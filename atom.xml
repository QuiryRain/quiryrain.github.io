<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuiryRain的博客</title>
  
  
  <link href="https://blog.qaz327zz.tk/atom.xml" rel="self"/>
  
  <link href="https://blog.qaz327zz.tk/"/>
  <updated>2020-07-24T00:20:49.591Z</updated>
  <id>https://blog.qaz327zz.tk/</id>
  
  <author>
    <name>QuiryRain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask学习之路</title>
    <link href="https://blog.qaz327zz.tk/200720/"/>
    <id>https://blog.qaz327zz.tk/200720/</id>
    <published>2020-07-19T15:54:26.000Z</published>
    <updated>2020-07-24T00:20:49.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程是可单独管理的最小指令集</p></blockquote><table><thead><tr><th align="left">变量名</th><th align="left">上下文</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">current_app</td><td align="left">程序上下文</td><td align="left">当前激活程序的程序实例</td></tr><tr><td align="left">g</td><td align="left">程序上下文</td><td align="left">处理请求时用作临时存储的对象。每次请求都会重设</td></tr><tr><td align="left">request</td><td align="left">请求上下文</td><td align="left">请求对象，封装了客户端发出的http请求中的内容</td></tr><tr><td align="left">session</td><td align="left">请求上下文</td><td align="left">用户会话，用于存储请求之间需要“记住”的值的字典</td></tr></tbody></table><p>Flask 在分发请求之前激活（或推送）程序和请求上下文，请求处理完成后再将其删除。</p><span id="more"></span><h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">请求页面，并返回页面内容</td></tr><tr><td align="left">HEAD</td><td align="left">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">POST</td><td align="left">大多用于提交表单或上传文件，数据包含在请求体中</td></tr></tbody></table><h3 id="常见的错误代码及错误原因"><a href="#常见的错误代码及错误原因" class="headerlink" title="常见的错误代码及错误原因"></a>常见的错误代码及错误原因</h3><table><thead><tr><th align="left">状态码</th><th align="left">说明</th><th align="left">详情</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">继续</td><td align="left">请求者应当继续提出请求。服务器已经收到请求的部分内容，正在等待其余部分</td></tr><tr><td align="left">101</td><td align="left">切换协议</td><td align="left">请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr><tr><td align="left">200</td><td align="left">成功</td><td align="left">服务器已成功处理了请求</td></tr><tr><td align="left">201</td><td align="left">已创建</td><td align="left">请求成功并企鹅服务器创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">已接受</td><td align="left">服务器已接受请求，但尚未处理</td></tr><tr><td align="left">203</td><td align="left">非授权信息</td><td align="left">服务器已成功处理了请求，但返回的信息可能来自另个源</td></tr><tr><td align="left">204</td><td align="left">无内容</td><td align="left">服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td align="left">205</td><td align="left">重置内容</td><td align="left">服务器成功处理了请求，内容被重置</td></tr><tr><td align="left">206</td><td align="left">部分内容</td><td align="left">服务器成功处理部分请求</td></tr><tr><td align="left">300</td><td align="left">多种选择</td><td align="left">针对请求，服务器可执行多种操作</td></tr><tr><td align="left">301</td><td align="left">永久移动</td><td align="left">请求的网页已永久移动到新位置，即永久重定向</td></tr><tr><td align="left">302</td><td align="left">临时移动</td><td align="left">请求的页面暂时跳转到其他页面，即暂时重定向</td></tr><tr><td align="left">303</td><td align="left">查看其他位置</td><td align="left">如果原来的请求是POST，重定向目标文档应该通过GET提取</td></tr><tr><td align="left">304</td><td align="left">未修改</td><td align="left">此次请求返回的页面未修改，继续使用上次的资源</td></tr><tr><td align="left">305</td><td align="left">使用代理</td><td align="left">请求者应该使用代理访问该网页</td></tr><tr><td align="left">307</td><td align="left">临时重定向</td><td align="left">请求的资源临时从其他位置响应</td></tr><tr><td align="left">400</td><td align="left">错误请求</td><td align="left">服务器无法解析该请求</td></tr><tr><td align="left">401</td><td align="left">未授权</td><td align="left">请求没有进行身份验证或验证未通过</td></tr><tr><td align="left">403</td><td align="left">禁止访问</td><td align="left">服务器拒绝此请求</td></tr><tr><td align="left">404</td><td align="left">未找到</td><td align="left">服务器找不到请求的网页</td></tr><tr><td align="left">405</td><td align="left">方法禁用</td><td align="left">服务器禁用了请求中指定的方法</td></tr><tr><td align="left">406</td><td align="left">不接受</td><td align="left">无法使用请求的内容响应请求的网页</td></tr><tr><td align="left">407</td><td align="left">需要代理授权</td><td align="left">请求者需要使用代理授权</td></tr><tr><td align="left">408</td><td align="left">请求超时</td><td align="left">服务器请求超时</td></tr><tr><td align="left">409</td><td align="left">冲突</td><td align="left">服务器在完成请求时发生冲突</td></tr><tr><td align="left">410</td><td align="left">已删除</td><td align="left">请求的资源已永久删除</td></tr><tr><td align="left">411</td><td align="left">需要有效长度</td><td align="left">服务器不接受不包含有效内容长度标头字段的请求</td></tr><tr><td align="left">412</td><td align="left">未满足前提条件</td><td align="left">服务器未满足请求者在请求中设置的其中一个前提条件</td></tr><tr><td align="left">413</td><td align="left">请求实体过大</td><td align="left">请求实体过大，超出服务器的处理能力</td></tr><tr><td align="left">414</td><td align="left">请求URI过长</td><td align="left">请求网址过长，服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">不支持类型</td><td align="left">请求格式不被请求页面支持</td></tr><tr><td align="left">416</td><td align="left">请求范围不符</td><td align="left">页面无法提供请求的范围</td></tr><tr><td align="left">417</td><td align="left">未满足期望值</td><td align="left">服务器未满足期望请求标头字段的要求</td></tr><tr><td align="left">500</td><td align="left">服务器内部错误</td><td align="left">服务器遇到错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">未实现</td><td align="left">服务器不具备完成请求的功能</td></tr><tr><td align="left">502</td><td align="left">错误网关</td><td align="left">服务器作为网关或代理，从上游服务器收到无效响应</td></tr><tr><td align="left">503</td><td align="left">服务不可用</td><td align="left">服务器目前无法使用</td></tr><tr><td align="left">504</td><td align="left">网管超时</td><td align="left">服务器作为网关或代理，但是没有及时从上游服务器收到请求</td></tr><tr><td align="left">505</td><td align="left">HTTP版本不支持</td><td align="left">服务器不支持请求中所用的HTTP协议版本</td></tr></tbody></table><h3 id="常用的匹配规则"><a href="#常用的匹配规则" class="headerlink" title="常用的匹配规则"></a>常用的匹配规则</h3><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\w</td><td align="left">匹配字母、数字及下划线</td></tr><tr><td align="left">\W</td><td align="left">匹配不是字母、数字及下划线的字符</td></tr><tr><td align="left">\s</td><td align="left">匹配任意空白字符，等价于[\t\n\r\f]</td></tr><tr><td align="left">\S</td><td align="left">匹配任意非空白字符</td></tr><tr><td align="left">\d</td><td align="left">匹配任意数字，等价于[0-9]</td></tr><tr><td align="left">\D</td><td align="left">匹配任意非数字的字符</td></tr><tr><td align="left">\A</td><td align="left">匹配字符串开头</td></tr><tr><td align="left">\Z</td><td align="left">匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td></tr><tr><td align="left">\z</td><td align="left">匹配字符串结尾，如果存在换行，同时还会匹配换行符</td></tr><tr><td align="left">\G</td><td align="left">匹配最后匹配完成的位置</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符</td></tr><tr><td align="left">^</td><td align="left">匹配一行字符串的开头</td></tr><tr><td align="left">$</td><td align="left">匹配一行字符串的结尾</td></tr><tr><td align="left">.</td><td align="left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符</td></tr><tr><td align="left">[…]</td><td align="left">用来表示一组字符，单独列出，比如[amk]匹配a、m或k</td></tr><tr><td align="left">[^…]</td><td align="left">不在[]中的字符，比如[^abc]匹配除了a、b、c之外的字符</td></tr><tr><td align="left">*</td><td align="left">匹配0个或多个表达式</td></tr><tr><td align="left">+</td><td align="left">匹配1个或多个表达式</td></tr><tr><td align="left">?</td><td align="left">匹配0个或1个前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td align="left">{n}</td><td align="left">精确匹配n个前面的表达式</td></tr><tr><td align="left">{n, m}</td><td align="left">匹配n到m次由前面正则表达式定义的片段，贪婪方式</td></tr><tr><td align="left">a|b</td><td align="left">匹配a或b</td></tr><tr><td align="left">()</td><td align="left">匹配括号内的表达式，也表示一个组</td></tr></tbody></table><h3 id="Python中的正则修饰符"><a href="#Python中的正则修饰符" class="headerlink" title="Python中的正则修饰符"></a>Python中的正则修饰符</h3><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">re.I</td><td align="left">使匹配对大小写不敏感</td></tr><tr><td align="left">re.L</td><td align="left">做本地化识别(locale-aware)匹配</td></tr><tr><td align="left">re.M</td><td align="left">多行匹配，影响<code>^</code>和<code>$</code></td></tr><tr><td align="left">re.S</td><td align="left">使<code>.</code>匹配包括换行符在内的所有字符</td></tr><tr><td align="left">re.U</td><td align="left">根据Unicode字符集解析字符。影响<code>\w</code>、<code>\W</code>、<code>\b</code>和<code>\B</code></td></tr><tr><td align="left">re.X</td><td align="left">该标志通过给予你更灵活的格式以便你将正则表达式写的更易于理解</td></tr></tbody></table><p><em>在网页匹配中，常用<code>re.S</code>和<code>re.I</code></em></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;线程是可单独管理的最小指令集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;变量名&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;上下文&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;current_app&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;程序上下文&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;当前激活程序的程序实例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;g&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;程序上下文&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;处理请求时用作临时存储的对象。每次请求都会重设&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;request&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;请求上下文&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;请求对象，封装了客户端发出的http请求中的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;session&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;请求上下文&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;用户会话，用于存储请求之间需要“记住”的值的字典&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Flask 在分发请求之前激活（或推送）程序和请求上下文，请求处理完成后再将其删除。&lt;/p&gt;</summary>
    
    
    
    <category term="上下文全局变量" scheme="https://blog.qaz327zz.tk/categories/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
    
    <category term="Flask" scheme="https://blog.qaz327zz.tk/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>CSS选择器</title>
    <link href="https://blog.qaz327zz.tk/20200712/"/>
    <id>https://blog.qaz327zz.tk/20200712/</id>
    <published>2020-07-12T12:41:29.000Z</published>
    <updated>2020-07-13T00:25:48.468Z</updated>
    
    <content type="html"><![CDATA[<p>“CSS” 列指示该属性是在哪个 CSS 版本中定义的。（CSS1、CSS2 还是 CSS3。）</p><span id="more"></span><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">示例说明</th><th align="left">CSS版本</th></tr></thead><tbody><tr><td align="left">.class</td><td align="left">.intro</td><td align="left">选择所有class&#x3D;”intro”的元素</td><td align="left">1</td></tr><tr><td align="left">#id</td><td align="left">#firstname</td><td align="left">选择所有id&#x3D;”firstname”的元素</td><td align="left">1</td></tr><tr><td align="left">*</td><td align="left">*</td><td align="left">选择所有元素</td><td align="left">2</td></tr><tr><td align="left">element</td><td align="left">p</td><td align="left">选择所有 <code>&lt;p&gt;</code> 元素</td><td align="left">1</td></tr><tr><td align="left">element,element</td><td align="left">div,p</td><td align="left">选择所有<code>&lt;div&gt;</code>元素和<code>&lt;p&gt;</code>元素</td><td align="left">1</td></tr><tr><td align="left">element element</td><td align="left">div p</td><td align="left">选择<code>&lt;div&gt;</code>元素内所有的<code>&lt;p&gt;</code>元素</td><td align="left">1</td></tr><tr><td align="left">element&gt;element</td><td align="left">div&gt;p</td><td align="left">选择所有父级是<code>&lt;div&gt;</code>元素的<code>&lt;p&gt;</code>元素</td><td align="left">2</td></tr><tr><td align="left">element+element</td><td align="left">div+p</td><td align="left">选择所有紧接着<code>&lt;div&gt;</code>元素之后的<code>&lt;p&gt;</code>元素</td><td align="left">2</td></tr><tr><td align="left">[attribute]</td><td align="left">[target]</td><td align="left">选择所有带有target属性的元素</td><td align="left">2</td></tr><tr><td align="left">[attribute&#x3D;value]</td><td align="left">[target&#x3D;_blank]</td><td align="left">选择所有使用<code>target=&quot;_blank&quot;</code>的元素</td><td align="left">2</td></tr><tr><td align="left">[attribute~&#x3D;value]</td><td align="left">[title~&#x3D;flower]</td><td align="left">选择 title 属性包含单词 “flower” 的所有元素素</td><td align="left">2</td></tr><tr><td align="left">[attribute|&#x3D;language]</td><td align="left">[lang|&#x3D;en]</td><td align="left">选择 lang 属性值以 “en” 开头的所有元素</td><td align="left">2</td></tr><tr><td align="left">:link</td><td align="left">a:link</td><td align="left">选择所有未访问链接</td><td align="left">1</td></tr><tr><td align="left">:visited</td><td align="left">a:visited</td><td align="left">选择所有访问过的链接</td><td align="left">1</td></tr><tr><td align="left">:active</td><td align="left">a:active</td><td align="left">选择所有活动链接</td><td align="left">1</td></tr><tr><td align="left">:hover</td><td align="left">a:hover</td><td align="left">选择鼠标指针位于其上的链接</td><td align="left">1</td></tr><tr><td align="left">:focus</td><td align="left">input:focus</td><td align="left">选择获得焦点的 input 元素</td><td align="left">2</td></tr><tr><td align="left">:first-letter</td><td align="left">p:first-letter</td><td align="left">选择每一个<code>&lt;p&gt;</code>元素的首字母</td><td align="left">1</td></tr><tr><td align="left">:first-line</td><td align="left">p:first-line</td><td align="left">选择每一个<code>&lt;p&gt;</code>元素的首行</td><td align="left">1</td></tr><tr><td align="left">:first-child</td><td align="left">p:first-child</td><td align="left">选择属于父元素的第一个子元素的每个 <code>&lt;p&gt;</code> 元素</td><td align="left">2</td></tr><tr><td align="left">:before</td><td align="left">p:before</td><td align="left">在每个<code>&lt;p&gt;</code> 元素的内容之前插入内容</td><td align="left">2</td></tr><tr><td align="left">:after</td><td align="left">p:after</td><td align="left">在每个 <code>&lt;p&gt;</code> 元素的内容之后插入内容</td><td align="left">2</td></tr><tr><td align="left">:lang(language)</td><td align="left">p:lang(it)</td><td align="left">选择带有以 “it” 开头的 lang 属性值的每个 <code>&lt;p&gt;</code> 元素</td><td align="left">2</td></tr><tr><td align="left">element1~element2</td><td align="left">p~ul</td><td align="left">选择前面有<code>&lt;p&gt;</code>元素的每个<code>&lt;ul&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">[attribute^&#x3D;value]</td><td align="left">a[src^&#x3D;”https”]</td><td align="left">选择其 src 属性值以 “https” 开头的每个 <code>&lt;a&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">[attribute$&#x3D;value]</td><td align="left">a[src$&#x3D;”.pdf”]</td><td align="left">选择其 src 属性以 “.pdf” 结尾的所有 <code>&lt;a&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">[attribute*&#x3D;value]</td><td align="left">a[src*&#x3D;”abc”]</td><td align="left">选择其 src 属性中包含 “abc” 子串的每个 <code>&lt;a&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:first-of-type</td><td align="left">p:first-of-type</td><td align="left">选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:last-of-type</td><td align="left">p:last-of-type</td><td align="left">选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:only-of-type</td><td align="left">p:only-of-type</td><td align="left">选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:only-child</td><td align="left">p:only-child</td><td align="left">选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:nth-child(n)</td><td align="left">p:nth-child(2)</td><td align="left">选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:nth-last-child(n)</td><td align="left">p:nth-lat-child(2)</td><td align="left">选择属于其父元素的倒数第二个子元素的每个 <code>&lt;p</code>&gt; 元素</td><td align="left">3</td></tr><tr><td align="left">:nth-of-type(n)</td><td align="left">p:nth-of-type(2)</td><td align="left">选择属于其父元素第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:nth-last-of-type(n)</td><td align="left">p:nth-last-of-type(2)</td><td align="left">选择属于其父元素倒数第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:last-child</td><td align="left">p:last-child</td><td align="left">选择属于其父元素最后一个子元素每个 <code>&lt;p&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:root</td><td align="left">:root</td><td align="left">选择文档的根元素</td><td align="left">3</td></tr><tr><td align="left">:empty</td><td align="left">p:empty</td><td align="left">选择没有子元素的每个 <code>&lt;p&gt;</code> 元素（包括文本节点）</td><td align="left">3</td></tr><tr><td align="left">:target</td><td align="left">#news:target</td><td align="left">选择当前活动的 #news 元素</td><td align="left">3</td></tr><tr><td align="left">:enabled</td><td align="left">input:enabled</td><td align="left">选择每个启用的 <code>&lt;input&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:disabled</td><td align="left">input:disabled</td><td align="left">选择每个禁用的 <code>&lt;input&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:checked</td><td align="left">input:checked</td><td align="left">选择每个被选中的 <code>&lt;input&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:not(selector)</td><td align="left">:not(p)</td><td align="left">选择非<code>&lt;p&gt;</code> 元素的每个元素</td><td align="left">3</td></tr><tr><td align="left">:out-of-range</td><td align="left">:out-of-range</td><td align="left">匹配值在指定区间之外的input元素</td><td align="left">3</td></tr><tr><td align="left">:in-range</td><td align="left">:in-range</td><td align="left">匹配值在指定区间之内的input元素</td><td align="left">3</td></tr><tr><td align="left">:read-write</td><td align="left">:read-write</td><td align="left">用于匹配可读及可写的元素</td><td align="left">3</td></tr><tr><td align="left">:read-only</td><td align="left">:read-only</td><td align="left">用于配置只读属性的元素</td><td align="left">3</td></tr><tr><td align="left">:optional</td><td align="left">:optional</td><td align="left">用于匹配可选的输入元素</td><td align="left">3</td></tr><tr><td align="left">:required</td><td align="left">:required</td><td align="left">用于匹配设置了<code>required</code>属性的元素</td><td align="left">3</td></tr><tr><td align="left">:valid</td><td align="left">:valid</td><td align="left">用于匹配输入值为合法的元素</td><td align="left">3</td></tr><tr><td align="left">:invalid</td><td align="left">:invalid</td><td align="left">用于匹配输入值为非法的元素</td><td align="left">3</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;“CSS” 列指示该属性是在哪个 CSS 版本中定义的。（CSS1、CSS2 还是 CSS3。）&lt;/p&gt;</summary>
    
    
    
    <category term="lxml" scheme="https://blog.qaz327zz.tk/categories/lxml/"/>
    
    
    <category term="lxml" scheme="https://blog.qaz327zz.tk/tags/lxml/"/>
    
    <category term="CSS" scheme="https://blog.qaz327zz.tk/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Pip 更新所有包</title>
    <link href="https://blog.qaz327zz.tk/20200412/"/>
    <id>https://blog.qaz327zz.tk/20200412/</id>
    <published>2020-04-12T09:21:53.000Z</published>
    <updated>2020-04-12T09:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看可更新包：</span><br><span class="line">pip <span class="built_in">list</span>  --outdated --<span class="built_in">format</span>=columns</span><br><span class="line">批量下载并更新：</span><br><span class="line">pip install pip-review</span><br><span class="line">pip-review --local --interactive</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="Python后端" scheme="https://blog.qaz327zz.tk/categories/Python%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Pip" scheme="https://blog.qaz327zz.tk/tags/Pip/"/>
    
  </entry>
  
  <entry>
    <title>Mac中使用Navicat Premium</title>
    <link href="https://blog.qaz327zz.tk/191217/"/>
    <id>https://blog.qaz327zz.tk/191217/</id>
    <published>2019-12-17T03:04:14.000Z</published>
    <updated>2019-12-17T23:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="给一个飞机链接"><a href="#给一个飞机链接" class="headerlink" title="给一个飞机链接"></a>给一个飞机链接</h3><p>链接1：<a href="https://linan.blog/2019/Navicat-Premium2/">起飞</a><br>链接2：<a href="https://hacpai.com/article/1571890862655">起飞</a></p><h3 id="Navicat-Keygen"><a href="#Navicat-Keygen" class="headerlink" title="Navicat Keygen"></a>Navicat Keygen</h3><p>由于原文的中的navicat-keygen无法使用了，可以采用以下的一个，效果相同</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/kervin521/navicat-keygen</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;给一个飞机链接&quot;&gt;&lt;a href=&quot;#给一个飞机链接&quot; class=&quot;headerlink&quot; title=&quot;给一个飞机链接&quot;&gt;&lt;/a&gt;给一个飞机链接&lt;/h3&gt;&lt;p&gt;链接1：&lt;a href=&quot;https://linan.blog/2019/Navicat-Premi</summary>
      
    
    
    
    <category term="激活" scheme="https://blog.qaz327zz.tk/categories/%E6%BF%80%E6%B4%BB/"/>
    
    
    <category term="Mac" scheme="https://blog.qaz327zz.tk/tags/Mac/"/>
    
    <category term="破解" scheme="https://blog.qaz327zz.tk/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>通过图像像素值对图像进行降噪处理</title>
    <link href="https://blog.qaz327zz.tk/191028/"/>
    <id>https://blog.qaz327zz.tk/191028/</id>
    <published>2019-10-28T04:53:58.000Z</published>
    <updated>2020-07-14T00:14:58.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何更好获取图像的像素值"><a href="#如何更好获取图像的像素值" class="headerlink" title="如何更好获取图像的像素值"></a>如何更好获取图像的像素值</h3><p>对于一张彩色的验证码，肯定少不了RBG三通道或者是RGBA四通道，其中在四通道的图像中，是在原来的基础上加上了alpha通道，即透明度。</p><p>彩色的图像虽然人为可以更好的区分，但是对于机器而言，并不能去区分。因此如何让机器进行区分这就是接下来要说明的问题。</p><p>首先，对于人而言，彩色的图像有时候是很容易区分出来的，对于机器而言，灰色或者黑白的图像才是机器容易识别的。因此，对于有颜色上区别的验证码而言，可以使用像素值过滤的方式进行降噪。当然，该方法只能解决部分，并不是通用的方法。</p><span id="more"></span><p>在开始接下来的内容之前需要先明白灰度值的计算公式:<code>Gray = R*0.299 + G*0.587 + B*0.114</code>，该公式为一个心理公式。</p><p>之后对于黑白图像，在图像中0表示黑色，255表示白色。</p><h3 id="图像降噪处理之图像灰度化转换"><a href="#图像降噪处理之图像灰度化转换" class="headerlink" title="图像降噪处理之图像灰度化转换"></a>图像降噪处理之图像灰度化转换</h3><p>以下代码均运行在jupyter notebook中。</p><p>开篇来张图：</p><p><img src="/userImages/a.jpeg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">filenames = glob.glob(<span class="string">&#x27;images/*.jpeg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">filename = filenames[<span class="number">0</span>]</span><br><span class="line">img = plt.imread(filename)</span><br><span class="line"></span><br><span class="line">plt.imshow(img)</span><br></pre></td></tr></table></figure><p>对于给出的这张图片可以很明显的看出，可以根据不同的颜色进行图像降噪、去干绕线。</p><p>首先需要将彩色图片转为灰色图片，这样才能保证多通道的数据图像变成单通道的数据图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rgb2gray</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(img[...,:<span class="number">3</span>], [<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>])</span><br><span class="line"></span><br><span class="line">gray = rgb2gray(img)</span><br><span class="line"></span><br><span class="line">plt.imshow(gray, cmap = plt.get_cmap(<span class="string">&#x27;gray&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="/userImages/a_gray.png"></p><p>在将图像转化为灰度图像之后，就可以很明显的看出，图像的像素值由原来的三通道变成了单通道数据。</p><p><img src="/userImages/2019-10-28-00.png"></p><h3 id="图像降噪处理之灰度图像像素值平均值"><a href="#图像降噪处理之灰度图像像素值平均值" class="headerlink" title="图像降噪处理之灰度图像像素值平均值"></a>图像降噪处理之灰度图像像素值平均值</h3><p>平均值，是反应一组数据的最好表现。在图像像素值中，通过平均值进行过滤可以达到意想不到的效果。</p><p>如果一张图片中有很多无关紧要的干扰因素，如空白区域，可以考虑将图像的像素值进行设定到一定的范围中，这样就是这些验证码的平均像素值了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">avg_image</span>(<span class="params">image, w, h</span>):</span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="keyword">if</span> image[i, j] &lt; <span class="number">180</span>:</span><br><span class="line">                points.append(image[i, j])</span><br><span class="line"></span><br><span class="line">    avg_point = <span class="built_in">sum</span>(points) // <span class="built_in">len</span>(points)</span><br><span class="line">    <span class="keyword">return</span> avg_point</span><br><span class="line"></span><br><span class="line">w,h = gray.shape</span><br><span class="line"></span><br><span class="line">avg_point = avg_image(gray, w, h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">cgray = copy.copy(gray)</span><br></pre></td></tr></table></figure><p><img src="/userImages/2019-10-28-01.png"></p><h3 id="图像降噪处理之像素值的增强与削弱"><a href="#图像降噪处理之像素值的增强与削弱" class="headerlink" title="图像降噪处理之像素值的增强与削弱"></a>图像降噪处理之像素值的增强与削弱</h3><p>在此处我们规定，图像的削弱点为平均值的像素值，这样可以保证对深颜色的再次加深，浅色的再次削弱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">        r = gray[i, j] - avg_point</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">1</span>:</span><br><span class="line">            cgray[i, j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> r &gt; <span class="number">0</span>:</span><br><span class="line">            cgray[i, j] = <span class="number">255</span></span><br></pre></td></tr></table></figure><p>在经过上述处理后，效果就变为</p><p><img src="/userImages/2019-10-30-00.png"></p><h3 id="图像降噪处理之8邻域、4邻域降噪"><a href="#图像降噪处理之8邻域、4邻域降噪" class="headerlink" title="图像降噪处理之8邻域、4邻域降噪"></a>图像降噪处理之8邻域、4邻域降噪</h3><p> <code>8邻域降噪</code> 的前提是将图片灰度化，即将彩色图像转化为灰度图像。以RGN色彩空间为例，彩色图像中每个像素的颜色由R 、G、B三个分量决定，每个分量由0到255种取值，这个一个像素点可以有一千多万种颜色变化。而灰度则是将三个分量转化成一个，使每个像素点只有0-255种取值，这样可以使后续的图像计算量变得少一些。</p><p>图片越接近白色的点像素越接近255，越接近黑色的点像素越接近0，而且验证码字符肯定是非白色的。对于其中噪点大部分都是孤立的小点的，而且字符都是串联在一起的。<code>8邻域降噪</code> 的原理就是依次遍历图中所有非白色的点，计算其周围8个点中属于非白色点的个数，如果数量小于一个固定值，那么这个点就是噪点。对于不同类型的验证码这个阈值是不同的，所以可以在程序中配置，不断尝试找到最佳的阈值  。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">depoint</span>(<span class="params">img, k</span>):</span><br><span class="line">    pixdata = img</span><br><span class="line">    w, h = img.shape</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, w-<span class="number">1</span>):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y - <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y + <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x - <span class="number">1</span>, y] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x + <span class="number">1</span>, y] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x - <span class="number">1</span>, y - <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x - <span class="number">1</span>, y + <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x + <span class="number">1</span>, y - <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x + <span class="number">1</span>, y + <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; k:</span><br><span class="line">                pixdata[x, y] = <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> pixdata</span><br><span class="line"></span><br><span class="line">np_img = depoint(cgray, <span class="number">8</span>)</span><br><span class="line">np_img = depoint(np_img, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/userImages/2019-10-30-01.png"></p><p>虽然看起来效果和经过像素值削弱过的图像没有两样，这是因为，在图像经过像素值调整的时候直接将图像的像素值做了调整，如果将两者顺序进行调整，将会看到不同效果。</p><h3 id="图像降噪处理之pycapt库的使用"><a href="#图像降噪处理之pycapt库的使用" class="headerlink" title="图像降噪处理之pycapt库的使用"></a>图像降噪处理之pycapt库的使用</h3><p>之所以引用这个库，是因为在降噪的过程中，以上的方法会降噪不是很好，如上图，可以看出仍旧有两条干扰线，使用pycapt库是为了将剩余的噪音处理掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pycapt</span><br><span class="line">img = Image.fromarray(np_img.astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line">img = pycapt.dele_line(img, <span class="number">2</span>)</span><br><span class="line">img = pycapt.dele_noise(img, N=<span class="number">2</span>, Z=<span class="number">1</span>)</span><br><span class="line">img = pycapt.tran_90(img)</span><br><span class="line">img = pycapt.dele_line(img, <span class="number">2</span>)</span><br><span class="line">img = pycapt.dele_noise(img, N=<span class="number">2</span>, Z=<span class="number">1</span>)</span><br><span class="line">img = pycapt.tran_90(img)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/userImages/2019-10-30-02.png"></p><p>处理前的效果：</p><p><img src="/userImages/2019-10-30-01.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>图像降噪处理有很多的方法，此处只是使用了一种大众化的方法，该方法可以解决很多有色值差的图像，但是，效果并不是很好。所以想要好的降噪后的图像，需要不断的寻找更好的方法。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;如何更好获取图像的像素值&quot;&gt;&lt;a href=&quot;#如何更好获取图像的像素值&quot; class=&quot;headerlink&quot; title=&quot;如何更好获取图像的像素值&quot;&gt;&lt;/a&gt;如何更好获取图像的像素值&lt;/h3&gt;&lt;p&gt;对于一张彩色的验证码，肯定少不了RBG三通道或者是RGBA四通道，其中在四通道的图像中，是在原来的基础上加上了alpha通道，即透明度。&lt;/p&gt;
&lt;p&gt;彩色的图像虽然人为可以更好的区分，但是对于机器而言，并不能去区分。因此如何让机器进行区分这就是接下来要说明的问题。&lt;/p&gt;
&lt;p&gt;首先，对于人而言，彩色的图像有时候是很容易区分出来的，对于机器而言，灰色或者黑白的图像才是机器容易识别的。因此，对于有颜色上区别的验证码而言，可以使用像素值过滤的方式进行降噪。当然，该方法只能解决部分，并不是通用的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="https://blog.qaz327zz.tk/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
    <category term="降噪" scheme="https://blog.qaz327zz.tk/tags/%E9%99%8D%E5%99%AA/"/>
    
    <category term="像素值" scheme="https://blog.qaz327zz.tk/tags/%E5%83%8F%E7%B4%A0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>一次完整的HTTP请求过程</title>
    <link href="https://blog.qaz327zz.tk/190724/"/>
    <id>https://blog.qaz327zz.tk/190724/</id>
    <published>2019-07-24T01:45:34.000Z</published>
    <updated>2019-07-24T01:51:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一次完整的HTTP请求过程"><a href="#一次完整的HTTP请求过程" class="headerlink" title="一次完整的HTTP请求过程"></a>一次完整的HTTP请求过程</h3><p>搬运来的，直接上链接吧：</p><p>链接：<a href="https://www.cnblogs.com/xuzekun/p/7527736.html">飞机起飞</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一次完整的HTTP请求过程&quot;&gt;&lt;a href=&quot;#一次完整的HTTP请求过程&quot; class=&quot;headerlink&quot; title=&quot;一次完整的HTTP请求过程&quot;&gt;&lt;/a&gt;一次完整的HTTP请求过程&lt;/h3&gt;&lt;p&gt;搬运来的，直接上链接吧：&lt;/p&gt;
&lt;p&gt;链接：&lt;a </summary>
      
    
    
    
    <category term="HTTP" scheme="https://blog.qaz327zz.tk/categories/HTTP/"/>
    
    
    <category term="HTTP请求过程" scheme="https://blog.qaz327zz.tk/tags/HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>动态网页数据抓取</title>
    <link href="https://blog.qaz327zz.tk/190703/"/>
    <id>https://blog.qaz327zz.tk/190703/</id>
    <published>2019-07-03T07:50:19.000Z</published>
    <updated>2020-07-14T00:14:48.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态页面数据抓取"><a href="#动态页面数据抓取" class="headerlink" title="动态页面数据抓取"></a>动态页面数据抓取</h2><h3 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a>什么是AJAX</h3><p>AJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。在后台与服务器进行少量数据换时，可以在不重新加载整个网页的情况下，利用Ajax对网页实现异步更新。在传统的网页中，如果要获取更新内容，需要重新加载整个页面。因为传统的网页数据传输格式使用的是XML语法。在Ajax加载的网页中，数据的交互使用的是JSON格式。</p><span id="more"></span><h3 id="获取ajax数据的格式"><a href="#获取ajax数据的格式" class="headerlink" title="获取ajax数据的格式"></a>获取ajax数据的格式</h3><ol><li>直接分析ajax调用的接口，然后通过代码请求接口。</li><li>使用selenium+chromedriver模拟浏览器的行为获取数据。</li></ol><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分析接口</td><td>直接可以请求到数据，不需要做一些解析工具，代码量少，性能高。</td><td>分析接口比较复杂，特别是一些通过js混淆的接口，需要有js的功底。容易被发现是爬虫。</td></tr><tr><td>selenium</td><td>直接模拟浏览器的行为，浏览器能请求到的，使用selenium也同样可以获取。爬虫更稳定。</td><td>代码量多，性能低。</td></tr></tbody></table><h3 id="selenium-chromdriver获取动态数据"><a href="#selenium-chromdriver获取动态数据" class="headerlink" title="selenium + chromdriver获取动态数据"></a>selenium + chromdriver获取动态数据</h3><p>Selenium是一个自动化测试工具，可以在模拟人类在浏览器上的行为，自动处理浏览器上的一些行为，如点击，填充数据，删除cookie等。chromedriver是一个chrome浏览器的驱动程序。</p><p>Chromedriver：<a href="http://npm.taobao.org/mirrors/chromedriver">http://npm.taobao.org/mirrors/chromedriver</a></p><h3 id="安装Selenium和chromedriver"><a href="#安装Selenium和chromedriver" class="headerlink" title="安装Selenium和chromedriver"></a>安装Selenium和chromedriver</h3><ol><li>安装selenium：<code>pip install selenium</code></li><li>安装chromedriver：下载完毕后，放到自己能找到的英文目录中即可。</li></ol><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>以一个例子快速开始</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver_path = <span class="string">&#x27;./driver/chromedriver.exe&#x27;</span></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line"></span><br><span class="line">driver.get(url)</span><br><span class="line"><span class="built_in">print</span>(driver.page_source)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p>在运行之后会出现一个浏览器框，并自动的访问百度</p><h3 id="selenium官方文档"><a href="#selenium官方文档" class="headerlink" title="selenium官方文档"></a>selenium官方文档</h3><p><a href="https://selenium-python.readthedocs.io/index.html">https://selenium-python.readthedocs.io/index.html</a></p><h3 id="关闭页面"><a href="#关闭页面" class="headerlink" title="关闭页面"></a>关闭页面</h3><ol><li>driver.close()：关闭当前页面</li><li>driver.quit()：退出整个浏览器</li></ol><h3 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h3><ol><li><p><code>find_element_by_id</code>：根据id查找某个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submitTag = driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.ID, <span class="string">&#x27;su&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>find_element_by_class_name</code>：根据类名查找元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submitTag = driver.find_element_by_class_name(<span class="string">&#x27;s_ipt&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.CLASS, <span class="string">&#x27;s_ipt&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>find_element_by_name</code>：根据name属性的值来查找元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submitTag = driver.find_element_by_name(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.NAME,<span class="string">&#x27;email&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>find_element_by_tag_name</code>：根据标签名来查找元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submitTag = driver.find_element_by_tag_name(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.TAG_NAME,<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>find_element_by_xpath</code>：根据xpath语法来获取元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submitTag = driver.find_element_by_xpath(<span class="string">&#x27;//div&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.XPATH,<span class="string">&#x27;//div&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>find_element_by_css_selector</code>：根据css选择器选择元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">submitTag = driver.find_element_by_css_selector(<span class="string">&#x27;//div&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.CSS_SELECTOR,<span class="string">&#x27;//div&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>By</code>模块导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br></pre></td></tr></table></figure></li></ol><p><em>注意</em>：<code>find_element</code>是获取第一个满足条件的元素。<code>find_elements</code>是获取所有满足条件的元素</p><h3 id="操作表单元素"><a href="#操作表单元素" class="headerlink" title="操作表单元素"></a>操作表单元素</h3><ol><li><p>在操作输入框时需要分为两步，一：找到表单元素，二：填充数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputTag = driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">inputTag.send_keys(<span class="string">&quot;Python&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用clear方法可以清除输入框中的内容</p><p><code>inputTag.clear()</code></p></li><li><p>操作checkbox时，需要先选中checkbox标签，然后执行click事件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rememberTag = driver.find_element_by_name(<span class="string">&quot;rememberMe&quot;</span>)</span><br><span class="line">rememberTag.click()</span><br></pre></td></tr></table></figure></li><li><p>选择select时，不能直接点击，因为点击后还需要选中元素。因此在selenium中专门为select标签设置了一个类<code>selenium.webdriver.support.ui.Select</code>。将获取到的元素当成参数传到这个类中，创建这个对象，之后就可以使用这个对象进行选择了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line"><span class="comment">### 选中标签创建对象</span></span><br><span class="line">selectTag = Select(driver.find_element_by_name(<span class="string">&quot;jumpMenu&quot;</span>))</span><br><span class="line"><span class="comment">### 根据索引选择</span></span><br><span class="line">selectTag.select_by_index(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 根据值选择</span></span><br><span class="line">selectTag.select_by_value(<span class="string">&quot;https://www.python.org&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 根据可视化文本选择</span></span><br><span class="line">selectTag.select_by_visible_text(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 取消选中的所有选项</span></span><br><span class="line">selectTag.deselect_all()</span><br></pre></td></tr></table></figure></li><li><p>操作按钮：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputTag = driver.find_element_by_id(<span class="string">&quot;su&quot;</span>)</span><br><span class="line">inputTag.click()</span><br></pre></td></tr></table></figure></li></ol><h3 id="行为链"><a href="#行为链" class="headerlink" title="行为链"></a>行为链</h3><p>有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类<code>ActionChains</code>来完成。如将鼠标移到某个元素并执行点击事件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inputTag = driver.find_element(By.ID, <span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">submitTag = driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"></span><br><span class="line">actions = webdriver.ActionChains(driver)</span><br><span class="line">actions.move_to_element(inputTag)</span><br><span class="line">actions.send_keys_to_element(inputTag, <span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line">actions.move_to_element(submitTag)</span><br><span class="line">actions.click(submitTag)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p>更多鼠标相关操作</p><ul><li>click_and_hold(element)：点击但不松开鼠标</li><li>context_click(element)：右键点击</li><li>double_click(element)：双击</li></ul><p>更多方法：<a href="https://selenium-python.readthedocs.io/api.html">https://selenium-python.readthedocs.io/api.html</a></p><h3 id="Cookie操作"><a href="#Cookie操作" class="headerlink" title="Cookie操作"></a>Cookie操作</h3><ol><li><p>获取所有的cookie</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> driver.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(cookie)</span><br></pre></td></tr></table></figure></li><li><p>根据cookie的key获取value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = driver.get_cookie(key)</span><br></pre></td></tr></table></figure></li><li><p>删除所有的cookie</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.delete_all_cookies()</span><br></pre></td></tr></table></figure></li><li><p>删除某个cookie</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.delete_cookie(key)</span><br></pre></td></tr></table></figure></li></ol><h3 id="页面等待"><a href="#页面等待" class="headerlink" title="页面等待"></a>页面等待</h3><p>现在的网页多采用 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，在使用了WebElement时，就会抛出NullPointer的异常。为了解决这个问题。所以 Selenium 提供了两种等待方式：一种是隐式等待、一种是显式等待。</p><ul><li><p>隐式等待</p><p>调用<code>driver.implicitly_wait</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 请求网页</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.douban.com/&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>显式等待</p><p>显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用<code>selenium.webdriver.support.excepted_conditions</code>期望的条件和<code>selenium.webdriver.support.ui.WebDriverWait</code>来配合完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">&quot;http://somedomain/url_that_delays_loading&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">&quot;myDynamicElement&quot;</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure></li><li><p>其他的等待条件</p><ol><li><code>presence_of_element_located</code>：某个元素已经加载完毕了。</li><li><code>presence_of_all_emement_located</code>：网页中所有满足条件的元素都加载完毕了。</li><li><code>element_to_be_cliable</code>：某个元素是可以点击了。</li></ol><p>更多条件请参考：<a href="http://selenium-python.readthedocs.io/waits.html">http://selenium-python.readthedocs.io/waits.html</a></p></li></ul><h3 id="切换页面"><a href="#切换页面" class="headerlink" title="切换页面"></a>切换页面</h3><p>在切换页面时，<code>selenium</code>提供了一个叫做<code>switch_to_window</code>来进行切换，具体切换到哪个页面，可以从<code>driver.window_handles</code>中找到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个新的页面</span></span><br><span class="line">self.driver.execute_script(<span class="string">&quot;window.open(&#x27;&quot;</span>+url+<span class="string">&quot;&#x27;)&quot;</span>)</span><br><span class="line"><span class="comment"># 切换到这个新的页面中</span></span><br><span class="line">self.driver.switch_to_window(self.driver.window_handles[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--proxy-server=http://113.12.202.50:50327&quot;</span>)</span><br><span class="line">driver_path = <span class="string">&quot;./driver/chromedriver.exe&quot;</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path, options=options)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&#x27;http://httpbin.org/ip&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><h3 id="WebElement元素"><a href="#WebElement元素" class="headerlink" title="WebElement元素"></a>WebElement元素</h3><p><code>from selenium.webdriver.remote.webelement import WebElement</code>类是每个获取出来的元素的所属类</p><p>常用属性：</p><ol><li>get_attribute：这个标签的某个属性的值。</li><li>screentshot：获取当前页面的截图。这个方法只能在<code>driver</code>上使用。<code>driver</code>的对象类，也是继承自<code>WebElement</code>。</li></ol><h3 id="对带有页面嵌套的豆瓣进行登录"><a href="#对带有页面嵌套的豆瓣进行登录" class="headerlink" title="对带有页面嵌套的豆瓣进行登录"></a>对带有页面嵌套的豆瓣进行登录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver_path = <span class="string">&quot;./driver/chromedriver.exe&quot;</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.douban.com&#x27;</span>)</span><br><span class="line">iframe = driver.find_element_by_tag_name(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to.frame(iframe)</span><br><span class="line"></span><br><span class="line">login = driver.find_element_by_class_name(<span class="string">&quot;account-tab-account&quot;</span>)</span><br><span class="line"></span><br><span class="line">actions = webdriver.ActionChains(driver)</span><br><span class="line">actions.move_to_element(login)</span><br><span class="line">actions.click()</span><br><span class="line">actions.perform()</span><br><span class="line"></span><br><span class="line">username = driver.find_element_by_id(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">password = driver.find_element_by_id(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">submit = driver.find_element_by_xpath(<span class="string">&quot;//div[@class=&#x27;account-form-field-submit &#x27;]/a&quot;</span>)</span><br><span class="line"></span><br><span class="line">actions.move_to_element(username)</span><br><span class="line">actions.send_keys_to_element(username, <span class="string">&quot;your username&quot;</span>)</span><br><span class="line">actions.move_to_element(password)</span><br><span class="line">actions.send_keys_to_element(password, <span class="string">&quot;your password&quot;</span>)</span><br><span class="line">actions.move_to_element(submit)</span><br><span class="line">actions.click()</span><br><span class="line">actions.perform()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>注意：在使用以下内容时会出现警告信息，身为有代码洁癖的人，最不能忍受运行中出现警告信息。</p><p>警告信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeprecationWarning: use driver.switch_to.frame instead driver.switch_to_frame(iframe)</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iframe = driver.find_element_by_tag_name(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to_frame(iframe)</span><br></pre></td></tr></table></figure><p>将上文改为即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iframe = driver.find_element_by_tag_name(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to.frame(iframe)</span><br></pre></td></tr></table></figure><p>对框架的解决方式推荐一篇文章：<a href="https://www.cnblogs.com/dydxw/p/10551160.html">Selenium（十二）嵌套frame定位</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;动态页面数据抓取&quot;&gt;&lt;a href=&quot;#动态页面数据抓取&quot; class=&quot;headerlink&quot; title=&quot;动态页面数据抓取&quot;&gt;&lt;/a&gt;动态页面数据抓取&lt;/h2&gt;&lt;h3 id=&quot;什么是AJAX&quot;&gt;&lt;a href=&quot;#什么是AJAX&quot; class=&quot;headerlink&quot; title=&quot;什么是AJAX&quot;&gt;&lt;/a&gt;什么是AJAX&lt;/h3&gt;&lt;p&gt;AJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。在后台与服务器进行少量数据换时，可以在不重新加载整个网页的情况下，利用Ajax对网页实现异步更新。在传统的网页中，如果要获取更新内容，需要重新加载整个页面。因为传统的网页数据传输格式使用的是XML语法。在Ajax加载的网页中，数据的交互使用的是JSON格式。&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫" scheme="https://blog.qaz327zz.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="AJAX" scheme="https://blog.qaz327zz.tk/tags/AJAX/"/>
    
    <category term="Selenium" scheme="https://blog.qaz327zz.tk/tags/Selenium/"/>
    
    <category term="chromedriver" scheme="https://blog.qaz327zz.tk/tags/chromedriver/"/>
    
  </entry>
  
  <entry>
    <title>多线程爬虫</title>
    <link href="https://blog.qaz327zz.tk/190630/"/>
    <id>https://blog.qaz327zz.tk/190630/</id>
    <published>2019-06-30T07:33:40.000Z</published>
    <updated>2020-07-14T00:14:44.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程介绍"><a href="#多线程介绍" class="headerlink" title="多线程介绍"></a>多线程介绍</h3><p>多线程时为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。就好比多线程是火车的每一节车厢，而进程就是火车，车厢离开火车无法启动。多线程的出现是为了提高效率。</p><span id="more"></span><h3 id="threading模块介绍"><a href="#threading模块介绍" class="headerlink" title="threading模块介绍"></a>threading模块介绍</h3><p>threading模块是python中专门提供用来多线程编程的模块。threading模块中最常用的类是Thread。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coding</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> 正在写代码&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawing</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> 正在画图&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi_thread</span>():</span><br><span class="line">    t1 = threading.Thread(target=coding)</span><br><span class="line">    t2 = threading.Thread(target=drawing)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multi_thread()</span><br></pre></td></tr></table></figure><h4 id="查看线程数"><a href="#查看线程数" class="headerlink" title="查看线程数"></a>查看线程数</h4><p>使用threading.enumerate()函数可以看到当前线程的数量</p><h4 id="查看当前线程的名字"><a href="#查看当前线程的名字" class="headerlink" title="查看当前线程的名字"></a>查看当前线程的名字</h4><p>使用threading.current_thread()函数可以看到当前线程的信息。</p><h4 id="继承自threading-Thread类"><a href="#继承自threading-Thread类" class="headerlink" title="继承自threading.Thread类"></a>继承自threading.Thread类</h4><p>为了让线程代码得到更好的封装，可以使用到threading模块下的Thread类，继承自Thread类后，然后实现run方法，线程代码会自动运行run方法中的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodingThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread()&#125;</span> 正在写代码&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread()&#125;</span> 正在画图&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi_thread</span>():</span><br><span class="line">    t1 = CodingThread()</span><br><span class="line">    t2 = DrawingThread()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multi_thread()</span><br></pre></td></tr></table></figure><h4 id="多线程共享全局变量的问题"><a href="#多线程共享全局变量的问题" class="headerlink" title="多线程共享全局变量的问题"></a>多线程共享全局变量的问题</h4><p>多线程都是在同一个进程中运行的，因此在进程中的全局变量多有线程都是可共享的。由于线程执行的顺序是无序的，线程如果同时执行，有可能会造成数据错误。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">tickets = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ticket</span>():</span><br><span class="line">    <span class="keyword">global</span> tickets</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        tickets += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;tickets: <span class="subst">&#123;tickets&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=get_ticket)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>为了解决以上使用共享全局变量的问题，threading提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时无法使用，直到当前线程处理完成后，把锁释放，其他线程才能使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">tickets = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ticket</span>():</span><br><span class="line">    <span class="keyword">global</span> tickets</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        tickets += <span class="number">1</span></span><br><span class="line">    lock.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;tickets: <span class="subst">&#123;tickets&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=get_ticket)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>_注意_：lock锁加在修改全局变量的位置，如果只是访问全局变脸没有必要加锁。</p><h4 id="Lock生产者和消费者模式"><a href="#Lock生产者和消费者模式" class="headerlink" title="Lock生产者和消费者模式"></a>Lock生产者和消费者模式</h4><p>生产者和消费者模式是多线程开发中经常看到的一种模式。生产者的线程专门用来生产一些数据，然后存放在一个中间变量中。消费者再从这个中间变量中取出数据进行消费。但是因为要使用中间变量，中间变量由于经常是些全局变量，因此在使用的时候需要使用Lock锁来保证数据完整性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gMoney = <span class="number">1000</span></span><br><span class="line">gLock = threading.Lock()</span><br><span class="line"><span class="comment"># 记录生产者生产次数，在达到10次时停止生产</span></span><br><span class="line">gTimes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">            gLock.acquire()</span><br><span class="line">            <span class="keyword">if</span> gTimes &gt;= <span class="number">10</span>:</span><br><span class="line">                gLock.release()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            gMoney += money</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 当前存入 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元&quot;</span>)</span><br><span class="line">            gTimes += <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gLock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">500</span>)</span><br><span class="line">            gLock.acquire()</span><br><span class="line">            <span class="keyword">if</span> gMoney &gt; money:</span><br><span class="line">                gMoney -= money</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元&quot;</span>)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> gMoney &gt;= <span class="number">10</span>:</span><br><span class="line">                    gLock.release()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 想取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元，不足！&quot;</span>)</span><br><span class="line">            gLock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Consumer(name=<span class="string">f&quot;消费者线程<span class="subst">&#123;x&#125;</span>&quot;</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Producer(name=<span class="string">f&quot;生产者线程<span class="subst">&#123;x&#125;</span>&quot;</span>).start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="Condition生产者和消费者模式"><a href="#Condition生产者和消费者模式" class="headerlink" title="Condition生产者和消费者模式"></a>Condition生产者和消费者模式</h4><p>Lock中的生产者与消费者模式可以正常运行，但是存在一个问题，在消费者中，总是通过while死循环上锁的方式判断money的多少。由于上锁是一个很消耗CPU资源的行为，因此此方式不是最好的。还有一种更好的方式是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作，还可以提升程序的性能。threading.Condition类似threading.Lock，可以在修改全局数据的时候进行加锁，也可以在修改完毕后解锁。以下对部分常用函数进行简单介绍：</p><ol><li>acquire：上锁</li><li>release：解锁</li><li>wait：将当前线程处于等待状态，并且释放锁。可以被其他线程使用notify和notify_all函数进行唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。</li><li>notify：通知某个正在等待的线程，默认是第一个等待的线程。</li><li>notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gMoney = <span class="number">1000</span></span><br><span class="line">gCondition = threading.Condition()</span><br><span class="line"><span class="comment"># 记录生产者生产次数，在达到10次时停止生产</span></span><br><span class="line">gTimes = <span class="number">0</span></span><br><span class="line">gTotalTimes = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gCondition</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">            gCondition.acquire()</span><br><span class="line">            <span class="keyword">if</span> gTimes &gt;= gTotalTimes:</span><br><span class="line">                gCondition.release()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;当前生产者总共生产了<span class="subst">&#123;gTimes&#125;</span>次&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            gMoney += money</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 当前存入 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元&quot;</span>)</span><br><span class="line">            gTimes += <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gCondition.notify_all()</span><br><span class="line">            gCondition.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gCondition</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">500</span>)</span><br><span class="line">            gCondition.acquire()</span><br><span class="line">            <span class="keyword">while</span> gMoney &lt; money:</span><br><span class="line">                <span class="keyword">if</span> gTimes &gt;= gTotalTimes:</span><br><span class="line">                    gCondition.release()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 想取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元，不足！&quot;</span>)</span><br><span class="line">                gCondition.wait()</span><br><span class="line"></span><br><span class="line">            gMoney -= money</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gCondition.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Consumer(name=<span class="string">f&quot;消费者线程<span class="subst">&#123;x&#125;</span>&quot;</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Producer(name=<span class="string">f&quot;生产者线程<span class="subst">&#123;x&#125;</span>&quot;</span>).start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="Queue线程安全队列"><a href="#Queue线程安全队列" class="headerlink" title="Queue线程安全队列"></a>Queue线程安全队列</h3><p>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你想把一些数据存储到某个队列中，可以使用Python内置的Queue模块。Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO(先进先出)队列、LIFO(后进先出)队列。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列实现线程间的同步。相关函数：</p><ol><li>初始化Queue(maxsize)：创建一个先进先出的队列</li><li>qsize()：返回队列的大小</li><li>empty()：判断队列是否为空</li><li>full()：判断队列是否满了</li><li>get()：从队列中取最后一个数据</li><li>put()：将一个数据放到队列中</li></ol><h4 id="使用生产者消费者模式多线程下载表情包"><a href="#使用生产者消费者模式多线程下载表情包" class="headerlink" title="使用生产者消费者模式多线程下载表情包"></a>使用生产者消费者模式多线程下载表情包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(threading.Thread):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, page_queue, img_queue, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Producer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.img_queue = img_queue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.page_queue.empty():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            url = self.page_queue.get()</span><br><span class="line">            self.parse_page(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_page</span>(<span class="params">self, url</span>):</span><br><span class="line">        response = requests.get(url, headers=self.headers)</span><br><span class="line">        text = response.text</span><br><span class="line">        html = etree.HTML(text)</span><br><span class="line">        imgs = html.xpath(<span class="string">&#x27;//a[@class=&quot;col-xs-6 col-sm-3&quot;]/img&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> img <span class="keyword">in</span> imgs:</span><br><span class="line">            <span class="keyword">if</span> img.get(<span class="string">&#x27;class&#x27;</span>) == <span class="string">&#x27;gif&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            img_url = img.get(<span class="string">&#x27;data-original&#x27;</span>)</span><br><span class="line">            suffix = os.path.splitext(img_url)[<span class="number">1</span>].replace(<span class="string">&#x27;.null&#x27;</span>, <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">            alt = img.get(<span class="string">&#x27;alt&#x27;</span>)</span><br><span class="line">            alt = re.sub(<span class="string">r&#x27;[，。？！!?,/\\.]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, alt)</span><br><span class="line">            img_name = alt + suffix</span><br><span class="line">            self.img_queue.put((img_url, img_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(threading.Thread):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, page_queue, img_queue, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Consumer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.img_queue = img_queue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.img_queue.empty():</span><br><span class="line">                <span class="keyword">if</span> self.page_queue.empty():</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            img = self.img_queue.get(block=<span class="literal">True</span>)</span><br><span class="line">            url, filename = img</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;images&#x27;</span>):</span><br><span class="line">                os.makedirs(<span class="string">&#x27;images/&#x27;</span>)</span><br><span class="line">            result = util.retrieve(url, headers=self.headers, path=<span class="string">&#x27;images/&#x27;</span>+filename)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;filename&#125;</span> 下载完成!&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;filename&#125;</span> 下载失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    page_queue = Queue(<span class="number">100</span>)</span><br><span class="line">    img_queue = Queue(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        url = <span class="string">f&#x27;http://www.doutula.com/photo/list/?page=<span class="subst">&#123;x&#125;</span>&#x27;</span></span><br><span class="line">        page_queue.put(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = Producer(page_queue, img_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = Consumer(page_queue, img_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># util.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse, request</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retrieve</span>(<span class="params">url, headers=<span class="literal">None</span>, path=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(headers, <span class="built_in">dict</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    opener = request.build_opener()</span><br><span class="line">    opener.addheaders = [result <span class="keyword">for</span> result <span class="keyword">in</span> <span class="built_in">zip</span>(headers.keys(), headers.values())]</span><br><span class="line">    request.install_opener(opener)</span><br><span class="line">    request.urlretrieve(url, path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">urlopen</span>(<span class="params">url, headers=<span class="literal">None</span>, data=<span class="literal">None</span>,origin_req_host=<span class="literal">None</span>, unverifiable=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 method=<span class="literal">None</span></span>):</span><br><span class="line">    req = request.Request(url, headers=headers, data=data, origin_req_host=origin_req_host,</span><br><span class="line">                          unverifiable=unverifiable, method=method)</span><br><span class="line">    resp = request.urlopen(req)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><h3 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h3><p>Python自带的解释器是CPython。CPython解释器的多线程实际上是一个伪多线程（在多核CPU中，只能利用一核，无法利用多核的优势）。同一时刻只有一个线程执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中便引入了GIL（Global Intepreter Lock），叫做全局解释器锁。因为在CPython解释器的内存管理不是线程安全的，所以还有其他的解释器。</p><ul><li><p>Ipython</p><p>Ipython是基于CPython之上一个交互解释器，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p></li><li><p>PyPy</p><p>PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。在PyPy中，同样也是存在GIL锁的。</p></li><li><p>Jython</p><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。不存在GIL锁。</p></li><li><p>IronPython</p><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。不存在GIL锁。</p></li></ul><p>GIL虽然是一个假的多线程，但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;多线程介绍&quot;&gt;&lt;a href=&quot;#多线程介绍&quot; class=&quot;headerlink&quot; title=&quot;多线程介绍&quot;&gt;&lt;/a&gt;多线程介绍&lt;/h3&gt;&lt;p&gt;多线程时为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。就好比多线程是火车的每一节车厢，而进程就是火车，车厢离开火车无法启动。多线程的出现是为了提高效率。&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫" scheme="https://blog.qaz327zz.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="多线程" scheme="https://blog.qaz327zz.tk/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="threading" scheme="https://blog.qaz327zz.tk/tags/threading/"/>
    
  </entry>
  
  <entry>
    <title>BeautifulSoup4库</title>
    <link href="https://blog.qaz327zz.tk/190628-1/"/>
    <id>https://blog.qaz327zz.tk/190628-1/</id>
    <published>2019-06-28T10:42:52.000Z</published>
    <updated>2020-07-14T00:14:35.984Z</updated>
    
    <content type="html"><![CDATA[<p>和lxml一样，BeautifulSoup也是一个HTML&#x2F;XML的解析器，主要的功能也是解析和提取HTML&#x2F;XML数据。</p><p>lxml只会局部遍历，而BeautifulSoup是基于HTML DOM的，它会加载整个文档，解析整个DOM树，因此在时间和内存上也会有很大的开销，所以性能要低于lxml。</p><p>BeautifulSoup用来解析HTML比较简单，其API设计的非常人性化，同时BeautifulSoup也支持CSS选择器、Python标准库中的HTML解析器、lxml的XML。</p><span id="more"></span><p>安装：<code>pip install bs4</code></p><p>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p><h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><table><thead><tr><th>解析工具</th><th>解析速度</th><th>使用难度</th></tr></thead><tbody><tr><td>BeautifulSoup4</td><td>最慢</td><td>最简单</td></tr><tr><td>lxml</td><td>快</td><td>简单</td></tr><tr><td>正则</td><td>最快</td><td>最难</td></tr></tbody></table><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br></pre></td></tr></table></figure><p>BeautifulSoup(markup, features):在使用的时候需要指定解析器，如果未指定，BeautifulSoup使用的Python标准库中的HTML解析器，同时beautifulsoup也支持第三方的解析器如lxml。另一个可供选择的解析器是纯Python实现的html5lib，html5lib的解析方式与浏览器相同。</p><p>安装lxml：<code>pip install lxml</code></p><p>安装html5lib: <code>pip install html5lib</code></p><p>主要解析器的优缺点：</p><p><img src="/userImages/20190629_000.png" alt="解析器"></p><h3 id="四个常用的对象"><a href="#四个常用的对象" class="headerlink" title="四个常用的对象"></a>四个常用的对象</h3><p>BeautifulSoup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：</p><ol><li>Tag</li><li>NavigatableString</li><li>BeautifulSoup</li><li>Comment</li></ol><h3 id="操作讲解"><a href="#操作讲解" class="headerlink" title="操作讲解"></a>操作讲解</h3><p>以下内容以4个例子的形式进行讲解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div data-v-a6e3291a=&quot;&quot; class=&quot;correlation-degree&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-wrap recruit-margin&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;TEG15-计费产品web前端开发工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;TEG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责腾讯计费平台基础支付前端架构设计和开发工作； 参与需求评审、架构设计、编码设计和上线运维； 负责用户体验优化，包括但不限于：业务流程、前端展示、性能、安全等。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;PCG19-腾讯视频媒资后台开发工程师&lt;/h4&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;PCG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;北京,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;腾讯视频&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责腾讯视频媒资中台开发工作。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;TEG15-计费系统前端测试工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;TEG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责web端/后台系统测试工作，从整个项目角度规划测试方法，达成项目质量目标； 负责web端/后台系统的自动化测试、性能测试，稳定性以及其它专项测试； 负责研究web端/后台系统测试技术，跟进业界测试技术发展，引进先进测试方法并开展二次开发，建立团队质量体系建设，有效提升测试效率&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;32032-资深后台开发工程师（上海）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;IEG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;上海,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;游戏服务器的功能开发和现有系统的持续优化； 负责服务器压力测试和性能优化； 负责服务器外网运营的持续跟进和优化。 &lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;WXG03-搜索自然语言算法工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;WXG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;广州,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责包括新词发现、命名实体识别、查询理解、意图提取、知识图谱、搜索喜好偏向性等相关系统的建设，用以优化微信小程序搜索各产品方向的流量分发，并参与工程实践。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;WXG03-搜索检索算法工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;WXG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;广州,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责微信小程序搜索各个产品方向的检索工作，内容包括页面识别、页面核心数据提取、页面分类、页面评分、词权重、排序等相关工作，并与开发工程师配合进行工程实践。 &lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;23486-证券业务C++后台开发高级工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;CDG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责证券交易、风控、清算等系统的开发维护，建设证券业务相关的技术基础平台。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;22989-腾讯云数据平台产品中心运营开发&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;CSIG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责腾讯云数据平台产品的设计和研发。 负责云产品数据管理和服务的设计和研发。 负责构建和完善云底层数据的存储和查询，优化数据的质量和监控能力。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;18428-证券业务测试工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;CDG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;北京,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;财付通&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责证券类产品的功能、性能、安全、自动化等测试工作，包括终端/H5及后台系统的测试。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;30360-后台平台开发（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;PCG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳总部,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责QQ平台海量用户和数据的基础后台研发工作； 负责AI基础架构系统后台研发工作； 负责推荐系统，大数据分析计算后台研发工作。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>获取所有的class属性为“recruit-list”的div标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">divs = soup.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;recruit-list&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    <span class="built_in">print</span>(div)</span><br></pre></td></tr></table></figure></li><li><p>获取第二个class属性为“recruit-list”的div标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div = soup.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;recruit-list&quot;</span>&#125;, limit=<span class="number">2</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(div)</span><br></pre></td></tr></table></figure></li><li><p>获取所有的h4标签中的class属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h4_texts = soup.find_all(<span class="string">&#x27;h4&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> h4_text <span class="keyword">in</span> h4_texts:</span><br><span class="line">    <span class="built_in">print</span>(h4_text[<span class="string">&#x27;class&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>获取所有的职位信息（纯文本）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aEs = soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li><p>方法一</p><p>输出的字符串中可能包含了很多空格或空行,使用 <code>.stripped_strings</code> 可以去除多余空白内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    infos = <span class="built_in">list</span>(aE.stripped_strings)</span><br><span class="line">    <span class="built_in">print</span>(infos)</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">job = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    h4 = aE.find(<span class="string">&#x27;h4&#x27;</span>).string</span><br><span class="line">    ps = aE.find_all(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">    spans = ps[<span class="number">0</span>].find_all(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">    span = <span class="string">&#x27;|&#x27;</span>.join([s.string <span class="keyword">for</span> s <span class="keyword">in</span> spans])</span><br><span class="line">    p2 = ps[<span class="number">1</span>].string</span><br><span class="line">    job[<span class="string">&#x27;title&#x27;</span>] = h4</span><br><span class="line">    job[<span class="string">&#x27;info&#x27;</span>] = span</span><br><span class="line">    job[<span class="string">&#x27;desc&#x27;</span>] = p2</span><br><span class="line">    <span class="built_in">print</span>(job)</span><br></pre></td></tr></table></figure></li><li><p>方法三</p><p>该方法提取出的内容中包含换行、空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(aE.strings))</span><br></pre></td></tr></table></figure></li></ol><p>_注意_：</p><p>strings和stripped_strings、string属性和get_text方法：</p><ol><li>string：获取某个标签下的非标签字符串。返回值为字符串。</li><li>strings：获取某个标签下的所有非标签字符串，返回结果为一个生成器。</li><li>stripped_strings：获取某个标签下的所有非空行、非换行的非标签字符串，返回结果为一个生成器。</li><li>get_text：获取某个标签下的所有非标签字符串，返回结果为字符串。</li></ol></li></ul><h3 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h3><h4 id="find和find-all方法"><a href="#find和find-all方法" class="headerlink" title="find和find_all方法"></a>find和find_all方法</h4><p>搜索文档树，一般采用较多的是这两个方法，一个是find，另一个是find_all方法。find方法是在文档树中找到第一个满足条件的标签后就返回结果。find_all方法是在文档树中找到所有满足条件的标签后返回结果。在这两个方法中最常用的用法是name和attr参数，其中也可以直接传入关键字，在传入关键字”class”时，需要将”class”变为”class_”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="select方法"><a href="#select方法" class="headerlink" title="select方法"></a>select方法</h4><p>在使用css选择器的方式时，需要使用select方法。以下为几种常用的css选择器方法：</p><ol><li><p>通过标签名查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过类名查找</p><p>通过类名，应该在前面加一个”.”,比如要查找class&#x3D;sister的标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;.sister&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过id查找</p><p>通过id查找，应该在id的名字前面加一个”#”号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;#link1&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过组合查找</p><p>组合查找时，标签名和类名、id名进行组合的方式进行查找，例如查找p标签中，id等于link1的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;p #link1&quot;</span>))</span><br></pre></td></tr></table></figure><p>直接子标签查找，则用”&gt;”分隔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;head &gt; title&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>通过属性查找</p><p>查找时还可以加入属性元素，属性元素需要使用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>获取内容</p><p>以上的select方法返回的结果都是以列表的形式返回的，可以进行遍历输出，然后使用get_text()方法获取其他的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.select(<span class="string">&#x27;title&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;title&#x27;</span>)[<span class="number">0</span>].get_text())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> soup.select(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(title.get_text())</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;和lxml一样，BeautifulSoup也是一个HTML&amp;#x2F;XML的解析器，主要的功能也是解析和提取HTML&amp;#x2F;XML数据。&lt;/p&gt;
&lt;p&gt;lxml只会局部遍历，而BeautifulSoup是基于HTML DOM的，它会加载整个文档，解析整个DOM树，因此在时间和内存上也会有很大的开销，所以性能要低于lxml。&lt;/p&gt;
&lt;p&gt;BeautifulSoup用来解析HTML比较简单，其API设计的非常人性化，同时BeautifulSoup也支持CSS选择器、Python标准库中的HTML解析器、lxml的XML。&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫" scheme="https://blog.qaz327zz.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="bs4" scheme="https://blog.qaz327zz.tk/tags/bs4/"/>
    
  </entry>
  
  <entry>
    <title>XPath语法详解</title>
    <link href="https://blog.qaz327zz.tk/190628/"/>
    <id>https://blog.qaz327zz.tk/190628/</id>
    <published>2019-06-28T07:40:35.000Z</published>
    <updated>2020-07-14T00:14:40.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Xpath语法和lxml模块"><a href="#Xpath语法和lxml模块" class="headerlink" title="Xpath语法和lxml模块"></a>Xpath语法和lxml模块</h3><h4 id="什么是XPath？"><a href="#什么是XPath？" class="headerlink" title="什么是XPath？"></a>什么是XPath？</h4><p>xpath (XML Path Language)是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。</p><span id="more"></span><h4 id="XPath开发工具"><a href="#XPath开发工具" class="headerlink" title="XPath开发工具"></a>XPath开发工具</h4><ol><li>Chrom插件XPath Helper</li><li>FireFox插件XPath Checker</li></ol><h4 id="XPath语法"><a href="#XPath语法" class="headerlink" title="XPath语法"></a>XPath语法</h4><h5 id="选取节点："><a href="#选取节点：" class="headerlink" title="选取节点："></a>选取节点：</h5><p>Xpath使用路径表达式选取XML文档中的节点或 节点集。</p><table><thead><tr><th>表达式</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有结点</td><td>bookstore</td><td>选取bookstore下所有的节点</td></tr><tr><td>&#x2F;</td><td>如果是在最前面，代表从根节点选取。否者选取某节点下的某个节点</td><td>&#x2F;bookstore</td><td>选取根元素下所有的bookstore节点</td></tr><tr><td>&#x2F;&#x2F;</td><td>从全局节点中选择节点</td><td>&#x2F;&#x2F;book</td><td>选取所有的bookstore节点</td></tr><tr><td>@</td><td>选取某个节点的属性</td><td>&#x2F;&#x2F;book[@id]</td><td>选取所有拥有id属性的book节点</td></tr></tbody></table><h5 id="谓语："><a href="#谓语：" class="headerlink" title="谓语："></a>谓语：</h5><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。</p><table><thead><tr><th>路径表达式</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;bookstore&#x2F;book[1]</td><td>选取bookstore下的第一个book元素</td></tr><tr><td>&#x2F;bookstore&#x2F;book[last()]</td><td>选取bookstore下的倒数第二个book元素</td></tr><tr><td>&#x2F;bookstore&#x2F;book[position() &lt; 3]</td><td>选取bookstore下前两个book元素</td></tr><tr><td>&#x2F;&#x2F;book[@id]</td><td>选取拥有id属性的所有book元素</td></tr><tr><td>&#x2F;&#x2F;book[@id&#x3D;10]</td><td>选取所有id&#x3D;10的所有book元素</td></tr></tbody></table><h5 id="通配符："><a href="#通配符：" class="headerlink" title="通配符："></a>通配符：</h5><p><code>*</code> 表示通配符</p><table><thead><tr><th>通配符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>*</td><td>匹配任意节点</td><td>&#x2F;bookstore&#x2F;*</td><td>选取bookstore下所有的子元素</td></tr><tr><td>@*</td><td>匹配节点中的任何属性</td><td>&#x2F;&#x2F;book[@*]</td><td>选取所有带有属性的book元素</td></tr></tbody></table><h5 id="选取多个路径："><a href="#选取多个路径：" class="headerlink" title="选取多个路径："></a>选取多个路径：</h5><p>通过在路径表达式中使用“|”运算符，可以选取若干路径。</p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bookstore/book | //book/title</span><br><span class="line">### 选取所有book元素以及book元素下所有的title元素</span><br></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>返回值</th></tr></thead><tbody><tr><td>&#124;</td><td>计算两个节点集</td><td>&#x2F;&#x2F;book &#124; &#x2F;&#x2F;cd</td><td>返回所有拥有book 和cd元素的节点集</td></tr><tr><td>+</td><td>加法</td><td>6+4</td><td>10</td></tr><tr><td>-</td><td>减法</td><td>6-4</td><td>2</td></tr><tr><td>*</td><td>乘法</td><td>6*4</td><td>24</td></tr><tr><td>div</td><td>除法</td><td>8 div 4</td><td>2</td></tr><tr><td>&#x3D;</td><td>等于</td><td>id&#x3D;101</td><td>如果id&#x3D;101，则返回True，否则返回False</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>id !&#x3D; 101</td><td>如果id !&#x3D; 101，则返回True，否则返回False</td></tr><tr><td>&lt;</td><td>小于</td><td>id &lt; 101</td><td>如果id &gt; 101，则返回True，否则返回False</td></tr><tr><td>&lt;&#x3D;</td><td>小于或等于</td><td>id &lt;&#x3D; 101</td><td>如果id &lt;&#x3D; 101，则返回True，否则返回False</td></tr><tr><td>&gt;</td><td>大于</td><td>id &gt; 101</td><td>如果id &gt; 101，则返回True，否则返回False</td></tr><tr><td>&gt;&#x3D;</td><td>大于或等于</td><td>id &gt;&#x3D; 101</td><td>如果id &gt;&#x3D; 101，则返回True，否则返回False</td></tr><tr><td>or</td><td>或</td><td>id &#x3D;100 or id &#x3D; 101</td><td>如果id &#x3D; 100 或id&#x3D;101，返回True， 否则返回False</td></tr><tr><td>and</td><td>与</td><td>id &gt; 100 and id &lt; 150</td><td>如果100 &lt; id &lt; 101,返回True，否则返回False</td></tr><tr><td>mod</td><td>计算除法的余数</td><td>5 mod 2</td><td>1</td></tr></tbody></table><p><em>注意:</em></p><ol><li><p>&#x2F;和&#x2F;&#x2F;的区别：&#x2F;代表只获取直接子节点， &#x2F;&#x2F;代表获取子孙节点。</p></li><li><p>contains：有时某个属性中包含多个值，可以使用模糊匹配的方式获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//div[contaions(@class, &#x27;job_detail&#x27;)]</span><br></pre></td></tr></table></figure></li></ol><h3 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h3><p>lxml是一个HTML&#x2F;XML的解析器，主要的功能是如何解析和提取HTML&#x2F;XML数据。</p><p>lxml和正则一样，也是C实现的，是一款高性能的Python HTML&#x2F;XML解析器，它可以用来快速的定位特定元素以及节点信息。</p><p>安装：<code>pip install lxml</code></p><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><p>在用lxml解析HTML代码的时候，如果HTML代码不规范，lxml库会自动的将其补全。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用lxml的etree库</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link0.html&quot;&gt;First item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;Second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;Third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;Fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;Fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_result</span>(<span class="params">html</span>):</span><br><span class="line">    result = etree.tostring(html, encoding=<span class="string">&#x27;utf-8&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    </span><br><span class="line">print_result(html)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link0.html&quot;</span>&gt;</span>First item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>Second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>Third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span>Fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>Fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在解析html文件时，如果使用的<code>lxml.etree.parse</code>解析。该函数默认使用的解析器是<code>XML</code>解析器，所以，如果html文件中缺少相应标签，解析就会出错，此时可以自行创建解析器。</p><h4 id="lxml的使用"><a href="#lxml的使用" class="headerlink" title="lxml的使用"></a>lxml的使用</h4><p>以上文的text为例：</p><ul><li><p>获取ul标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uls = html.xpath(<span class="string">&#x27;//ul&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> ut <span class="keyword">in</span> uls:</span><br><span class="line">    print_result(ut)</span><br></pre></td></tr></table></figure></li><li><p>获取&lt;li class&#x3D;”item-1”&gt;标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li_items_1 = html.xpath(<span class="string">&quot;//li[@class=&#x27;item-1&#x27;]&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li_item_1 <span class="keyword">in</span> li_items_1:</span><br><span class="line">    print_result(li_item_1)</span><br></pre></td></tr></table></figure></li><li><p>获取所有&lt;li class&#x3D;”item-1”&gt;中a标签中的链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li_items_1_as_href = html.xpath(<span class="string">&quot;//li[@class=&#x27;item-1&#x27;]/a/@href&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li_items_1_a_href <span class="keyword">in</span> li_items_1_as_href:</span><br><span class="line">    <span class="built_in">print</span>(li_items_1_a_href)</span><br></pre></td></tr></table></figure></li><li><p>获取所有a标签中的文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">as_text = html.xpath(<span class="string">&quot;//a/text()&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> a_text <span class="keyword">in</span> as_text:</span><br><span class="line">    <span class="built_in">print</span>(a_text)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Xpath语法和lxml模块&quot;&gt;&lt;a href=&quot;#Xpath语法和lxml模块&quot; class=&quot;headerlink&quot; title=&quot;Xpath语法和lxml模块&quot;&gt;&lt;/a&gt;Xpath语法和lxml模块&lt;/h3&gt;&lt;h4 id=&quot;什么是XPath？&quot;&gt;&lt;a href=&quot;#什么是XPath？&quot; class=&quot;headerlink&quot; title=&quot;什么是XPath？&quot;&gt;&lt;/a&gt;什么是XPath？&lt;/h4&gt;&lt;p&gt;xpath (XML Path Language)是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫" scheme="https://blog.qaz327zz.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="XPath" scheme="https://blog.qaz327zz.tk/tags/XPath/"/>
    
  </entry>
  
  <entry>
    <title>Python 3中的Urllib库的使用</title>
    <link href="https://blog.qaz327zz.tk/190615/"/>
    <id>https://blog.qaz327zz.tk/190615/</id>
    <published>2019-06-15T07:17:25.000Z</published>
    <updated>2020-07-14T00:14:29.251Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中有着这样一个常用的、基础的爬虫库。在Python2中为urllib.urllib，在Python3中官方为了便于管理，将和请求有关的函数封装进了urllib.request模块中。</p><p>在此处，使用Python3做记录。</p><span id="more"></span><h3 id="urlopen函数"><a href="#urlopen函数" class="headerlink" title="urlopen函数"></a>urlopen函数</h3><p>urlopen函数是request中的一个很常用的函数，它主要用于打开一个网页。其中有着很多的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">resp = request.<span class="built_in">open</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><h3 id="urlretrieve函数"><a href="#urlretrieve函数" class="headerlink" title="urlretrieve函数"></a>urlretrieve函数</h3><p>urlretrieve函数可以很方便的将网页保存至本地。其实用方法见下方代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">request.urlretrieve()</span><br></pre></td></tr></table></figure><h3 id="urlencode函数"><a href="#urlencode函数" class="headerlink" title="urlencode函数"></a>urlencode函数</h3><p>将字典类型的数据转化为url编码的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse, request</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">&quot;wd&quot;</span>: <span class="string">&quot;爬虫之道&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line"></span><br><span class="line">url = <span class="string">f&quot;https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">resp = request.urlopen(url)</span><br></pre></td></tr></table></figure><h3 id="parse-qs函数"><a href="#parse-qs函数" class="headerlink" title="parse_qs函数"></a>parse_qs函数</h3><p>将url编码后的参数还原为字典形式，其中的值以列表形式进行存储。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">ps = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;爬虫之道&quot;</span>, <span class="string">&quot;vxcode&quot;</span>: <span class="string">&quot;spider_rold&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">results = parse.urlencode(ps)</span><br><span class="line"></span><br><span class="line">new_results = parse.parse_qs(results)</span><br><span class="line"><span class="built_in">print</span>(new_results)</span><br></pre></td></tr></table></figure><h3 id="urlparse和urlsplit函数"><a href="#urlparse和urlsplit函数" class="headerlink" title="urlparse和urlsplit函数"></a>urlparse和urlsplit函数</h3><p>对URL各部分进行分割，其中在使用urlsplit函数时，没有_params_参数。（<em>注</em>：params参数指的是在以下链接中”?”前添加”;”，位于这两者之间的内容，如：_<a href="https://www.baidu.com/s;hello?wd=hello+world_%EF%BC%89">https://www.baidu.com/s;hello?wd=hello+world_）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">&quot;wd&quot;</span>: <span class="string">&quot;爬虫之道&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line">url = <span class="string">f&quot;https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">result = parse.urlparse(url)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;scheme:&#x27;</span>, result.scheme)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;netloc:&#x27;</span>, result.netloc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>, result.path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;params:&#x27;</span>, result.params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;query:&#x27;</span>, result.query)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fragment:&#x27;</span>, result.fragment)</span><br></pre></td></tr></table></figure><h3 id="request-Request类"><a href="#request-Request类" class="headerlink" title="request.Request类"></a>request.Request类</h3><p>在爬虫中，如果想使用一些参数，如：请求头，请求数据等，需要使用到Request类。如果只是使用urlopen函数，没有办法进行添加请求头。在没有使用_User-Agent_的时候，如果服务器发现是爬虫，服务器可能会返回一条假的数据内容，或者是不返回内容。所以，将爬虫程序伪装成正常的浏览器访问是很有必要的一件事。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36&quot;</span>&#125;</span><br><span class="line">params = &#123;<span class="string">&quot;wd&quot;</span>: <span class="string">&quot;爬虫之道&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line">url = <span class="string">f&quot;https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">req = request.Request(url, headers=headers)</span><br><span class="line">resp = request.urlopen(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><p>注： 可以去挑战一下网络爬虫界的“珠穆朗玛峰” —– 拉勾网</p><h3 id="ProxyHandler处理器"><a href="#ProxyHandler处理器" class="headerlink" title="ProxyHandler处理器"></a>ProxyHandler处理器</h3><p>在爬取网站时，一般情况下网站都会做一些反爬虫机制，如封ip。如果只使用一个ip地址进行爬取，在网站封掉ip地址后，就无法获取数据了。所以，在有反爬虫机制的情况，反反爬虫机制便可以使用了。在urllib中通过使用ProxyHandler进行设置代理服务器。</p><p>在使用代理与未使用代理的区别：</p><p><img src="/userImages/proxy.jpg">  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment">### 未使用代理</span></span><br><span class="line">resp = request.urlopen(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用代理</span></span><br><span class="line">handler = request.ProxyHandler(&#123;<span class="string">&quot;https&quot;</span>: <span class="string">&quot;58.253.152.231:9999&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">req = request.Request(<span class="string">&quot;http://httpbin.org/get&quot;</span>)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure><p>常用的代理：</p><ul><li>西刺代理：<a href="https://www.xicidaili.com/">https://www.xicidaili.com</a></li><li>快代理: <a href="https://www.kuaidaili.com/free/">https://www.kuaidaili.com/free/</a></li></ul><h3 id="Cookie是什么"><a href="#Cookie是什么" class="headerlink" title="Cookie是什么"></a>Cookie是什么</h3><p>在网站汇总，http请求是无状态的。在第一次和服务器建立连接登录后，第二次请求服务器依旧不能知道当前请求的用户是谁。Cookie的出现就是为了解决该问题。第一次登录后，服务器会返回一些数据(cookie) 给浏览器，然后浏览器将数据保存在本地。当用户发送第二次请求时，浏览器会自动的将保存在本地的数据(cookie)一起发送给服务器。服务通过判断不同的cookie信息，进行确认用户。cookie的存储大小是有限的一般不会超过4KB，因此在设置cookie对的时候，只能存储少量数据。</p><h4 id="cookie的格式："><a href="#cookie的格式：" class="headerlink" title="cookie的格式："></a>cookie的格式：</h4><p>Set-Cookie: NAME&#x3D;VALUE；Expires&#x3D;DATE；Path&#x3D;PATH；Domain&#x3D;DOMAIN_NAME；SECURE</p><p>参数含义：</p><ul><li>NAME：Cookie的名字</li><li>VALUE：Cookie的值</li><li>Expires:  Cookie的过期时间</li><li>Path：Cookie作用的路径</li><li>Domain： Cookie作用的域名</li><li>SECURE：是否只在HTTP协议下起作用</li></ul><h3 id="使用cookielib库和HTTPCookieProcessor模块模拟登陆"><a href="#使用cookielib库和HTTPCookieProcessor模块模拟登陆" class="headerlink" title="使用cookielib库和HTTPCookieProcessor模块模拟登陆"></a>使用cookielib库和HTTPCookieProcessor模块模拟登陆</h3><p>在Python中使用cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器一起使用的。</p><ul><li>http.cookiejar：提供用于存储cookie的对象</li><li>HTTPCookieProcessor：处理cookie对象并构建handler对象</li></ul><h4 id="http-cookiejar模块"><a href="#http-cookiejar模块" class="headerlink" title="http.cookiejar模块"></a>http.cookiejar模块</h4><p>在该模块中主要有三个类，CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。其作用如下：</p><ul><li>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie，向传出的HTTP请求添加cookie对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie失效。</li><li>FileCookieJar (filename, delayload&#x3D;None, policy&#x3D;None)：从CookieJar派生而来，用来创建FileCookieJar实例。检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名，delayload为True是支持延迟访问文件，即只有在需要时才读取文件或将数据存储在文件中。</li><li>MozillaCookieJar (filename, delayload&#x3D;None, policy&#x3D;None)：从FileCookieJar派生而来，创建与Mozilla浏览器cookies.txt兼容的FileCookieJar实例。</li><li>LWPCookieJar (filename, delayload&#x3D;None, policy&#x3D;None)：从FileCookieJar派生而来，创建与libwww·per标准的Set-Cookies3文件格式兼容的FileCookieJar实例。</li></ul><h3 id="保存Cookie至本地"><a href="#保存Cookie至本地" class="headerlink" title="保存Cookie至本地"></a>保存Cookie至本地</h3><p>保存cookie到本地，可以使用cookiejar的save方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&#x27;cookies.txt&#x27;</span>)</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">handlers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = request.Request(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>, headers=handlers)</span><br><span class="line"></span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br><span class="line"></span><br><span class="line">cookiejar.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="加载本地cookie"><a href="#加载本地cookie" class="headerlink" title="加载本地cookie"></a>加载本地cookie</h3><p>从本地文件读取cookie信息，可以使用cookiejar中的load方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&#x27;cookies.txt&#x27;</span>)</span><br><span class="line">cookiejar.load(ignore_discard=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookiejar:</span><br><span class="line">    <span class="built_in">print</span>(cookie)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Python中有着这样一个常用的、基础的爬虫库。在Python2中为urllib.urllib，在Python3中官方为了便于管理，将和请求有关的函数封装进了urllib.request模块中。&lt;/p&gt;
&lt;p&gt;在此处，使用Python3做记录。&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫" scheme="https://blog.qaz327zz.tk/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="urllib" scheme="https://blog.qaz327zz.tk/tags/urllib/"/>
    
  </entry>
  
  <entry>
    <title>为Next加上彩色标签云</title>
    <link href="https://blog.qaz327zz.tk/190520/"/>
    <id>https://blog.qaz327zz.tk/190520/</id>
    <published>2019-05-20T10:02:00.000Z</published>
    <updated>2020-07-14T00:14:23.531Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直看hexo官方的标签云太难看，就google了一下。最终搜索到了这篇文章（<a href="https://me.idealli.com/post/d6caa003.html">传送门</a>），在此也做下记录吧！</p><span id="more"></span><ol><li><p>打开themes –&gt; next –&gt; layout –&gt; page.swig文件</p></li><li><p>找到<code>&#123; % if page.type === &#39;tags&#39; % &#125;</code></p></li><li><p>将下方代码进行替换即可</p></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原内容：</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;tag-cloud-tags&quot;&gt;</span><br><span class="line">  &#123;% if not theme.tagcloud %&#125;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: &#x27;#ccc&#x27;, end_color: &#x27;#111&#x27;&#125;) &#125;&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;min_font: theme.tagcloud.min, max_font: theme.tagcloud.max, amount: theme.tagcloud.amount, color: true, start_color: theme.tagcloud.start, end_color: theme.tagcloud.end&#125;) &#125;&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><hr><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">修改之后的内容：</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;tag-cloud-tags&quot; id=&quot;tags&quot;&gt;</span><br><span class="line">  &#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#x27;#fff&#x27;, end_color: &#x27;#fff&#x27;&#125;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var alltags=document.getElementById(&#x27;tags&#x27;);</span><br><span class="line">  var tags=alltags.getElementsByTagName(&#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">  for (var i = tags.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    var r=Math.floor(Math.random()*75+130);</span><br><span class="line">    var g=Math.floor(Math.random()*75+100);</span><br><span class="line">    var b=Math.floor(Math.random()*75+80);</span><br><span class="line">    tags[i].style.background = &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  div#posts.posts-expand .tag-cloud a&#123;</span><br><span class="line">    background-color: #f5f7f1;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-left: 10px;</span><br><span class="line">    padding-right: 10px;</span><br><span class="line">    margin-top: 18px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud a&#123;</span><br><span class="line">    background-color: #f5f7f1;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin-right: 5px;</span><br><span class="line">    margin-left: 0px;</span><br><span class="line">    margin-top: 8px;</span><br><span class="line">    margin-bottom: 0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud a:before&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    text-align: left;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>之后清理缓存，重新部署就行了。</p><p>最终效果如下：</p><p><img src="/userImages/tag-cloud.png" alt="彩色标签云"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一直看hexo官方的标签云太难看，就google了一下。最终搜索到了这篇文章（&lt;a href=&quot;https://me.idealli.com/post/d6caa003.html&quot;&gt;传送门&lt;/a&gt;），在此也做下记录吧！&lt;/p&gt;</summary>
    
    
    
    <category term="起始篇" scheme="https://blog.qaz327zz.tk/categories/%E8%B5%B7%E5%A7%8B%E7%AF%87/"/>
    
    
    <category term="标签云" scheme="https://blog.qaz327zz.tk/tags/%E6%A0%87%E7%AD%BE%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>使用Cython保护Python文件</title>
    <link href="https://blog.qaz327zz.tk/190502-4/"/>
    <id>https://blog.qaz327zz.tk/190502-4/</id>
    <published>2019-05-02T04:02:58.000Z</published>
    <updated>2020-07-14T00:14:05.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Cython保护Python代码库"><a href="#使用Cython保护Python代码库" class="headerlink" title="使用Cython保护Python代码库"></a>使用Cython保护Python代码库</h1><p>从语言层面来说，Cython是一种拓展的Python，其文件的扩展名为.pyx。这种类型的文件通过编译之后可以变成供Python直接调用的动态链接库（Linux&#x2F;Mac下是.so，Windows下是.pyd）。根据官方文档，主要如下几编译方式：</p><blockquote><ul><li>(推荐) 通过setup.py中调用Cython.Build进行编译</li><li>使用pyximport调用.pyx文件，这种方法.pyx文件相当于普通的.py文件</li><li>在命令行使用cython命令从.pyx文件生成.c文件，再使用外部编译器将.c文件编译成Python可用的库</li><li>使用Jupyter Notebook或者Sage Notebook直接运行Cython代码</li></ul></blockquote><span id="more"></span><p>这上面四种方法里最简单的是第三种方法。运行<code>cythonize -i &lt;.pyx File&gt;</code>即可编译.pyx成二进制库，并保存在与.pyx文件相同的目录下。cythonize命令有其他的参数，可以通过命令行查看。这个命令也可以通过<code>python -m Cython.Build.Cythonize -i &lt;.pyx File&gt;</code>来完成。</p><p>  在对Python 代码进行保护时，可以采用Cython对Python代码记性二进制转换，尽管可以对二进制文件进行逆向工程，但是依然会起到一定的保护作用.</p><h2 id="对项目包进行编译"><a href="#对项目包进行编译" class="headerlink" title="对项目包进行编译"></a>对项目包进行编译</h2><p>对以下结构的包进行编译:</p><p><img src="/userImages/Cython_tree.png" alt="tree"></p><ul><li>通过<code>setup.py</code>文件进行简单编译</li></ul><p>在使用该方法编译的时候，一个函数只有一个参数时，有可能会出现无法找到函数的情况，鉴于这种情况，请参考复杂编译的过程。以Cython官方实例为例：</p><p><code>setup.py</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">  name = <span class="string">&#x27;Hello world app&#x27;</span>,</span><br><span class="line">  ext_modules = cythonize(<span class="string">&quot;hello.py&quot;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>hello.py</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello_to</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello %s!&quot;</span> % name)</span><br></pre></td></tr></table></figure><p><img src="/userImages/Cython_example1.png" alt="example1"></p><p>运行<code>python setup.py build_ext --inplace</code>，生成<code>.so</code>文件，删除该文件夹中的<code>py文件</code>和<code>c文件</code>。<br>在终端导入使用：<br><img src="/userImages/Cython_example2.png" alt="example2"></p><ul><li>使用<code>setup.py</code>文件进行复杂编译</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> setuptools.extension <span class="keyword">import</span> Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"><span class="keyword">from</span> Cython.Distutils <span class="keyword">import</span> build_ext</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    ext_modules=cythonize(</span><br><span class="line">        [</span><br><span class="line">            Extension(<span class="string">&#x27;mypkg.*&#x27;</span>, [<span class="string">&#x27;mypkg/*.py&#x27;</span>]),</span><br><span class="line">            Extension(<span class="string">&#x27;mypkg.submypkg1.*&#x27;</span>, [<span class="string">&#x27;mypkg/submypkg1/*.py&#x27;</span>]),</span><br><span class="line">            Extension(<span class="string">&#x27;mypkg.submypkg2.*&#x27;</span>, [<span class="string">&#x27;mypkg/submypkg2/*.py&#x27;</span>]),</span><br><span class="line">            Extension(<span class="string">&#x27;mypkg2.*&#x27;</span>, [<span class="string">&#x27;mypkg2/*.py&#x27;</span>]),</span><br><span class="line">        ],</span><br><span class="line">        build_dir=<span class="string">&#x27;build&#x27;</span>,</span><br><span class="line">        compiler_directives=<span class="built_in">dict</span>(</span><br><span class="line">            always_allow_keywords=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    cmdclass = <span class="built_in">dict</span>(</span><br><span class="line">        build_ext=build_ext</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── mypkg</span><br><span class="line">│   │   ├── bar.c</span><br><span class="line">│   │   ├── foo.c</span><br><span class="line">│   │   ├── __init__.c</span><br><span class="line">│   │   ├── submypkg1</span><br><span class="line">│   │   │   ├── bar.c</span><br><span class="line">│   │   │   ├── foo.c</span><br><span class="line">│   │   │   └── __init__.c</span><br><span class="line">│   │   └── submypkg2</span><br><span class="line">│   │       ├── bar.c</span><br><span class="line">│   │       ├── foo.c</span><br><span class="line">│   │       └── __init__.c</span><br><span class="line">│   ├── mypkg2</span><br><span class="line">│   │   ├── bar.c</span><br><span class="line">│   │   ├── foo.c</span><br><span class="line">│   │   └── __init__.c</span><br><span class="line">│   └── temp.linux-x86_64-3.7</span><br><span class="line">│       └── build</span><br><span class="line">│           ├── mypkg</span><br><span class="line">│           │   ├── bar.o</span><br><span class="line">│           │   ├── foo.o</span><br><span class="line">│           │   ├── __init__.o</span><br><span class="line">│           │   ├── submypkg1</span><br><span class="line">│           │   │   ├── bar.o</span><br><span class="line">│           │   │   ├── foo.o</span><br><span class="line">│           │   │   └── __init__.o</span><br><span class="line">│           │   └── submypkg2</span><br><span class="line">│           │       ├── bar.o</span><br><span class="line">│           │       ├── foo.o</span><br><span class="line">│           │       └── __init__.o</span><br><span class="line">│           └── mypkg2</span><br><span class="line">│               ├── bar.o</span><br><span class="line">│               ├── foo.o</span><br><span class="line">│               └── __init__.o</span><br><span class="line">├── mypkg</span><br><span class="line">│   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── bar.py</span><br><span class="line">│   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── foo.py</span><br><span class="line">│   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── submypkg1</span><br><span class="line">│   │   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   ├── bar.py</span><br><span class="line">│   │   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   ├── foo.py</span><br><span class="line">│   │   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   └── __init__.py</span><br><span class="line">│   └── submypkg2</span><br><span class="line">│       ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── bar.py</span><br><span class="line">│       ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── foo.py</span><br><span class="line">│       ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       └── __init__.py</span><br><span class="line">├── mypkg2</span><br><span class="line">│   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── bar.py</span><br><span class="line">│   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── foo.py</span><br><span class="line">│   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><ul><li>运行文件<code>python setup.py build_ext --inplace</code></li><li>最终会在当前文件夹中生成build文件夹，同时在build文件夹中生成相应的文件夹和<code>.c</code>文件，在主目录对应的文件夹中生成<code>.so</code>文件，此时的<code>.so</code>文件就可以通过导入的方式直接使用。</li><li>如果需求有改动，需要删除相应的<code>.so文件</code>后重新生成该文件。</li></ul><hr><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul><li>此<code>always_allow_keywords=True</code>参数一定要添加，因为<code>always_allow_keywords</code>指令禁用具有大量参数的函数只允许使用关键字参数，如果不禁用，此处在传入一个参数时会找不到对应的函数。</li><li>在使用第二种方法时，一定要注意一点，在有celery task任务的文件中，无法进行编译，否则在编译过后会出现celery无法启动的情况。<ul><li>对上文出现的问题进行给出一个解答：<br> 在上文中，如果编译了带有task任务的文件，会出现以下错误   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="string">&#x27;method-wrapper&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__module__&#x27;</span></span><br></pre></td></tr></table></figure> 解决方法为：  <blockquote><ul><li>创建第三方真实执行逻辑的文件，在进行加密时，加密第三方逻辑文件，对celery调度任务的文件不进行加密。</li><li>见官方给出的解决方式<a href="https://github.com/celery/celery/issues/4342">Issues</a>，不过此处不建议更改celery源文件。</li></ul></blockquote></li></ul></li></ul><hr><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://bucharjan.cz/blog/using-cython-to-protect-a-python-codebase.html">Using Cython to protect a Python codebase</a></li><li><a href="https://python.freelycode.com/contribution/detail/981">对《Using Cython to protect a Python codebase》的翻译</a></li><li><a href="http://docs.cython.org/en/latest/">Cython Documentation</a></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用Cython保护Python代码库&quot;&gt;&lt;a href=&quot;#使用Cython保护Python代码库&quot; class=&quot;headerlink&quot; title=&quot;使用Cython保护Python代码库&quot;&gt;&lt;/a&gt;使用Cython保护Python代码库&lt;/h1&gt;&lt;p&gt;从语言层面来说，Cython是一种拓展的Python，其文件的扩展名为.pyx。这种类型的文件通过编译之后可以变成供Python直接调用的动态链接库（Linux&amp;#x2F;Mac下是.so，Windows下是.pyd）。根据官方文档，主要如下几编译方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;(推荐) 通过setup.py中调用Cython.Build进行编译&lt;/li&gt;
&lt;li&gt;使用pyximport调用.pyx文件，这种方法.pyx文件相当于普通的.py文件&lt;/li&gt;
&lt;li&gt;在命令行使用cython命令从.pyx文件生成.c文件，再使用外部编译器将.c文件编译成Python可用的库&lt;/li&gt;
&lt;li&gt;使用Jupyter Notebook或者Sage Notebook直接运行Cython代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Cython" scheme="https://blog.qaz327zz.tk/categories/Cython/"/>
    
    
    <category term="加密" scheme="https://blog.qaz327zz.tk/tags/%E5%8A%A0%E5%AF%86/"/>
    
    <category term="Cython" scheme="https://blog.qaz327zz.tk/tags/Cython/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL学习总结</title>
    <link href="https://blog.qaz327zz.tk/190502-3/"/>
    <id>https://blog.qaz327zz.tk/190502-3/</id>
    <published>2019-05-02T03:42:09.000Z</published>
    <updated>2020-07-14T00:13:59.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PG数据库："><a href="#PG数据库：" class="headerlink" title="PG数据库："></a>PG数据库：</h1><p>理解：对于PostgreSQL数据库，我个人理解为和MySQL数据库很相识，比MySQL功能多，在pg数据库中，用户可以指定表集合，这点和mongodb很像。</p><blockquote><p>模式(架构)：是指定的表集合，它还可以包含视图、索引、序列、数据类型、运算符和函数.</p></blockquote><span id="more"></span><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建模式:create schema &lt;schemaname&gt;</span><br></pre></td></tr></table></figure><h1 id="架构作用"><a href="#架构作用" class="headerlink" title="架构作用:"></a>架构作用:</h1><blockquote><p>1、模式有助于多用户使用一个数据库,而不会互相干扰</p><p>2、将数据库对象组织成逻辑组,使其更易于管理</p><p>3、可以将第三方模式放入单独的模式中,以避免与其他对象的名称相冲突</p></blockquote><h1 id="PostgreSQL中的连接类型："><a href="#PostgreSQL中的连接类型：" class="headerlink" title="PostgreSQL中的连接类型："></a>PostgreSQL中的连接类型：</h1><ul><li><p>内连接（inner join）显示两个集合共有部分（交集）</p><p>  select table1.columns,table2.columns from table1 inner join table2 on table1.common_filed &#x3D; table2.common_filed;</p></li><li><p>左外连接（left outer join）显示左集合的全部，右集合不满足的用空补全</p><p>  select table1.columns,table2.columns from table1 left outer join table2 on table1.common_filed &#x3D; table2.common_filed;</p></li><li><p>右外连接（right outer join）显示右集合的全部，左集合不满足的用空补全</p><p>  select table1.columns,table2.columns from table1 right outer join table2 on table1.common_filed &#x3D; table2.common_filed;</p></li><li><p>全连接（full outer join）显示两个集合的全部，不满足条件的用空补全</p><p>  select table1.columns,table2.columns from table1 full outer join table2 on table1.common_filed &#x3D; table2.common_filed;</p></li><li><p>跨连接（cross join）将第一个表的每一行与第二个表的每一行相匹配。</p><p>  select coloums from table1 cross join table2;</p></li><li><p>having子句和group by子句组合使用，用于选择函数结果满足某些条件的特定行。</p></li></ul><h1 id="普通用户创建与登陆："><a href="#普通用户创建与登陆：" class="headerlink" title="普通用户创建与登陆："></a>普通用户创建与登陆：</h1><blockquote><p>1、登陆超级用户：sudo -u postgres psql</p><p>2、创建用户：create user dbuser encrypted password ‘test’;</p><p>3、授权：alter user dbuser with createdb; alter user dbuser with login;</p><p>4、创建dbuser用户的数据集：create database dbusers with owner&#x3D;’dbuser’;</p><p>5、退出\q</p><p>6、普通用户登陆：psql -U dbuser -d dbusers -h localhost</p></blockquote><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">function</span> auditlogfunc() <span class="keyword">returns</span> <span class="keyword">trigger</span> <span class="keyword">as</span> $example_table$</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> audit(emp_id,entry_date) <span class="keyword">values</span> (new.ID, <span class="built_in">current_timestamp</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$example_table$ <span class="keyword">language</span> plpgsql;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> example_trigger after <span class="keyword">insert</span> <span class="keyword">on</span> company <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="keyword">execute</span> <span class="keyword">procedure</span> auditlogfunc();</span><br></pre></td></tr></table></figure><blockquote><p>PostgreSQL触发器目的：</p><p>1、验证输入数据</p><p>2、执行业务规则</p><p>3、为不同文件中新插入的行生成唯一值</p><p>4、写入其他文件以急性审计跟踪</p><p>5、从其他文件查询交叉引用目的</p><p>6、访问系统函数</p><p>7、将数据复制到不同的文件以实现数据一致性</p></blockquote><h1 id="触发器的查询、删除："><a href="#触发器的查询、删除：" class="headerlink" title="触发器的查询、删除："></a>触发器的查询、删除：</h1><ul><li>列出当前数据库的所有触发器：select * from pg_trigger;</li><li>列出某张表上的触发器：SELECT tgname FROM pg_trigger, pg_class WHERE tgrelid&#x3D;pg_class.oid AND relname&#x3D;’&lt;tablename&gt;’;</li><li>删除触发器：drop trigger <trigger_name>;</li></ul><h1 id="查询创建的函数："><a href="#查询创建的函数：" class="headerlink" title="查询创建的函数："></a>查询创建的函数：</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">pg_proc.proname <span class="keyword">AS</span> &quot;函数名称&quot;,</span><br><span class="line">pg_type.typname <span class="keyword">AS</span> &quot;返回值数据类型&quot;,</span><br><span class="line">pg_proc.pronargs <span class="keyword">AS</span> &quot;参数个数&quot; </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">pg_proc </span><br><span class="line"><span class="keyword">JOIN</span> pg_type <span class="keyword">ON</span> (pg_proc.prorettype <span class="operator">=</span> pg_type.oid) </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">pg_type.typname <span class="operator">!=</span> <span class="string">&#x27;void&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> </span><br><span class="line">pronamespace <span class="operator">=</span> (<span class="keyword">SELECT</span> pg_namespace.oid <span class="keyword">FROM</span> pg_namespace <span class="keyword">WHERE</span> nspname <span class="operator">=</span> <span class="string">&#x27;public&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>用于加速从数据库中检索数据</p><blockquote><p>创建索引:create index index_name on table_name;</p></blockquote><p>响应时间的计算模型：<br>响应时间&#x3D;网络传输时间（请求）+服务器处理时间（一层或是多层）+网络传输时间（响应）+页面前段解析时间</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PG数据库：&quot;&gt;&lt;a href=&quot;#PG数据库：&quot; class=&quot;headerlink&quot; title=&quot;PG数据库：&quot;&gt;&lt;/a&gt;PG数据库：&lt;/h1&gt;&lt;p&gt;理解：对于PostgreSQL数据库，我个人理解为和MySQL数据库很相识，比MySQL功能多，在pg数据库中，用户可以指定表集合，这点和mongodb很像。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模式(架构)：是指定的表集合，它还可以包含视图、索引、序列、数据类型、运算符和函数.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="PostgreSQL" scheme="https://blog.qaz327zz.tk/categories/PostgreSQL/"/>
    
    
    <category term="学习总结" scheme="https://blog.qaz327zz.tk/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="PostgreSQL" scheme="https://blog.qaz327zz.tk/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Git学习总结</title>
    <link href="https://blog.qaz327zz.tk/190502-2/"/>
    <id>https://blog.qaz327zz.tk/190502-2/</id>
    <published>2019-05-02T03:39:40.000Z</published>
    <updated>2020-07-14T00:13:55.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git整理："><a href="#git整理：" class="headerlink" title="git整理："></a>git整理：</h1><blockquote><p>工作区中的.git目录为Git版本库，git add将文件提交到暂存区,git commit将文件提交到本地仓库，git push将文件提交到远程仓库。</p></blockquote><span id="more"></span><h1 id="历史版本回退及提交至远程仓库"><a href="#历史版本回退及提交至远程仓库" class="headerlink" title="历史版本回退及提交至远程仓库"></a>历史版本回退及提交至远程仓库</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^  可以回退版本  当回退多个版本时可以使用 HEAD~100（恢复到第100个版本）。</span><br><span class="line">git reflog 用于记录每次的命令，最上方为最近一次的命令</span><br><span class="line">git reset HEAD &lt;file&gt; 将缓存区中的修改回退到工作区。</span><br><span class="line">git checkout -- &lt;file&gt; 将版本库中的版本替换工作区的版本，可以做恢复用。</span><br><span class="line">git push 将当前分支master推送到远程</span><br><span class="line">git commit 将缓存区中的文件推送到分支master(本地)</span><br></pre></td></tr></table></figure><h1 id="分支的创建、切换与合并"><a href="#分支的创建、切换与合并" class="headerlink" title="分支的创建、切换与合并"></a>分支的创建、切换与合并</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt; 创建一个分支并切换，等同于git branch &lt;branch&gt; git checkout &lt;branch&gt;两条命令</span><br><span class="line">git branch 查看当前分支</span><br><span class="line">git merge 命令用于合并指定分支到当前分支</span><br><span class="line">git branch -d &lt;branch&gt; 删除分支</span><br><span class="line">git log --graph 可以查看分支合并图</span><br></pre></td></tr></table></figure><h1 id="对远程分支进行操作"><a href="#对远程分支进行操作" class="headerlink" title="对远程分支进行操作"></a>对远程分支进行操作</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete branch &lt;branchname&gt;或git push origin :&lt;branchname&gt; 删除远程仓库中的分支</span><br></pre></td></tr></table></figure><blockquote><p>重命名远程分支：<br>1、删除远程分支：git push –delete origin <branchname><br>2、重命名本地分支：git branch -m <old> <new><br>3、推送本地分支：git push origin <NewBranchName></p></blockquote><h1 id="提交出错解决方法"><a href="#提交出错解决方法" class="headerlink" title="提交出错解决方法"></a>提交出错解决方法</h1><p>如果在提交远程仓库的时候出现“更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支”，此时应该先获取远程更新,然后合并本地的分支，最后提交.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin;# 获取运程仓库</span><br><span class="line">git merge origin/master# 将本地仓库与远程仓库合并</span><br><span class="line"></span><br><span class="line">git pull = git fetch + git merge 可能会产生冲突，需要手动解决</span><br><span class="line"></span><br><span class="line">--no-ff 参数表示禁用Fast forward</span><br></pre></td></tr></table></figure><p>如果出现”您要求从远程 ‘origin’ 拉取，但是未指定一个分支。因为这不是当前分支默认的远程仓库，您必须在命令行中指定一个分支名。”<br>执行以下内容：<br><code>git branch --set-upstream-to corigin/master master</code></p><h2 id="出错时"><a href="#出错时" class="headerlink" title="出错时"></a>出错时</h2><p>出错内容: </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &#x27;https://github.com/bnq456/bnq456.github.io.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br></pre></td></tr></table></figure><ul><li>强制推送<br>在确定自己仓库中的内容低于本地仓库中的内容并且确定本地优于远程时，如果无法进行推送，可以选择强制推送<br><code>git push -u origin master -f</code></li><li>push前先将远程repository修改pull下来<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li><li>若不想merge远程和本地修改，可以先创建新的分支：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch [name]</span><br><span class="line">然后push</span><br><span class="line">git push -u origin [name]</span><br></pre></td></tr></table></figure></li></ul><h2 id="fetch-和-pull的区别："><a href="#fetch-和-pull的区别：" class="headerlink" title="fetch 和 pull的区别："></a>fetch 和 pull的区别：</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch：将远程主机的最新内容拉取到本地，是否合并由用户决定。</span><br><span class="line">git pull：将远程主机的最新内容拉取到本地后直接合并，可能会产生冲突，需要手动解决。</span><br><span class="line">解决方法：</span><br><span class="line">git reset --hard FETCH_HEAD</span><br><span class="line">git pull</span><br><span class="line">注：将本地的冲突文件冲掉，不仅需要reset到MERGE-HEAD或HEAD，还需要--hard。当后面没有hard，不会冲掉本地工作区，只会冲掉stage区。</span><br></pre></td></tr></table></figure><p><img src="/userImages/fetch_and_pull.png" alt="fetch和pull的不同"></p><h1 id="Git中工作环境的临时存储与恢复"><a href="#Git中工作环境的临时存储与恢复" class="headerlink" title="Git中工作环境的临时存储与恢复"></a>Git中工作环境的临时存储与恢复</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash 把当前工作现场存储起来，用于以后恢复现场继续工作</span><br><span class="line">切换回工作时：</span><br><span class="line">git stash list 列出所有存储的工作环境</span><br><span class="line">result: stash@&#123;0&#125;: WIP on dev: cc559a8 add merge</span><br><span class="line">git stash pop 切回工作场景，或git stash apply stash@&#123;0&#125; 恢复后不删除stash中的内容，需要使用git stash drop &lt;name&gt;删除</span><br></pre></td></tr></table></figure><blockquote><p>pop和 apply的区别<br>pop是将工作环境切回后直接删除<br>apply是先应用工作环境，然后存储的工作环境是否删除由用户自己决定。使用：git stash drop <name>进行删除</p></blockquote><blockquote><p>实验性质的代码最好新建分支</p></blockquote><h1 id="分支的创建、删除、合并与推送"><a href="#分支的创建、删除、合并与推送" class="headerlink" title="分支的创建、删除、合并与推送"></a>分支的创建、删除、合并与推送</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br><span class="line">git checkout &lt;branchname&gt;</span><br><span class="line">以上两条命令等同于git checkout -b &lt;branchname&gt;</span><br><span class="line">git branch -D &lt;name&gt; 表示强行删除一个分支</span><br><span class="line">git merge &lt;branchname&gt; 分支的合并，表示要将&lt;branchname&gt;分支合并到当前分支上</span><br><span class="line"></span><br><span class="line">分支的推送：</span><br><span class="line">master分支是主分支，因此要时刻与远程同步;</span><br><span class="line">dev分支是开发分支，团队所有成员都需要在上面工作，所以需要时刻与远程同步;</span><br><span class="line">bug分支是本地修复bug，可推送可不推送;</span><br><span class="line">feature分支取决与是否在上面进行开发。</span><br></pre></td></tr></table></figure><h1 id="多人协作："><a href="#多人协作：" class="headerlink" title="多人协作："></a>多人协作：</h1><blockquote><p>1、首先，可以试图用git push origin <branch-name>推送自己的修改；</p></blockquote><blockquote><p>2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p></blockquote><blockquote><p>3、如果合并有冲突，则解决冲突，并在本地提交；</p></blockquote><blockquote><p>4、没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</p></blockquote><blockquote><p>5、如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin&#x2F;<branch-name>。</p></blockquote><h1 id="rebase：（不是很了解）"><a href="#rebase：（不是很了解）" class="headerlink" title="rebase：（不是很了解）"></a>rebase：（不是很了解）</h1><blockquote><p>rebase操作可以将本地未push的分叉提交历史整理成一条直线;<br>rebase的目的是使我们在查看提交的变化时更容易，因为分叉的提交需要三方比较。</p></blockquote><h1 id="git-标签："><a href="#git-标签：" class="headerlink" title="git 标签："></a>git 标签：</h1><p>git tag <name>用于新建一个标签,默认为HEAD，当创建带有说明的标签时，用-a指定标签名，-m指定说明文字<br>git tag可以查看所有的标签<br>当给以前忘记打标签的项目打标签时，可以先找出要打标签项目的编号，然后git tag <tagname> <commit id><br>-d用于删除标签<br>    远程标签推送：<br>    git push origin <tagname>推送一个本地标签到远程<br>    git push origin –tags 将所有标签推送到远程</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当删除远程标签时：</span><br><span class="line">1、首先先删除本地的标签 git tag -d &lt;tagname&gt;</span><br><span class="line">2、然后删除远程的标签 git push origin :refs/tags/&lt;tagname&gt;或者git push origin --delete tag &lt;tagname&gt;（作用与上两步相同）</span><br></pre></td></tr></table></figure><h1 id="日志文件查询"><a href="#日志文件查询" class="headerlink" title="日志文件查询"></a>日志文件查询</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;git整理：&quot;&gt;&lt;a href=&quot;#git整理：&quot; class=&quot;headerlink&quot; title=&quot;git整理：&quot;&gt;&lt;/a&gt;git整理：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;工作区中的.git目录为Git版本库，git add将文件提交到暂存区,git commit将文件提交到本地仓库，git push将文件提交到远程仓库。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Git" scheme="https://blog.qaz327zz.tk/categories/Git/"/>
    
    
    <category term="学习总结" scheme="https://blog.qaz327zz.tk/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="Git" scheme="https://blog.qaz327zz.tk/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习总结</title>
    <link href="https://blog.qaz327zz.tk/190502-1/"/>
    <id>https://blog.qaz327zz.tk/190502-1/</id>
    <published>2019-05-02T03:37:44.000Z</published>
    <updated>2020-07-14T00:13:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-中的三个基本概念"><a href="#Docker-中的三个基本概念" class="headerlink" title="Docker 中的三个基本概念"></a>Docker 中的三个基本概念</h2><ul><li>镜像(Image)</li><li>容器(Container)</li><li>仓库(Repository)</li></ul><span id="more"></span><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会改变</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>是镜像的运行时实例 - 实际执行时镜像会在内存中变成什么。默认情况下，它完全独立于主机环境运行，仅在配置为访问主机文件和端口的情况下才执行此操作。</p><h2 id="非root用户执行docker"><a href="#非root用户执行docker" class="headerlink" title="非root用户执行docker"></a>非root用户执行docker</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 创建docker组，一般是存在的。</span><br><span class="line">sudo groupadd docker</span><br><span class="line">2. 将当前用户添加到docker组</span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line">3. 注销当前登陆用户，从新登陆</span><br><span class="line">4. 验证是否可以行</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyname .<span class="comment"># 使用此目录的 Dockerfile 创建镜像</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -p 4000:80 friendlyname  <span class="comment"># 运行端口 4000 到 90 的“友好名称”映射</span></span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d -p 4000:80 friendlyname         <span class="comment"># 内容相同，但在分离模式下</span></span></span><br><span class="line">docker ps                                 <span class="comment"># 查看所有正在运行的容器的列表</span></span><br><span class="line">docker stop &lt;hash&gt;                     <span class="comment"># 平稳地停止指定的容器</span></span><br><span class="line">docker ps -a           <span class="comment"># 查看所有容器的列表，甚至包含未运行的容器</span></span><br><span class="line">docker kill &lt;hash&gt;                   <span class="comment"># 强制关闭指定的容器</span></span><br><span class="line">docker rm &lt;hash&gt;              <span class="comment"># 从此机器中删除指定的容器</span></span><br><span class="line">docker rm $(docker ps -a -q)           <span class="comment"># 从此机器中删除所有容器</span></span><br><span class="line">docker images -a                               <span class="comment"># 显示此机器上的所有镜像</span></span><br><span class="line">docker rmi &lt;imagename&gt;            <span class="comment"># 从此机器中删除指定的镜像</span></span><br><span class="line">docker rmi $(docker images -q)             <span class="comment"># 从此机器中删除所有镜像</span></span><br><span class="line">docker login             <span class="comment"># 使用您的 Docker 凭证登录此 CLI 会话</span></span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># 标记 &lt;image&gt; 以上传到镜像库</span></span><br><span class="line">docker push username/repository:tag            <span class="comment"># 将已标记的镜像上传到镜像库</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> username/repository:tag                   <span class="comment"># 运行镜像库中的镜像</span></span></span><br><span class="line">docker stack ls              <span class="comment"># 列出此 Docker 主机上所有正在运行的应用</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  <span class="comment"># 运行指定的 Compose 文件</span></span><br><span class="line">docker stack services &lt;appname&gt;       <span class="comment"># 列出与应用关联的服务</span></span><br><span class="line">docker stack ps &lt;appname&gt;   <span class="comment"># 列出与应用关联的正在运行的容器</span></span><br><span class="line">docker stack rm &lt;appname&gt;                             <span class="comment"># 清除应用</span></span><br><span class="line">docker-machine create --driver virtualbox myvm1 <span class="comment"># 创建 VM（Mac、Win7、Linux）</span></span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch <span class="string">&quot;myswitch&quot;</span> myvm1 <span class="comment"># Win10</span></span><br><span class="line">docker-machine <span class="keyword">env</span> myvm1                <span class="comment"># 查看有关节点的基本信息</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker node ls&quot;</span>         <span class="comment"># 列出 swarm 中的节点</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker node inspect &lt;node ID&gt;&quot;</span>        <span class="comment"># 检查节点</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker swarm join-token -q worker&quot;</span>   <span class="comment"># 查看加入令牌</span></span><br><span class="line">docker-machine ssh myvm1   <span class="comment"># 打开与 VM 的 SSH 会话；输入“exit”以结束会话</span></span><br><span class="line">docker-machine ssh myvm2 <span class="string">&quot;docker swarm leave&quot;</span>  <span class="comment"># 使工作节点退出 swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker swarm leave -f&quot;</span> <span class="comment"># 使主节点退出，终止 swarm</span></span><br><span class="line">docker-machine start myvm1            <span class="comment"># 启动当前未运行的 VM</span></span><br><span class="line">docker-machine stop $(docker-machine ls -q)               <span class="comment"># 停止所有正在运行的 VM</span></span><br><span class="line">docker-machine rm $(docker-machine ls -q) <span class="comment"># 删除所有 VM 及其磁盘镜像</span></span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~     <span class="comment"># 将文件复制到节点的主目录</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker stack deploy -c &lt;file&gt; &lt;app&gt;&quot;</span>   <span class="comment"># 部署应用</span></span><br></pre></td></tr></table></figure><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;localfilename&gt; &lt;flename&gt; <span class="comment">#导出镜像到本地文件</span></span><br><span class="line">docker load --input &lt;filename&gt; <span class="comment">#从导出的本地文件中再导入到本地镜像库</span></span><br><span class="line">docker load &lt; &lt;filename&gt; <span class="comment">#同上，导入镜像以及其相关的元数据信息(包括标签等)(生成镜像文件)</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d ... <span class="comment"># 使docker容器在后台以守护态形式运行</span></span></span><br><span class="line">docker export &lt;container id&gt; &gt; &lt;localfilename&gt; <span class="comment"># 将本地的某个容器导出</span></span><br><span class="line">docker import - &lt;repository:tag&gt; <span class="comment"># 将容器快照文件导入为镜像 (生成镜像快照)</span></span><br><span class="line">docker load 和 docker import 的区别：</span><br><span class="line">  docker import 将丢弃所有的历史记录和元数据信息(仅保存容器当时的快照状态)，</span><br><span class="line">  docker load 将保存完整记录，体积较大</span><br><span class="line">  docker import 导入时可以重新指定标签等元数据信息</span><br><span class="line">docker image ls --digests <span class="comment"># 列出所有镜像的摘要</span></span><br><span class="line">docker image rm &lt;id、repository:tag&gt; <span class="comment"># 删除镜像，在通过id删除时，可以指定前3个字符以上，但是要能足够用于区分别的镜像</span></span><br><span class="line">docker image rm &lt;digest&gt; <span class="comment"># 精确删除</span></span><br></pre></td></tr></table></figure><p><em>Union FS 是有最大层数限制的,比如 AUFS，一个镜像不能超过127层</em></p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>仓库名、标签均为<code>&lt;none&gt;</code>的镜像，被称为虚悬镜像</p><p>显示虚悬镜像：<code>docker image ls -f dangling=true</code></p><p>删除虚悬镜像：<code>docker image prune</code></p><h2 id="docker-中的过滤器"><a href="#docker-中的过滤器" class="headerlink" title="docker 中的过滤器"></a>docker 中的过滤器</h2><p>在docker image ls还支持使用过滤器参数 –filter或-f</p><ul><li>since 在某个镜像之后建立的镜像</li><li>before在某个镜像之前建立的镜像</li><li>dangling未打开标签</li></ul><p>镜像是多层存储,每一层是在前一层的基础上进行的修改;而容器同样也是多层存储,是在以镜像为基础层,在其基础上加一层作为容器运行时的存储层。</p><p>镜像的定制实际上就是定制每一层所添加的配置、文件.</p><p>在构建Dockerfile时，如果使用了scratch为基础镜像，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始，这样减少了镜像体积。</p><h2 id="从标准输入中读取Dockerfile"><a href="#从标准输入中读取Dockerfile" class="headerlink" title="从标准输入中读取Dockerfile"></a>从标准输入中读取Dockerfile</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line">或</span><br><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为<code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，它没有上下文，因此不以像其他方法那样将文本文件<code>Copy</code>进镜像之类的事情</p><h2 id="ADD中更高级的复制文件"><a href="#ADD中更高级的复制文件" class="headerlink" title="ADD中更高级的复制文件"></a>ADD中更高级的复制文件</h2><p>ADD指令将会自动解压缩这个压缩文件到&lt;目标路径&gt;</p><h2 id="COPY和ADD指令选择时遵循的原则"><a href="#COPY和ADD指令选择时遵循的原则" class="headerlink" title="COPY和ADD指令选择时遵循的原则"></a>COPY和ADD指令选择时遵循的原则</h2><p>所有文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD</p><p>Docker 不是虚拟机,容器中的应用都应该以前台执行,而不是像虚拟机、物理机里面那样,用upstart&#x2F;systemd 去启动后台服务,容器内没有后台服务的概念。<br>启动程序就是容器应用进程,容器就是为了主进程而存在的,主进程退出,容器就失去了存在的意义。<br>当使用ENTRYPOINT后，CMD的内容将会作为参数传给ENTRYPOINT。</p><p><code>EXPOSE</code>指令是声明运行时容器提供的服务端口</p><p><code>WORKDIR</code>可以来指定工作目录(或者称为当前目录)，以后各层的当前目录就被改为指定的目录，如果目录不存在，WORKDIR自动创建目录。</p><p><code>USER</code>和<code>WORKDIR</code>都是改变环境状态并影响以后的层。<code>WORKDIR</code>是改变工作目录，<code>USER</code>则是改变之后层的执行<code>RUN</code>、<code>CMD</code>以及<code>ENTRYPOINT</code>这类命令的身份。</p><p><code>HEALTHCHECK</code>支持下列选项:</p><ul><li>–interval&#x3D;&lt;间隔&gt; :两次健康检查的间隔,默认为 30 秒;</li><li>–timeout&#x3D;&lt;时长&gt; :健康检查命令运行超时时间,如果超过这个时间,本次健康检查就被视为失败,默认 30 秒;</li><li>–retries&#x3D;&lt;次数&gt; :当连续失败指定次数后,则将容器状态视为_unhealthy_,默认3次。</li></ul><p><em><code>CMD</code>、<code>ENTRYPOINT</code>、<code>HEALTHCHECK</code>三者的共同点：在Dockerfile文件中只可以出现一次，如果出现多次，只有最后一个生效。</em></p><h2 id="镜像迁移"><a href="#镜像迁移" class="headerlink" title="镜像迁移"></a>镜像迁移</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker export container_id &gt; export_filename.tar</span><br><span class="line"></span><br><span class="line">cat export_filename.tar | docker import - repository:tag</span><br></pre></td></tr></table></figure><p>此处利用了Linux中的管道，将一个镜像文件从一台机器迁移到另一台机器</p><h2 id="docker-attach和docker-exec的区别"><a href="#docker-attach和docker-exec的区别" class="headerlink" title="docker attach和docker exec的区别"></a>docker attach和docker exec的区别</h2><p>相同点：</p><ul><li>两者都可以使用-d、-i参数，在同时使用这两个参数时，都是进入bash</li><li>-i参数是没有分配伪终端，但命令执行结果仍然返回</li></ul><p>不同点：</p><ul><li>在使用attach进入伪终端，输入exit退出时，会导致容器的停止</li><li>exec进入终端，输入exit退出时，不会导致容器的停止</li></ul><h2 id="容器的操作"><a href="#容器的操作" class="headerlink" title="容器的操作"></a>容器的操作</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container rm 容器名称</span><br><span class="line">docker container prune <span class="comment"># 清理所有处于终止状态的容器</span></span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器,可以添加-f参数。Docker 会发送SIGKILL信号给容器。</p><h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><p>在容器中管理数据主要有两种方式：</p><ul><li>数据卷(Volumes)</li><li>挂载主机目录(Bind mounts)</li></ul><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在同期之间共享和重用</li><li>对数据卷的修改会立即生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认一直存在，即使容器被删除</li></ul><h3 id="数据卷操作命令"><a href="#数据卷操作命令" class="headerlink" title="数据卷操作命令"></a>数据卷操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volume create &lt;volumename&gt; # 创建一个数据卷</span><br><span class="line">docker volume ls # 查看所有数据卷</span><br><span class="line">docker inspect &lt;contrainer name&gt; # 查看容器的信息</span><br><span class="line">docker volume rm &lt;volumename&gt; # 删除数据卷</span><br></pre></td></tr></table></figure><p>在用docker run命令的时候，使用 –mount标记来将数据卷挂载到容器里，在一次docker run中可以挂载多个数据卷。</p><p>数据卷是被设计用来持久化数据的，它的声明周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收机制。</p><h3 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h3><p>在容器中运行一个网络应用，要让外部也可以访问这些应用，可以通过-P或-p参数来执行端口映射</p><p>在使用<code>-P</code>标记时，Docker会随机映射一个<code>49000~49900</code>的端口到内部容器开放的网络端口。</p><h2 id="Compose中的两个重要概念"><a href="#Compose中的两个重要概念" class="headerlink" title="Compose中的两个重要概念"></a>Compose中的两个重要概念</h2><ul><li>服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目（project）：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义</li></ul><h2 id="docker-compose命令"><a href="#docker-compose命令" class="headerlink" title="docker-compose命令"></a>docker-compose命令</h2><p>命令选项</p><ul><li>-f, –file FILE 指定使用的 Compose 模板文件,默认为<code>docker-compose.yml</code>,可以多次指定。</li><li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</li><li>–x-networking 使用Docker的可拔插网络后端特性</li><li>–x-network-driver DRIVER 指定网络后端的驱动，默认为<code>bridge</code></li><li>–verbose 输出更多调试信息</li><li>-v, –version打印版本并退出</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Docker-中的三个基本概念&quot;&gt;&lt;a href=&quot;#Docker-中的三个基本概念&quot; class=&quot;headerlink&quot; title=&quot;Docker 中的三个基本概念&quot;&gt;&lt;/a&gt;Docker 中的三个基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;镜像(Image)&lt;/li&gt;
&lt;li&gt;容器(Container)&lt;/li&gt;
&lt;li&gt;仓库(Repository)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://blog.qaz327zz.tk/categories/Docker/"/>
    
    
    <category term="学习总结" scheme="https://blog.qaz327zz.tk/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="Docker" scheme="https://blog.qaz327zz.tk/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Python3爬虫之urllib模块</title>
    <link href="https://blog.qaz327zz.tk/190502/"/>
    <id>https://blog.qaz327zz.tk/190502/</id>
    <published>2019-05-02T02:45:54.000Z</published>
    <updated>2020-07-14T00:14:11.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python2-中的urllib和Python3中的urlllib的区别"><a href="#Python2-中的urllib和Python3中的urlllib的区别" class="headerlink" title="Python2 中的urllib和Python3中的urlllib的区别"></a>Python2 中的urllib和Python3中的urlllib的区别</h3><p>在python 2中有urllib和urllib2两个库进行实现请求的发送，但是再python 3中官方将urllib2库合并在了urllib库中。所以在3中使用urllib库时一定要先了解其中的四个模块：</p><ul><li>request：这个模块是最基本的HTTP请求模块，用来模拟发送请求。</li><li>error：异常处理模块，用来捕获异常，保证程序不会意外终止。</li><li>parse：工具模块，提供了许多URL处理方法，如拆分、解析、编码等</li><li>robotparser:用来识别网站的robots.txt文件，判断哪些网站可以爬，一般不用。<br>此处只讲解前三个的用法。</li></ul><span id="more"></span><h3 id="请求的发送"><a href="#请求的发送" class="headerlink" title="请求的发送"></a>请求的发送</h3><p>1、urlopen()函数<br>在urllib.request模块中提供了最基本的构造HTTP请求的方法，可以利用它进行模拟浏览器发送一个请求，同时它还具有处理授权验证、重定向、浏览器cookies等其他内容<br>下面以百度为例子，进行网页的抓取：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">response = request.urlopen(&#x27;http://www.baidu.com&#x27;)</span><br><span class="line">print(response.read().decode(&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure><p>可以很简单的看出，上面很简单的三行代码已经实现了一个简单的爬虫了。只不过这个爬虫获取下来的内容没有经过任何数据处理，我们可以很容的看到百度首页的源代码。<br>之后，查看返回的内容是什么类型的。<br><code>print(type(response))</code><br>输出为：<code>&lt;class &#39;http.client.HTTPResponse&#39;&gt;</code><br>可以发现，它是一个HTTPResponse类型的对象，接下来查看有那些函数和属性，使用<code>dir(response)</code>：<br>输出为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;__abstractmethods__&#x27;, &#x27;__class__&#x27;, &#x27;__del__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__enter__&#x27;, &#x27;__eq__&#x27;, &#x27;__exit__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__next__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;_abc_impl&#x27;, &#x27;_checkClosed&#x27;, &#x27;_checkReadable&#x27;, &#x27;_checkSeekable&#x27;, &#x27;_checkWritable&#x27;, &#x27;_check_close&#x27;, &#x27;_close_conn&#x27;, &#x27;_get_chunk_left&#x27;, &#x27;_method&#x27;, &#x27;_peek_chunked&#x27;, &#x27;_read1_chunked&#x27;, &#x27;_read_and_discard_trailer&#x27;, &#x27;_read_next_chunk_size&#x27;, &#x27;_read_status&#x27;, &#x27;_readall_chunked&#x27;, &#x27;_readinto_chunked&#x27;, &#x27;_safe_read&#x27;, &#x27;_safe_readinto&#x27;, &#x27;begin&#x27;, &#x27;chunk_left&#x27;, &#x27;chunked&#x27;, &#x27;close&#x27;, &#x27;closed&#x27;, &#x27;code&#x27;, &#x27;debuglevel&#x27;, &#x27;detach&#x27;, &#x27;fileno&#x27;, &#x27;flush&#x27;, &#x27;fp&#x27;, &#x27;getcode&#x27;, &#x27;getheader&#x27;, &#x27;getheaders&#x27;, &#x27;geturl&#x27;, &#x27;headers&#x27;, &#x27;info&#x27;, &#x27;isatty&#x27;, &#x27;isclosed&#x27;, &#x27;length&#x27;, &#x27;msg&#x27;, &#x27;peek&#x27;, &#x27;read&#x27;, &#x27;read1&#x27;, &#x27;readable&#x27;, &#x27;readinto&#x27;, &#x27;readinto1&#x27;, &#x27;readline&#x27;, &#x27;readlines&#x27;, &#x27;reason&#x27;, &#x27;seek&#x27;, &#x27;seekable&#x27;, &#x27;status&#x27;, &#x27;tell&#x27;, &#x27;truncate&#x27;, &#x27;url&#x27;, &#x27;version&#x27;, &#x27;will_close&#x27;, &#x27;writable&#x27;, &#x27;write&#x27;, &#x27;writelines&#x27;]</span><br></pre></td></tr></table></figure><p>其中最主要函数为：read()、readinto()、getheader(name)、getheaders()、fileno()等方法。<br>在调用read()方法时可以返回网页内容，使用status属性可以查看返回的状态码。<br>在urlopen()方法中，最基本的是简单网页的GET请求抓取。但是如果要传入一个参数呢？下面就讲解参数的使用方法。  </p><ol><li>data参数<br>在讲解之前，首先需要说明的是data参数是可选的，如果传入了此参数，要以字节流编码格式的内容，即bytes类型，需要进行转化。此时的请求方式不再是GET方法，而是POST方法.因为如果使用GET方法，会将传入data暴露在url中，十分不安全。<br>实例一:    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">data = bytes(parse.urlencode(&#123;&#x27;word&#x27;: &#x27;hello world&#x27;&#125;), encoding=&#x27;utf8&#x27;)</span><br><span class="line">response = request.urlopen(&#x27;http://httpbin.org/post&#x27;, data=data)</span><br><span class="line">print(response.read().decode(&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure>这里我们传入了一个参数word，值为hello world。由于发送的的data需要是字节流类型，此处使用到了上文提到的工具包函数parse，使用它将我们要传入的函数进行转码。在我们执行完这段代码后，服务器会给我们返回一下结果:    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;data&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;word&quot;: &quot;hello world&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">    &quot;Content-Length&quot;: &quot;16&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.7&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: null,</span><br><span class="line">  &quot;origin&quot;: &quot;115.60.58.52&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>此时我们可以很容易的看到，在返回的结果中有form字段，字段中的内容就是我们传入的data中的内容，至此我们已经模拟了表单提交的过程，以POST请求方式尽心传输数据。  </li><li>timeout参数<br>顾名思义，这个参数就是用来设置超时的。单位为秒，意思是当请求超出了设置的值后还有得到响应，就讲异常抛出。如果此参数不指定时间，使用全局默认时间。<br>实例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">response = request .urlopen(&#x27;http://httpbin.org/get&#x27;, timeout=0.1)</span><br><span class="line">print(response .read().decode(&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure>运行结果：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test_urllib_001.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    response = request .urlopen(&#x27;http://httpbin.org/get&#x27;, timeout=0.1)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 222, in urlopen</span><br><span class="line">    return opener.open(url, data, timeout)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 525, in open</span><br><span class="line">    response = self._open(req, data)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 543, in _open</span><br><span class="line">    &#x27;_open&#x27;, req)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 503, in _call_chain</span><br><span class="line">    result = func(*args)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 1345, in http_open</span><br><span class="line">    return self.do_open(http.client.HTTPConnection, req)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 1319, in do_open</span><br><span class="line">    raise URLError(err)</span><br><span class="line">urllib.error.URLError: &lt;urlopen error timed out&gt;</span><br></pre></td></tr></table></figure>这里我们设置了超时的时间是0.1秒。程序再执行0.1秒以后，服务器依然没有任何响应，于是抛出了URLError异常。可以从<code>&lt;urlopen error timed out&gt;</code>看出是网络超时。那么问题来了，如何抓取这种情况呢？<br>实例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request .urlopen(&#x27;http://httpbin.org/get&#x27;, timeout=0.1)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    if isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(&#x27;Time Out&#x27;)</span><br></pre></td></tr></table></figure>我们用try: … except: …来捕获异常，此处引入了socket模块。</li></ol><p>2、Request<br>到此，我们知道了如何用urlopen方法实现一个简单的请求发送。但是这些简单参数有时候并不能满足我们的需求，比如我们需要在请求中添加header，此时就需要一个更加强大的类来实现了，这就是本节要讲的Request类。<br>实例是最好的验证。<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">req = request.Request(&#x27;https://baidu.com&#x27;)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure><p>此处我们依然使用了上文的urlopen()方法，只是此时的参数不再是一个URL了，而是一个Request对象。另外，这个函数我们可以很灵活的配置我们需要的参数。看下它的构造方法吧：<br><code>urllib.request.Request(url, data=None, headers=&#123;&#125;,origin_req_host=None, unverifiable=False,method=None)</code><br>  解释下：</p><ul><li>url：请求的URL，必填项</li><li>data：字节流，请求时需要带的数据</li><li>header：请求头，在创建实例后可以通过add_header()添加</li><li>origin_req_host: 请求方的host名称或IP地址</li><li>unverifiable：表示请求是否无法是验证的，默认为False。意思是用户没有足够的权限来选择接收这个请求的结果。</li><li>method：请求是用的方法，如GET、POST等</li></ul><p>下面实现一个多参数构建请求的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">url = &#x27;http://httpbin.org/post&#x27;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    &#x27;name&#x27;: &quot;spider_road&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data= bytes(parse.urlencode(dict), encoding=&#x27;utf8&#x27;)</span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method =&#x27;POST&#x27;)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure><p>我们通过四个参数四个参数构建了这个请求，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;data&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;spider_road&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">    &quot;Content-Length&quot;: &quot;16&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: null,</span><br><span class="line">  &quot;origin&quot;: &quot;115.60.58.52&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>在上节中，我们简单的提到了如何对异常做出处理，但是程序在运行过程总会出现一些其他的错误，当出现这些错误时，异常处理还是很有必要做的。<br>1、URLError<br>URLError类来自于urllib库的error模块，继承自OSError类，由request模块产生的异常都已使用这个类来捕捉。<br>实例：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request.urlopen(&#x27;https://spider-road.com&#x27;)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure><p>上面的程序我们使用它打开了一个不存在的网址，我们使用try:… except:…来捕获了异常。<br>运行输出：<code>[Errno -2] Name or service not known</code>，此时有效得避免了程序异常终止。</p><p>2、HTTPError<br>它是URLError的子类，用来处理HTTP请求错误，比如认证请求失败等。它有一下3个属性：</p><ul><li>code： http状态码</li><li>reason：错误原因</li><li>headers： 返回请求头</li></ul><p>实例验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request.urlopen(&#x27;https://spider-road.com&#x27;)</span><br><span class="line">except error.HTTPError as e:</span><br><span class="line">    print(f&#x27;code:&#123;e.code&#125;\nreason:&#123;e.reason&#125;\nheaders:&#123;e.headers&#125;&#x27;)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure><p>由于没有该网站，所以最后返回的是：<code>[Errno 110] Connection timed out</code><br>至此，关于urllib请求和错误处理已经讲解完毕，后续还有关于此节更为高级的用法。欢迎订阅爬虫之道，我们在这里等待你的到来。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Python2-中的urllib和Python3中的urlllib的区别&quot;&gt;&lt;a href=&quot;#Python2-中的urllib和Python3中的urlllib的区别&quot; class=&quot;headerlink&quot; title=&quot;Python2 中的urllib和Python3中的urlllib的区别&quot;&gt;&lt;/a&gt;Python2 中的urllib和Python3中的urlllib的区别&lt;/h3&gt;&lt;p&gt;在python 2中有urllib和urllib2两个库进行实现请求的发送，但是再python 3中官方将urllib2库合并在了urllib库中。所以在3中使用urllib库时一定要先了解其中的四个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;request：这个模块是最基本的HTTP请求模块，用来模拟发送请求。&lt;/li&gt;
&lt;li&gt;error：异常处理模块，用来捕获异常，保证程序不会意外终止。&lt;/li&gt;
&lt;li&gt;parse：工具模块，提供了许多URL处理方法，如拆分、解析、编码等&lt;/li&gt;
&lt;li&gt;robotparser:用来识别网站的robots.txt文件，判断哪些网站可以爬，一般不用。&lt;br&gt;此处只讲解前三个的用法。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Python后端" scheme="https://blog.qaz327zz.tk/categories/Python%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="爬虫" scheme="https://blog.qaz327zz.tk/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="urllib" scheme="https://blog.qaz327zz.tk/tags/urllib/"/>
    
  </entry>
  
  <entry>
    <title>在Centos中架设ss服务</title>
    <link href="https://blog.qaz327zz.tk/190425/"/>
    <id>https://blog.qaz327zz.tk/190425/</id>
    <published>2019-04-25T03:05:00.000Z</published>
    <updated>2020-07-14T00:13:41.196Z</updated>
    
    <content type="html"><![CDATA[<p>想必大家都被国内的“墙”折磨过，是不是很难受，是不是有时候很无能为力。这里就为大家介绍几种上网的方式。</p><h3 id="Google访问助手"><a href="#Google访问助手" class="headerlink" title="Google访问助手"></a>Google访问助手</h3><p>如果你使用的是这种方式，那么恭喜你，下面介绍的内容和你无关了。</p><p>Google访问助手下载链接：<a href="http://ggfwzs.com/">链接</a></p><span id="more"></span><h3 id="架设SS服务"><a href="#架设SS服务" class="headerlink" title="架设SS服务"></a>架设SS服务</h3><p>架设环境</p><ul><li>一台可以访问外网的VPS服务器</li><li>Centos7 + Python2.x</li></ul><p>架设步骤</p><ul><li>安装必须的软件包:</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum upgrade -y</span><br><span class="line">yum groupinstall &quot;Development Tools&quot;</span><br><span class="line">yum install epel-release -y</span><br><span class="line">yum install python-setuptools python-pip m2crypto -y</span><br><span class="line"></span><br><span class="line">## 更新pip包</span><br><span class="line">python -m pip install -U pip</span><br><span class="line"></span><br><span class="line">## 安装shadowsocks</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><ul><li><p>创建配置文件</p><p>以下内容是创建唯一密码和端口的配置文件，如果多用户使用，建议直接使用多用户配置.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">### 单用户配置</span><br><span class="line">vim /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">  &quot;server_port&quot;:server_port,    #例如5460</span><br><span class="line">  &quot;local_port&quot;:1080,</span><br><span class="line">  &quot;password&quot;:&quot;password&quot;,</span><br><span class="line">  &quot;timeout&quot;:600,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 多用户配置</span><br><span class="line">vim /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">第一种：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:&quot;your_server_ip&quot;, # 或者使用 0.0.0.0</span><br><span class="line">  &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;local_port&quot;:1080,</span><br><span class="line">  &quot;port_password&quot;:&#123;   #端口号与密码</span><br><span class="line">    &quot;8989&quot;:&quot;password0&quot;,   # 左边是端口号，右边是密码</span><br><span class="line">    &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">    &quot;9002&quot;:&quot;password2&quot;,</span><br><span class="line">    &quot;9003&quot;:&quot;password3&quot;,</span><br><span class="line">    &quot;9004&quot;:&quot;password4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;timeout&quot;:300,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">  &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">第二种：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;timeout&quot;: 600,</span><br><span class="line">  &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">  &quot;port_password&quot;:&#123;</span><br><span class="line">    &quot;40001&quot;: &quot;password1&quot;,</span><br><span class="line">    &quot;40002&quot;: &quot;password2&quot;,</span><br><span class="line">    &quot;40003&quot;: &quot;password3&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_comment&quot;:&#123;</span><br><span class="line">    &quot;40001&quot;: &quot;xiaoming&quot;,</span><br><span class="line">    &quot;40002&quot;: &quot;lilei&quot;,</span><br><span class="line">    &quot;40003&quot;: &quot;mike&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>系统级服务关闭</p><p>在配置完成后，需要关闭防火墙，否者会造成无法科学上网。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop iptables</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>若配置完成，且防火墙关闭，依旧无法科学上网，那么看是否是浏览器设置问题，若浏览器有FQ插件且处于启用状态（浏览器启用代理），停用它。</p></li><li><p>测试是否可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 开启ss服务</span><br><span class="line">ssserver -c /etc/shadowsocks.json start</span><br></pre></td></tr></table></figure><p>如果可以使用，则说明配置完成</p></li><li><p>将SS服务变为系统级服务</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/shadowsocks.service</span><br><span class="line"></span><br><span class="line">### 将以下内容粘贴到打开的shadowsocks.service文件中</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable shadowsocks &amp;&amp; systemctl start shadowsocks</span><br></pre></td></tr></table></figure></li><li><p>为OpenVZ的VPS服务器做BBR加速</p><p>本安装<strong>适用于CentOS&#x2F;RHEL7+，Ubuntu15+，Debian8+</strong> 的64位系统，如不是请先重装系统，下载rintd二进制文件(原版bbr和修改版bbr二选一即可)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd_bbr_powered -O /root/rinetd </span><br></pre></td></tr></table></figure><p>最后一个为魔改版BBR，上面一个为原版。选一个下载就可以了。然后修改权限</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x rinetd</span><br></pre></td></tr></table></figure><p>修改rinetd的配置文件rinetd.conf,添加监听地址:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim rinetd.conf</span><br><span class="line"></span><br><span class="line"># bindadress bindport connectaddress connectport </span><br><span class="line">0.0.0.0 443 0.0.0.0 443</span><br><span class="line"></span><br><span class="line">0.0.0.0 80 0.0.0.0 80</span><br></pre></td></tr></table></figure><p>每一行都是一个端口，将端口改成你使用的端口就可以了。不要问我一行为什么要写两个相同的，我也不知道为什么。</p></li><li><p>将rinetd变为系统级应用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/rinetd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=rinetd</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/rinetd -f -c /root/rinetd.conf raw venet0:0</span><br><span class="line">Restart=always</span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rinetd &amp;&amp; systemctl start rinetd</span><br></pre></td></tr></table></figure><p>在以上操作完毕后，OpenVZ架构的VPS服务器在使用SS服务时，会明显感觉到访问速度快了很多。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;想必大家都被国内的“墙”折磨过，是不是很难受，是不是有时候很无能为力。这里就为大家介绍几种上网的方式。&lt;/p&gt;
&lt;h3 id=&quot;Google访问助手&quot;&gt;&lt;a href=&quot;#Google访问助手&quot; class=&quot;headerlink&quot; title=&quot;Google访问助手&quot;&gt;&lt;/a&gt;Google访问助手&lt;/h3&gt;&lt;p&gt;如果你使用的是这种方式，那么恭喜你，下面介绍的内容和你无关了。&lt;/p&gt;
&lt;p&gt;Google访问助手下载链接：&lt;a href=&quot;http://ggfwzs.com/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="科学上网" scheme="https://blog.qaz327zz.tk/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
    <category term="ss" scheme="https://blog.qaz327zz.tk/tags/ss/"/>
    
    <category term="科学上网" scheme="https://blog.qaz327zz.tk/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows10中Tensorflow GPU的安装</title>
    <link href="https://blog.qaz327zz.tk/190418/"/>
    <id>https://blog.qaz327zz.tk/190418/</id>
    <published>2019-04-18T00:27:27.000Z</published>
    <updated>2020-07-14T00:13:35.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tensorflow介绍"><a href="#Tensorflow介绍" class="headerlink" title="Tensorflow介绍"></a>Tensorflow介绍</h3><blockquote><p>TensorFlow™是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。</p></blockquote><span id="more"></span><h3 id="Tensorflow2-0-GPU版的安装"><a href="#Tensorflow2-0-GPU版的安装" class="headerlink" title="Tensorflow2.0 GPU版的安装"></a>Tensorflow2.0 GPU版的安装</h3><p>首先，先确定你要安装的是Tensorflow的CPU版还是GPU版。如果是CPU，请出门右转（开个玩笑）。</p><p>其次，Tensorflow分为1.x版本和2.x版本。在本文写的时候，Tensorflow刚出到2.0（preview）版本。对于本文而言，均采用pip的方式安装Tensorflow，并没有采用源码编译的方式。</p><p>如果你在pip安装的时候下载很慢，建议你pip使用<a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里开源镜像</a>源。具体配置方法为：</p><p>在阿里开源镜像中找到<code>pypi</code>，然后点击帮助。  </p><p>打开<code>C:\User\XXX</code>，然后在其中创建pip文件夹，打开刚创建的pip文件夹，在其中创建<code>pip.ini</code>文件。最后将下方代码粘贴进去即可。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><p>现在开始介绍Tensorflow的安装</p><ul><li><p>CPU版的安装</p><blockquote><p>如果你想安装的是Tensorflow1.x的版本，请使用<code>pip install tensorflow</code></p><p>如果是Tensorflow 2.x的版本，请使用&#96;pip install tensorflow&#x3D;&#x3D;2.0.0-alpha0</p></blockquote></li></ul><p>Tensorflow GPU安装时的准备工作：</p><p>在安装以下两个文件之前，先去<a href="https://tensorflow.google.cn/install/gpu">Tensorflow官网</a>查看GPU安装时对CUDA和cudnn的版本要求，特别要注意标红部分。</p><p><img src="/userImages/GPU_cuda_install.png"></p><ul><li><p>CUDA的下载与安装</p><p>下载网址:<a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a></p><p><img src="/userImages/cuda_download_1.png"></p><p>如果当前的CUDA Toolkit版本比较高，需要选择低版本的CUDA Toolkit，请点击_Legacy Releases_之后选择Tensorflow官网要求的版本。</p><p><img src="/userImages/cuda_download_2.png"></p><p><img src="/userImages/cuda_download_3.png"></p><p>最后等待下载完毕。</p><p><img src="/userImages/cuda_install_1.png"></p><p><img src="/userImages/cuda_install_2.png"></p><p>要特别主要自定义中的内容。</p><ul><li><p>CUDA中的内容选择</p><p>如果你不使用<code>Visual Studio</code>请把前面个方框中的<code>√</code>去掉。</p></li><li><p>NVIDIA GeForce Experience</p><p>可选可不选</p></li><li><p>Driver components</p><p>如果你<code>当前版本</code>高于或等于上面的<code>新版本</code>,那么此选项不选，如果你<code>当前版本</code>低于<code>新版本</code>，请选择。</p></li><li><p>Other components</p><p>可选可不选</p></li></ul><p><img src="/userImages/cuda_install_3.png"></p><p><img src="/userImages/cuda_install_4.png"></p><p><img src="/userImages/cuda_install_5.png"></p><p>最后直接点击<code>下一步</code>即可。</p></li><li><p>cudnn的下载与安装</p><p>cudnn的下载是需要登录的。</p><p>下载网址:<a href="https://developer.nvidia.com/cudnn">https://developer.nvidia.com/cudnn</a></p><p><img src="/userImages/cudnn_download_1.png"></p><p>在下载cudnn的时候，要特别注意cudnn对应的cuda版本号，cuda的版本要使用Tensorflow官网要求的版本号，否者会无法使用GPU版的。注意标红的第二部分。</p><p><img src="/userImages/cudnn_download_2.png"></p><p>然后点击<code>Windows 10</code>即可下载。</p><p>在将cudnn下载完毕后，cudnn不是安装程序，将其解压即可，然后将文件夹名改为<code>cudnn</code>，最后将该文件夹移动到<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0</code>中即可。</p></li><li><p>环境变量的配置</p><p>将以下两个路径添加进系统的环境变量中，最后将刚才添加的环境变量移动到最上面。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\CUPTI\libx64</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\cudnn\bin</span><br></pre></td></tr></table></figure><p><img src="/userImages/cuda_and_cudnn.png"></p></li><li><p>验证是否可用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.test.is_gpu_available() <span class="comment"># 将会弃用，效果同下</span></span><br><span class="line">tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><img src="/userImages/cuda_and_cudnn_1.png"></p><p>  通过以上程序，如果没有出错，则说明安装成功，如果出错，请仔细阅读以上内容。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Tensorflow介绍&quot;&gt;&lt;a href=&quot;#Tensorflow介绍&quot; class=&quot;headerlink&quot; title=&quot;Tensorflow介绍&quot;&gt;&lt;/a&gt;Tensorflow介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;TensorFlow™是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Tensorflow" scheme="https://blog.qaz327zz.tk/categories/Tensorflow/"/>
    
    
    <category term="Tensorflow" scheme="https://blog.qaz327zz.tk/tags/Tensorflow/"/>
    
    <category term="GPU" scheme="https://blog.qaz327zz.tk/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow知识总结</title>
    <link href="https://blog.qaz327zz.tk/190416-1/"/>
    <id>https://blog.qaz327zz.tk/190416-1/</id>
    <published>2019-04-16T02:30:52.000Z</published>
    <updated>2020-07-14T00:13:25.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消除过拟合的方法"><a href="#消除过拟合的方法" class="headerlink" title="消除过拟合的方法"></a>消除过拟合的方法</h3><ul><li>L1正则化   绝对值</li><li>L2正则化  平方</li><li>L3正则化  立方</li><li>L4正则化  4次方</li><li>dropout</li></ul><span id="more"></span><p>其中对图像的处理过程一般为:<br>输入 – &gt; 卷积 – &gt; 池化 –&gt; 卷积 –&gt; 池化 –&gt; 消除过拟合 –&gt;全连接层 – &gt; 全连接层 –&gt; 分类</p><p>max_pool函数的作用是降低系统的复杂度，其中pooling分为最大池化和平均值池化</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归的目标是找到一个与训练数据最为吻合的线性函数。对于2D数据是找到一个与数据相吻合的线性函数<br>线性回归是一种找到最适合一组点的直线或超平面的方法</p><p>在卷积运算中，对图像降维是通过修改卷积核的strides（步长）参数进行降维的。</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>单层CNN的实际用途是检测边缘。对于图像识别和分类任务而言，更常见的情形是使用不同的层类型支持某个卷积层。这些层有助于减少过拟合，并可加速训练过程和降低内存占用率。</p><p>tf.nn.depthwise_conv2d:将一个卷积层的输出连接到另一个卷积层的输入<br>tf.nn.separabel_conv2d:对于较大的模型，可保证在不牺牲准确率的前提下实现训练的加速。对于较小的模型，它能够快速收敛，但准确率较低。<br>tf.nn.conv2d_transpose:将一个卷积核应用于一个新的特征图，后者的每一部分都填充了与卷积核相同的值。当该卷积核遍历新图像时，任何重叠的部分都相加在一起。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>为神经网络引入非线性</p><p>在CNN中最常用的激活函数：<br>tf.nn.relu:<br>Relu是分段线性的。当输入为非负数时，输出与输入相同。当输入为负数时，输出均为0.<br>优点：不受梯度消失的影响，取值范围为[0,++]<br>缺点：当使用较大的学习速率时，易受达到饱和的神经元的影响。</p><p>tf.sigmoid:<br>sigmoid函数的返回值位于区间[0.0, 1.0]中。当输入值较大时，tf.sigmoid将返回一个接近于1.0的值，而输入值较小时，返回值将接近于0.0</p><p>tf.tanh:<br>双曲正切函数(tanh)与tf.sigmoid非常接近，且后者具有类似的优缺点。tf.tanh函数的值域为[-1.0, 1.0]</p><p>tf.nn.dropout:<br>依据某个可配置的概率将输出设为0.0.为学习到的输出添加少量噪声。</p><p>梯度是偏导数的矢量<br>Pandas 是用于进行数据分析和建模的重要库</p><ul><li>张量(Tensor)：是对高维数据的一种抽象式表达<br> Tensorflow张量是什么？</li><li>张量时用来表示多维数据的</li><li>张量时执行操作时的输入或输出数据</li><li>用户通过执行操作来创建或计算张量</li><li>张量的形状不一定在编译时确定，可以在运行时通过形状推断计算得出。</li></ul><p>会话是什么?<br>会话提供了估算张量和执行操作的运行环境，它是发放计算任务的客户端，所有计算任务都由它连接的执行引擎完成。</p><p>会话执行:</p><ul><li>估算张量(Tensor.eval)</li><li>执行操作(Operation.run)</li><li>会话执行(Session.run)</li></ul><p>会话执行原理：<br>调用sess.run(tain_op)语句执行训练操作时：</p><ul><li>首先，程序内部提取操作依赖的所有前置操作。这些操作的节点共同组成了一副子图</li><li>然后，程序将子图中的计算节点、存储节点和数据节点按照各自的执行设备分类。相同设备上的节点组成了一副局部图</li><li>最后，每个设备上的局部图在实际执行时，根据节点间的依赖关系将各个节点有序的加载到设备上执行。</li></ul><p>优化算法：<br>典型的机器学习和深度学习问题通常都需要转换为最优化问题进行求解。</p><p>求解最优化的问题的算法成为优化算法，他们通常采用迭代方式实现：首先设定一个初始的可行解。然后基于特定的函数反复重新计算可行解，直到找到一个最优解或达到预设的收敛条件。</p><p>不同的优化算法采用的迭代策略各有不同：</p><ul><li>有的使用目标函数的一阶导数，如梯度下降法</li><li>二阶导数，如牛顿法</li><li>前几轮迭代的信息，如Adam</li></ul><p>优化器是实现优化算法的载体：<br>一次典型的迭代优化应该分为以下3个步骤：</p><ul><li>计算梯度： 调用compute_gradients方法</li><li>处理梯度： 用户按照自己需求处理梯度值，如梯度裁剪和梯度加权等</li><li>应用梯度： 调用apply_grandients方法，将处理后的梯度值应用到模型参数</li></ul><p>Loss下降方法：</p><ul><li><p>随机梯度下降</p></li><li><p>最速下降法: tf.train.AdamOptimizer()</p></li></ul><p>监督学习典型算法:</p><ul><li>线性回归（Linear Regression）</li><li>逻辑回归（Logistic Regression）</li><li>决策树（Decision Tree）</li><li>随机森林（Random Forest）</li><li>最紧邻算法（k-NN）</li><li>朴素贝叶斯（Naice Bayes）</li><li>支持向量机（SVM）</li><li>感知器（Perceptron）</li><li>深度神经网络（DNN）</li></ul><p>Tensorflow训练模型的工作流</p><blockquote><p>数据读入–&gt; 数据分析 –&gt; 数据规范化 –&gt; 创建模型 –&gt; 创建会话 –&gt; 训练模型</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;消除过拟合的方法&quot;&gt;&lt;a href=&quot;#消除过拟合的方法&quot; class=&quot;headerlink&quot; title=&quot;消除过拟合的方法&quot;&gt;&lt;/a&gt;消除过拟合的方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;L1正则化   绝对值&lt;/li&gt;
&lt;li&gt;L2正则化  平方&lt;/li&gt;
&lt;li&gt;L3正则化  立方&lt;/li&gt;
&lt;li&gt;L4正则化  4次方&lt;/li&gt;
&lt;li&gt;dropout&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Tensorflow" scheme="https://blog.qaz327zz.tk/categories/Tensorflow/"/>
    
    
    <category term="Tensorflow" scheme="https://blog.qaz327zz.tk/tags/Tensorflow/"/>
    
    <category term="学习总结" scheme="https://blog.qaz327zz.tk/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
