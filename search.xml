<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MongoEngine所使用的操作符</title>
    <url>/171220/</url>
    <content><![CDATA[<h3 id="什么是MongoEngine？"><a href="#什么是MongoEngine？" class="headerlink" title="什么是MongoEngine？"></a>什么是MongoEngine？</h3><blockquote>
<p>MongoEngine是基于Python的对象系统设计的MongoDB专用的ORM框架。与SQLAlchemy不同的是，MongoEngine会自动生成一个唯一的标识，用ID属性表示。当然MongoEngine与SQLAlchemy还有很对不同的地方，比如字段类型等。</p>
</blockquote>
<span id="more"></span>

<h3 id="MongoEngine所支持的部分操作符"><a href="#MongoEngine所支持的部分操作符" class="headerlink" title="MongoEngine所支持的部分操作符"></a>MongoEngine所支持的部分操作符</h3><blockquote>
<p>操作符的表示形式为:加在关键字后面使用”__+操作符”(此处是两个” _ “),例如：publish_data__gt </p>
</blockquote>
<ul>
<li>ne：不等于</li>
<li>lt：小于</li>
<li>lte：小于或等于</li>
<li>gt：大于</li>
<li>gte：大于或等于</li>
<li>not：对一个操作符取否，例如publish_data__not__gt</li>
<li>in：值在列表中</li>
<li>nin：值不在列表中</li>
<li>mod：值%a&#x3D;&#x3D;b,a和b用(a,b)的方式传递</li>
<li>all：列表中的所有值都在该字段中</li>
<li>size：列表的大小</li>
<li>existes：在该字段中存在这个值</li>
</ul>
<h3 id="检测字符串的部分操作符"><a href="#检测字符串的部分操作符" class="headerlink" title="检测字符串的部分操作符"></a>检测字符串的部分操作符</h3><ul>
<li>exact：字符串相等</li>
<li>iexact：字符串相等（大小写不敏感）</li>
<li>contains：字符串包含该值</li>
<li>icontains：字符串包含该值（大小写不敏感）</li>
<li>startswith：字符串以该值开始</li>
<li>istartswith：字符串以该值开始（大小写不敏感）</li>
<li>endswith：字符串以该值结束</li>
<li>iendswith：字符串以该值结束（大小写不敏感）</li>
</ul>
<h3 id="可以对字段值进行修改的操作符"><a href="#可以对字段值进行修改的操作符" class="headerlink" title="可以对字段值进行修改的操作符"></a>可以对字段值进行修改的操作符</h3><ul>
<li>set：设置一个值</li>
<li>unset：删除一个值</li>
<li>inc：将值自增</li>
<li>dec：将值自减</li>
<li>push：把一个值加到列表的末尾</li>
<li>push_all：把几个值加到列表的末尾</li>
<li>pop：移除列表中的第一个或者是最后一个值</li>
<li>pull：移除列表中的值</li>
<li>pull_all：移除列表中的几个值</li>
<li>add_to_set：当且晋档某值不在列表中时，将其添加进列表</li>
</ul>
]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python实现的杨辉三角</title>
    <url>/171222/</url>
    <content><![CDATA[<p>某日，闲来无事做，就尝试着用Python实现了下杨辉三角，以下使用Python2 实现的杨辉三角 </p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">triangel</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27; &#x27;</span>*(<span class="number">20</span>*<span class="number">3</span>)+<span class="built_in">str</span>(<span class="number">1</span>)             <span class="comment">#定义起始两行</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27; &#x27;</span>*(<span class="number">19</span>*<span class="number">3</span>)+<span class="built_in">str</span>(<span class="number">1</span>)+<span class="string">&#x27; &#x27;</span>*<span class="number">5</span>+<span class="built_in">str</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">21</span>):</span><br><span class="line">        <span class="keyword">if</span> i ==<span class="number">3</span>:</span><br><span class="line">            L = [<span class="number">1</span>,<span class="number">1</span>]       <span class="comment">#初始化第二行        </span></span><br><span class="line">        L1 = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,i):</span><br><span class="line">            z = L[i-j-<span class="number">1</span>]+L[i-j] <span class="comment"># 通过上一行构建下一层数据</span></span><br><span class="line">            L1.append(z)        <span class="comment"># 将数据添加到一个空列表中</span></span><br><span class="line">        L = [<span class="number">1</span>]       <span class="comment"># 再次对L初始化</span></span><br><span class="line">        L.extend(L1)    <span class="comment"># 将两个列表合并</span></span><br><span class="line">        L.append(<span class="number">1</span>)     <span class="comment"># 在L列表中添加最后一个数据“1”</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以下内容为杨辉三角的打印</span></span><br><span class="line">        t = <span class="string">&#x27; &#x27;</span>*((<span class="number">21</span>-i)*<span class="number">3</span>)+<span class="built_in">str</span>(<span class="number">1</span>)   <span class="comment"># 每次循环进行初始化每列的第一个数据1</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(L)):   <span class="comment"># 以下为构建每列的除一个数据外的其他数据，</span></span><br><span class="line">            <span class="keyword">if</span> L[h]&lt;<span class="number">10</span>:             <span class="comment"># 如果数据小于10，就是其前面5个空格，如果</span></span><br><span class="line">                t = t + <span class="string">&#x27; &#x27;</span>*<span class="number">5</span>+<span class="built_in">str</span>(L[h]) <span class="comment">#数据小于100，就减少一个空格，依次类推，</span></span><br><span class="line">            <span class="keyword">elif</span> L[h] &lt;<span class="number">100</span>:         <span class="comment"># 直至剩余一个空格，用于分辨相邻的数据</span></span><br><span class="line">                t = t+<span class="string">&#x27; &#x27;</span>*<span class="number">4</span>+<span class="built_in">str</span>(L[h])</span><br><span class="line">            <span class="keyword">elif</span> L[h] &lt; <span class="number">1000</span>:</span><br><span class="line">                t = t + <span class="string">&#x27; &#x27;</span>*<span class="number">3</span>+<span class="built_in">str</span>(L[h])</span><br><span class="line">            <span class="keyword">elif</span> L[h] &lt; <span class="number">10000</span>:</span><br><span class="line">                t = t + <span class="string">&#x27; &#x27;</span>*<span class="number">2</span>+<span class="built_in">str</span>(L[h])</span><br><span class="line">            <span class="keyword">elif</span> L[h] &lt; <span class="number">100000</span>:</span><br><span class="line">                t = t + <span class="string">&#x27; &#x27;</span>*<span class="number">1</span>+<span class="built_in">str</span>(L[h])</span><br><span class="line">        <span class="built_in">print</span> t</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    triangel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/userImages/yanghuisanjiao.png" alt="杨辉三角"></p>
]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python实现贪心算法</title>
    <url>/180113/</url>
    <content><![CDATA[<p>题目： 圣诞节来临了，在城市A中，圣诞老人准备分发糖果。现在有多箱不同的糖果，每一种糖果都有自己的价值和重量。每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果。请问圣诞老人最多能带走多大价值的糖果。</p>
<span id="more"></span>

<p>输入数据： 输入的第一行由两个部分组成，分别为糖果箱数正整数n(1&lt;&#x3D;n&lt;&#x3D;100)，驯鹿能承受的最大重量正整数w(0&lt;w&lt;10000)；其余n行每行对应一箱糖果，由两部分正整数v和w组成，分别为一箱糖果的价值和重量。</p>
<p>输出要求： 输出圣诞老人能带走的糖果的最大总价值，保留一位小数，输出为一行。</p>
<p>输出样例： </p>
<table>
<thead>
<tr>
<th align="left">需要装的箱数</th>
<th align="left">4</th>
</tr>
</thead>
<tbody><tr>
<td align="left">驯鹿最大承受重量</td>
<td align="left">15</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">批次</th>
<th align="left">价值</th>
<th align="left">重量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">100</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">412</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">266</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">591</td>
<td align="left">2</td>
</tr>
</tbody></table>
<p>输出样例:</p>
<p>　1193.0</p>
<p>注：此处并没有按照这样的格式进行输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"></span><br><span class="line">input_a = raw_input(<span class="string">u&#x27;箱数:&#x27;</span>)</span><br><span class="line">input_b = raw_input(<span class="string">u&#x27;最大承受重量:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">list_c = []</span><br><span class="line">list_z = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">int</span>(input_a)+<span class="number">1</span>):</span><br><span class="line">    input_c = raw_input(<span class="string">&#x27;第&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;箱的总价值:&#x27;</span>)</span><br><span class="line">    input_d = raw_input(<span class="string">&#x27;第&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;箱的重量:&#x27;</span>)</span><br><span class="line">    avg = <span class="built_in">round</span>(<span class="built_in">int</span>(input_c)/<span class="built_in">int</span>(input_d),<span class="number">1</span>)<span class="comment">#每一箱，重量为1的价值</span></span><br><span class="line">    list_c.append(avg)<span class="comment">#添加到列表，用于之后做比较</span></span><br><span class="line">    list_z.append([<span class="built_in">int</span>(input_d),avg,<span class="number">0</span>])<span class="comment">#此处列表中添加列表，中间的列表一个存放总重量，第二个存放单位价值，第三个存放是否该物品已被取走</span></span><br><span class="line"></span><br><span class="line">list_c.sort(reverse=<span class="literal">True</span>) <span class="comment"># 降序排序</span></span><br><span class="line"><span class="built_in">sum</span> =[<span class="number">0</span>,<span class="number">0</span>]<span class="comment"># 用于存放取走的总重量，第一个参数是取走的重量，第二个是超出前的备份</span></span><br><span class="line">num =<span class="number">0</span></span><br><span class="line">ji = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_c)):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_z)):</span><br><span class="line">        <span class="keyword">if</span> ji == <span class="number">0</span>:<span class="comment">#做是否超出马车最大承受量的标记，未超出为0</span></span><br><span class="line">            <span class="keyword">if</span> (list_c[i] == list_z[k][<span class="number">1</span>]) <span class="keyword">and</span> (list_z[k][<span class="number">2</span>]==<span class="number">0</span>):</span><br><span class="line">                <span class="built_in">sum</span>[<span class="number">1</span>] = <span class="built_in">sum</span>[<span class="number">0</span>]<span class="comment">#备份</span></span><br><span class="line">                <span class="built_in">sum</span>[<span class="number">0</span>] = <span class="built_in">sum</span>[<span class="number">0</span>] + list_z[k][<span class="number">0</span>]<span class="comment">#取走的重量</span></span><br><span class="line">                v = list_z[k][<span class="number">0</span>]<span class="comment">#取走的重量</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>[<span class="number">0</span>] &gt; <span class="built_in">int</span>(input_b):<span class="comment">#如果所有取走的重量超出马车的重量，就依次减少一单元的重量</span></span><br><span class="line">                    ji = <span class="number">1</span><span class="comment">#超出为1</span></span><br><span class="line">                    t= list_z[k][<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#依次减去单位1的重量</span></span><br><span class="line">                        z = <span class="built_in">sum</span>[<span class="number">1</span>] + t<span class="comment">#使用备份进行判断，此时取走的数量已经大于最大承受量了</span></span><br><span class="line">                        <span class="keyword">if</span> z &lt;= <span class="built_in">int</span>(input_b):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        t = t-<span class="number">1</span></span><br><span class="line">                    v=t<span class="comment">#等于最大承受量时，价值较大的一件物品应取走的数量</span></span><br><span class="line">                    <span class="built_in">sum</span>[<span class="number">0</span>]=<span class="built_in">sum</span>[<span class="number">1</span>]<span class="comment">#从备份恢复</span></span><br><span class="line">                    <span class="built_in">sum</span>[<span class="number">0</span>] = <span class="built_in">sum</span>[<span class="number">0</span>] + t<span class="comment">#此时为真正的取走数量</span></span><br><span class="line">                num = list_c[i]*v + num<span class="comment">#总价值</span></span><br><span class="line">                list_z[k][<span class="number">2</span>] = <span class="number">1</span><span class="comment">#取走的标记</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">u&#x27;能带走的糖果的最大价值为:&#x27;</span>,num</span><br></pre></td></tr></table></figure>

<p>实现的效果图(此处用两组数据进行测试)：<br>第一组数据：<br><img src="/userImages/tanxin1.png" alt="测试结果1"></p>
<p>第二组数据：<br><img src="/userImages/tanxin2.png" alt="测试结果2"></p>
]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>玩命追一姑娘</title>
    <url>/180623/</url>
    <content><![CDATA[<h3 id="玩命的追一姑娘"><a href="#玩命的追一姑娘" class="headerlink" title="玩命的追一姑娘"></a>玩命的追一姑娘</h3><p>和朋友们聚会，大家决定玩一个游戏。<br>找一个主题，然后讲一段自己的真实经历，看看谁的经历最有起承转合，最催泪，最奇葩，或者最让人无语凝噎，想抄家伙。<br>最后我们选定了一个主题——你有没有玩命爱一个姑娘。<br>这个问题抛出来的时候，大家都沉默了，纷纷在记忆中寻找那一段为了姑娘、为了爱情玩命的激情岁月。<br>在座的男士们，有的已经结婚，有的有了女朋友，有的还是一如既往的单身狗。<br>在大家都沉默的片刻，四张点了根烟，说：“我的故事都到了嗓子眼了，我先说吧。”<br>我笑而不语，等着四张的下文。  </p>
<span id="more"></span>

<p>四张并没有四十岁。<br>我们二十来岁认识的时候，大家就管他叫四张了。<br>当时，我们都在山东上大学。<br>四张有个青梅竹马的女朋友叫何玉。<br>据四张说，自己和何玉从小穿开裆裤长大，一块啃过锅里的大腿骨，一块光着屁股洗过澡，更神奇的是，两个人生日只差两天，性格互补，血型一致，简直就是上天早就设定好的一对。<br>四张说，在我还不知道男孩和女孩在一起可以生小孩的时候，我就想跟何玉生小孩了。<br>两个人从小在一起过过家家，玩过给对方检查身体的游戏，不论见到谁的父母都可以直接叫爸妈。<br>四张跟何玉从小学到高中一直在一起，两个人一起经历了第二性征发育，长出喉结，胸脯耸起来，梦遗，初潮，青春期的各种烦躁，在别人都早恋的时候，两个人还是单纯得像是初生婴儿。<br>高中时代，何玉出过一次意外，失血过多。<br>四张不由分说地给何玉输了血。<br>四张说，看着我的血通过血管流进何玉的身体里，我就感觉我和何玉血脉相通了。就好像，就好像我把我的基因输送到何玉身体里一样。跟做爱的感觉一模一样，有战栗，有晕眩，还有高潮。真的，不骗人。  </p>
<p>最终，两个人去了山东两所相邻的大学，隔着一百八十公里。<br>上大学是两个人这么多年来第一次分开，四张说，我就好像经历了一次连体婴儿分离手术，而何玉就是我的幻肢，我总觉得一转头就能看见她，可是真转过头，又发现她不在了。  </p>
<p>真正的变故发生在一年后的情人节前夜。<br>四张接到了何玉的一通电话，电话里，何玉不无娇羞地说，四张，四张，有个男孩子跟我表白哎，你说我该不该答应他啊？<br>四张傻了，在四张听起来，这仿佛就是在问，老公老公，有个男孩子要跟我睡觉哎，你说我该不该答应他？<br>四张疯了，跳起来，念叨着，哎呀，我擦，我擦，我擦。<br>四张外套都没穿，直接冲出宿舍，抄起自己的自行车，蹬上车就往外狂奔。<br>夜色中的马路上，一个只穿着毛衣的缺货发狂地蹬着自行车，正在赶往一百八十公里之外的城市，问题是他要去干嘛呢？<br>四张说，当时我自己也不知道我也去干嘛，也许是去灭口。  </p>
<p>四张发狂地蹬了一整夜自行车，从毛衣到内裤都湿透了，整个人冒着热气，像是一个瓦特时代的蒸汽机。<br>到了情人节当天中午，四张终于赶到了何玉的宿舍，跳下自行车的时候，四张差点瘫在地上。<br>多年以后，四张回忆起来的时候，恨恨地说了一句英文：“I cannot feel my legs”  </p>
<p>何玉从女生宿舍楼下来的时候，四张正用一种诡异的外八字站着，穿着毛衣，瑟缩着，像是刚刚从戒备最森严的监狱里越狱而出。<br>何玉惊得差点背过气去，你怎么来了？你外套呢？<br>何玉不等四张说话，冲回去，不一会儿，拿着一件女式的粉色及膝羽绒服跑出来，不由分说地套在了四张身上。<br>四张继续用外八字的姿势站着，穿着粉色的女式及膝羽绒服，好不容易憋出一句话，你答应了？<br>何玉一愣，什么？<br>四张几乎都带了哭腔，你答应和追你的那个男人好了？<br>何玉哭笑不得，我……我还没有。<br>四张疯了，那你是准备答应了？<br>何玉沉默了一会儿，娇羞上脸，我不知道。哎，不过我问你，男生追求女生的时候，是不是脑子里都想着那个啊？<br>四张一下子这句话打得痛彻心扉。<br>时隔多年，四张回忆起那个时刻，还是痛得弯下了腰，恨不得立刻倒在地上舔马路。  </p>
<p>当天晚上，何玉带着四张到学校餐厅吃了饺子，把四张安排到男生宿舍睡一晚。<br>四张送何玉回女生宿舍的时候，那个追求何玉的男生抱着一束花等在了宿舍楼底下。<br>男生看到何玉身旁穿着粉色女式及膝羽绒服的四张，狐疑地往后退了两步。<br>何玉不好意思地对四张说，我过去跟他说两句。<br>四张说不出话，就看着何玉跑向那个男生，两个人叽里咕噜地不知道在说什么，四张恨自己为什么不好好学学唇语。<br>就在四张忍不住要冲过去的时候，何玉接过了男生递给她的那束花，对着男生娇羞地笑笑。<br>四张听见自己心碎的声音，不是咔嚓，也不是吧唧，也不是轰隆，而是何玉的笑声，呵呵。<br>四张男性的尊严终于复苏，他转身就跑，只留下何玉在他身后喊，你去哪啊？<br>夜色中的马路上，一个穿着女式及膝羽绒服的倒霉缺货，拼命地瞪着自行车奔驰在马路上。<br>四张形容说，那时候的心痛就像是，我的内脏全长在了外面，每走一步，都被粗糙的柏油马路摩擦。  </p>
<p>四张无法想象，自己青梅竹马了二十年的女孩，在情人节的夜晚，当着自己的面，答应了另一个不知道哪冒出来的男人的求爱。<br>四张觉得这个世界不会好了。<br>我们帮四张分析，也许是因为，熟悉的地方没有风景，熟悉的男人没有小鸡鸡吧。<br>四张哭着骂了一句，操你们大爷。  </p>
<p>大学里剩下的时光，四张没有谈恋爱，转而对各种社团活动产生了兴趣。先后参加过什么大学生电路装置比赛，大学生贫困山区十日行，大学生街头公益筹款之类。  </p>
<p>毕业之后，何玉拿到一份不错的offer，去了北京，成了北漂的一员。<br>四张就在山东一家运输公司跑货运，开着那种大卡车，一趟车要跑三四天，车上吃，车上睡，夏天就在驾驶室里挂个蚊帐，冬天就浑身贴着暖宝宝，车里放十几把暖瓶。碰上堵车的时候，也能堵个两三天，四张就和同样被困的司机斗地主，打保皇。<br>一次， 四张开着卡车跑长途送一车情趣玩具，路上，突然接到了何玉的电话。<br>何玉在电话里哭着说，四张，四张，我钱包丢了，身份证也没了，我租的房子下水道也堵了，现在正往外冒水，我找不到房东，我不知道该怎么办？<br>四张一听，嘴里念叨着，哎呀，我擦，我擦，我擦。<br>当即猛地掉转车头，临时改了路线，憋着一泡从山东就带着的尿，拉着一车情趣玩具就往北京狂奔，完全忘记了等着发货那批淘宝店店主。  </p>
<p>四张的大货车开不进小区，四张就把车停在小区外面的马路上，自己跳下车，憋着那泡尿，冲到了何玉租住的小区砸门。<br>何玉打开门，看着风尘仆仆的四张，呆住了。<br>四张从牙缝里提出一句话，先让我撒个尿。  </p>
<p>何玉听着四张水流湍急地打击着马桶，惊魂未定。<br>紧接着，又听见洗手间里，四张吭哧吭哧的声音。<br>半个小时后，四张走出来，洗手间里焕然一新，下水道也疏通了。<br>四张甩下一叠钱，还有一张银行卡，对何玉说，你先用着。<br>何玉刚要感谢，四张的手机急促的响起，货运公司老板在电话里狂吼，你他妈去哪了？<br>四张一下子急了，嘴里念叨着，哎呀，我擦，我擦，我擦。急忙冲出去，何玉在身后喊，你倒是吃了饭再走啊。<br>四张跑到小区外面，发现两个交警，面对着大货车，不知所措。<br>大货车的吨位，交警的拖车是拖不走的。<br>四张硬着头皮，跑过去，和交警套近乎，说，我老婆生孩子，您行行好。<br>四张认栽交了罚款，又开着货车，拉着一车情趣玩具，在高速公路上狂奔。  </p>
<p>四张任劳任怨，勤勤恳恳，攒了钱，自己买了一辆卡车，继续跑着长途，送过各种各样稀奇古怪的货物。<br>他最爱看的电影是《玩命快递》，四张说，这演的就他妈是我啊。我有一次大半夜的，就在一条黑压压的马路上，遇到拦路抢劫的。他们弄了一颗树横在马路中间，我一看不好，猛踩油门，飞驰而过。开除十公里之后，才发现两个轮胎都漏气了。  </p>
<p>四张再一次跑北京的时候，在北京留了一天。<br>何玉请四张吃饭。<br>何玉看起来有些奇怪，说话吞吞吐吐。<br>四张不耐烦，有事你就直说，跟我还用得着客气？<br>何玉说，我男朋友做生意，需要一笔钱周转，否则他过不了这个坎。<br>四张一愣，你什么时候交的男朋友？我怎么不知道？<br>何玉有些惭愧，我不想跟你说，我怕说了你难受。<br>四张沉默。<br>何玉说，他借了高利贷。<br>四张点了根烟，问，缺多少钱。<br>何玉鼓足勇气，说，十万。<br>四张抽了两口烟，给我五天，五天之后，我打你银行卡上。<br>四张说着就起身走了，留下何玉愣在原地。  </p>
<p>回到山东，四张把卡车卖了，加上自己的积蓄，凑了十万块给何玉。<br>我们都骂他，你脑残了？你不想想，万一何玉那个什么男朋友是个骗子呢？<br>四张无所谓的笑笑，我感觉，那男的百分百是骗子，好男人就是他妈再难，也不会向自己的女人开口要钱。<br>我们都惊呆了，你丫知道还借给她？<br>四张说，她要的东西，我没法拒绝。再说，让她上上课也好，她哪都好，就是太单纯。<br>我们再一次惊呆，她单纯？我看啊，是你傻逼。<br>四张切了一声，大智若愚，聪明还是傻逼，得分事儿。  </p>
<p>卖了卡车之后，四张又回到了原来的运输公司，继续打工。<br>一样勤勤恳恳，任劳任怨。<br>两个月后，何玉打电话给四张，哭着说，她男朋友不见了，电话也不接，他是个骗子。我对不起你。<br>四张说，不就十万块钱吗？有什么大不了的。花十万块，让你长长记性，值了。<br>何玉在电话里泣不成声。  </p>
<p>四张最爱跑的一条线，就是从山东到北京，他说，总觉得何玉在哪，哪立马就不一样了。就算何玉在撒哈拉，撒哈拉也能凭空生出喷泉来。就算何玉在索马里，索马里就立马变成天上人间。<br>何玉却消失了一段时间，再也没有联系四张，不知道是不是因为觉得自己就是个扫把星，总是拖累四张，因此故意远离四张的生活。  </p>
<p>又到了冬天。<br>四张依旧跑着长途，这次他拉着一车泡面跑北京，天寒地冻，高速公路上的积雪刚刚撒过盐，几乎都融化了，但是风很大。四张顺风撒尿的时候，尿柱射到了几百米外的广告牌上。<br>四张过了收费站口，猛地踩了刹车，他看见一个熟悉的身影，站在一望无际的高速公路隔离带旁边，冻得瑟瑟发抖，是何玉。<br>四张头发都炸起来了，他的车堵在高速公路入口，自己跳下去，几乎是飞到何玉面前，一把抱住何玉。<br>何玉整个人冻得就跟个冰美人一样，四张抱着何玉的时候打了个冷战，四张又生气又心疼，你他妈在这干嘛？<br>何玉泣不成声，我在这等了你三天了。晚上就在收费站里睡。我算错了时间，可我又不敢走，怕错过你。<br>四张疯了，你不会打个电话吗？<br>何玉说，我总是给你打电话，打电话给你都没好事，这一次我想见你。<br>四张紧紧地抱住何玉，直到高速公路路口堵成一排的车集体狂摁喇叭。  </p>
<p>四张开着大货车，行驶在冰雪皑皑的高速公路上。<br>何玉坐在副驾驶，身上裹着四张的军大衣，正在吃着一碗热气腾腾的泡面。<br>何玉吃完泡面，掏出两万块钱给四张。<br>四张生气了，你这是干什么？<br>何玉说，这是我这段时间攒的，还欠你八万，以后我就跟着你跑长途，给你打工，给你洗衣服，给你做饭。<br>四张傻了，你疯了，跑长途这是女人干的活吗？<br>何玉恨铁不成钢，从小到大，你怎么总是抓不到我的重点？我的重点在后半句，给你洗衣服，给你做饭！<br>四张愣愣地看着何玉，傻了。<br>何玉双颊都冻伤了，泛着红光，认真地看着四张。<br>大卡车远远地往前飞奔。  </p>
<p>今年，四张又买了一辆卡车，取了个名字，叫“何玉号”。<br>被同行取笑，你以为你开的是驱逐舰吗？<br>四张说，我开的就是驱逐舰，只属于我和我老婆的驱逐舰，一切坏人坏事统统退避。  </p>
<p>四张讲完了自己的故事，大家忍不住给她鼓掌。<br>四张憨笑，其实这也不算玩命爱一个姑娘，离着玩命还早呢。我只是觉得，既然爱了，就用点力，用点力总不会是坏事。<br>这个时候，一个女孩大着肚子走过来，走到四张身边。<br>四张吓坏了，你怎么来了？<br>女孩很娇羞，开玩笑似的，我想你了啊。<br>我们都愣住。<br>四张有些尴尬，跟大家介绍，这是我老婆，何玉。<br>我们都站起来，一起喊，嫂子好。<br>何玉被眼前的阵势吓了一跳，你们好，你们好，有空来家里喝酒。<br>四张笑得很欠揍，明目张胆秀恩爱。  </p>
<p>生命中，有些错过，最后成为了错过。<br>而有些错过，因为两个人的勇敢，又变成了相遇。<br>我们都期待美满的故事，但其实恰恰是靠着我们的勇气，让故事变得美满，让爱人就离着自己一个枕头的距离，有时候甚至是负20厘米的距离。<br>男人应该玩命爱一个姑娘。<br>好姑娘也值得被男人玩命去爱。<br>爱情，本来就是勇敢者的游戏。<br>如果你不够勇敢，你很快就会出局。<br>如果你够勇敢，此刻转个身，就能抱住你所爱的人吧。  </p>
]]></content>
      <categories>
        <category>短文</category>
      </categories>
      <tags>
        <tag>青春</tag>
        <tag>付出</tag>
      </tags>
  </entry>
  <entry>
    <title>使用chromedriver实现豆瓣网页的全网页截图</title>
    <url>/190108/</url>
    <content><![CDATA[<p>最近由于工作需要，需要对部分网站进行全文截屏。在网上搜了很久没有搜出好的方法，而且在新版的selenium中已经不在支持PhantomJS了，所以全文截取变得有点棘手。</p>
<span id="more"></span>

<p>此处给出一个简单的方法，以20行代码实现<code>selenium+chromedriver+python</code>实现豆瓣的全文截取。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--dns-prefetch-disable&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--no-referrers&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--disable-audio&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--allow-insecure-localhost&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=options)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.douban.com&#x27;</span>)</span><br><span class="line">width = driver.execute_script(</span><br><span class="line">        <span class="string">&quot;return Math.max(document.body.scrollWidth, document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth);&quot;</span>)</span><br><span class="line">height = driver.execute_script(</span><br><span class="line">        <span class="string">&quot;return Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);&quot;</span>)</span><br><span class="line">driver.set_window_size(width + <span class="number">100</span>, height + <span class="number">100</span>)</span><br><span class="line">driver.save_screenshot(<span class="string">&#x27;douban.png&#x27;</span>)</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<p><img src="/userImages/doubanjieping.png" alt="豆瓣全屏截取"></p>
]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>Chromedriver</tag>
        <tag>全页面截屏</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow知识总结</title>
    <url>/190416-1/</url>
    <content><![CDATA[<h3 id="消除过拟合的方法"><a href="#消除过拟合的方法" class="headerlink" title="消除过拟合的方法"></a>消除过拟合的方法</h3><ul>
<li>L1正则化   绝对值</li>
<li>L2正则化  平方</li>
<li>L3正则化  立方</li>
<li>L4正则化  4次方</li>
<li>dropout</li>
</ul>
<span id="more"></span>

<p>其中对图像的处理过程一般为:<br>输入 – &gt; 卷积 – &gt; 池化 –&gt; 卷积 –&gt; 池化 –&gt; 消除过拟合 –&gt;全连接层 – &gt; 全连接层 –&gt; 分类</p>
<p>max_pool函数的作用是降低系统的复杂度，其中pooling分为最大池化和平均值池化</p>
<h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归的目标是找到一个与训练数据最为吻合的线性函数。对于2D数据是找到一个与数据相吻合的线性函数<br>线性回归是一种找到最适合一组点的直线或超平面的方法</p>
<p>在卷积运算中，对图像降维是通过修改卷积核的strides（步长）参数进行降维的。</p>
<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>单层CNN的实际用途是检测边缘。对于图像识别和分类任务而言，更常见的情形是使用不同的层类型支持某个卷积层。这些层有助于减少过拟合，并可加速训练过程和降低内存占用率。</p>
<p>tf.nn.depthwise_conv2d:将一个卷积层的输出连接到另一个卷积层的输入<br>tf.nn.separabel_conv2d:对于较大的模型，可保证在不牺牲准确率的前提下实现训练的加速。对于较小的模型，它能够快速收敛，但准确率较低。<br>tf.nn.conv2d_transpose:将一个卷积核应用于一个新的特征图，后者的每一部分都填充了与卷积核相同的值。当该卷积核遍历新图像时，任何重叠的部分都相加在一起。</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>为神经网络引入非线性</p>
<p>在CNN中最常用的激活函数：<br>tf.nn.relu:<br>Relu是分段线性的。当输入为非负数时，输出与输入相同。当输入为负数时，输出均为0.<br>优点：不受梯度消失的影响，取值范围为[0,++]<br>缺点：当使用较大的学习速率时，易受达到饱和的神经元的影响。</p>
<p>tf.sigmoid:<br>sigmoid函数的返回值位于区间[0.0, 1.0]中。当输入值较大时，tf.sigmoid将返回一个接近于1.0的值，而输入值较小时，返回值将接近于0.0</p>
<p>tf.tanh:<br>双曲正切函数(tanh)与tf.sigmoid非常接近，且后者具有类似的优缺点。tf.tanh函数的值域为[-1.0, 1.0]</p>
<p>tf.nn.dropout:<br>依据某个可配置的概率将输出设为0.0.为学习到的输出添加少量噪声。</p>
<p>梯度是偏导数的矢量<br>Pandas 是用于进行数据分析和建模的重要库</p>
<ul>
<li>张量(Tensor)：是对高维数据的一种抽象式表达<br> Tensorflow张量是什么？</li>
<li>张量时用来表示多维数据的</li>
<li>张量时执行操作时的输入或输出数据</li>
<li>用户通过执行操作来创建或计算张量</li>
<li>张量的形状不一定在编译时确定，可以在运行时通过形状推断计算得出。</li>
</ul>
<p>会话是什么?<br>会话提供了估算张量和执行操作的运行环境，它是发放计算任务的客户端，所有计算任务都由它连接的执行引擎完成。</p>
<p>会话执行:</p>
<ul>
<li>估算张量(Tensor.eval)</li>
<li>执行操作(Operation.run)</li>
<li>会话执行(Session.run)</li>
</ul>
<p>会话执行原理：<br>调用sess.run(tain_op)语句执行训练操作时：</p>
<ul>
<li>首先，程序内部提取操作依赖的所有前置操作。这些操作的节点共同组成了一副子图</li>
<li>然后，程序将子图中的计算节点、存储节点和数据节点按照各自的执行设备分类。相同设备上的节点组成了一副局部图</li>
<li>最后，每个设备上的局部图在实际执行时，根据节点间的依赖关系将各个节点有序的加载到设备上执行。</li>
</ul>
<p>优化算法：<br>典型的机器学习和深度学习问题通常都需要转换为最优化问题进行求解。</p>
<p>求解最优化的问题的算法成为优化算法，他们通常采用迭代方式实现：首先设定一个初始的可行解。然后基于特定的函数反复重新计算可行解，直到找到一个最优解或达到预设的收敛条件。</p>
<p>不同的优化算法采用的迭代策略各有不同：</p>
<ul>
<li>有的使用目标函数的一阶导数，如梯度下降法</li>
<li>二阶导数，如牛顿法</li>
<li>前几轮迭代的信息，如Adam</li>
</ul>
<p>优化器是实现优化算法的载体：<br>一次典型的迭代优化应该分为以下3个步骤：</p>
<ul>
<li>计算梯度： 调用compute_gradients方法</li>
<li>处理梯度： 用户按照自己需求处理梯度值，如梯度裁剪和梯度加权等</li>
<li>应用梯度： 调用apply_grandients方法，将处理后的梯度值应用到模型参数</li>
</ul>
<p>Loss下降方法：</p>
<ul>
<li><p>随机梯度下降</p>
</li>
<li><p>最速下降法: tf.train.AdamOptimizer()</p>
</li>
</ul>
<p>监督学习典型算法:</p>
<ul>
<li>线性回归（Linear Regression）</li>
<li>逻辑回归（Logistic Regression）</li>
<li>决策树（Decision Tree）</li>
<li>随机森林（Random Forest）</li>
<li>最紧邻算法（k-NN）</li>
<li>朴素贝叶斯（Naice Bayes）</li>
<li>支持向量机（SVM）</li>
<li>感知器（Perceptron）</li>
<li>深度神经网络（DNN）</li>
</ul>
<p>Tensorflow训练模型的工作流</p>
<blockquote>
<p>数据读入–&gt; 数据分析 –&gt; 数据规范化 –&gt; 创建模型 –&gt; 创建会话 –&gt; 训练模型</p>
</blockquote>
]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow的基础学习和资料</title>
    <url>/190416/</url>
    <content><![CDATA[<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="以下内容为测试内容"><a href="#以下内容为测试内容" class="headerlink" title="以下内容为测试内容"></a>以下内容为测试内容</h3><blockquote>
<p>以下内容未测试内容</p>
</blockquote>
<p>中文测试</p>
<p>再次测试</p>
]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>机器学习</tag>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tkinter进行图片的遍历显示</title>
    <url>/190228/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>最近因为要写个GUI的内容，需要用到图像的遍历显示，因为没有办法,所以就自行摸索着开始写一个循环显示的TK。最终算是不符所望吧，勉强写出来一个，以此做下记录，便于下次使用。</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageTk, Image</span><br><span class="line"><span class="keyword">import</span> glob, time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">filenames = glob.glob(<span class="string">&#x27;sysImages/*&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autoQuit</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    root.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">    root = tk.Tk()</span><br><span class="line"></span><br><span class="line">    img = Image.<span class="built_in">open</span>(filename)</span><br><span class="line">    photo = ImageTk.PhotoImage(img)</span><br><span class="line">    label = tk.Label(image=photo)</span><br><span class="line">    label.image = photo</span><br><span class="line">    label.pack()</span><br><span class="line"></span><br><span class="line">    t = threading.Thread(target=autoQuit)</span><br><span class="line">    t.start()</span><br><span class="line">    root.mainloop()</span><br><span class="line">    root.destroy()</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>tkinter</tag>
        <tag>遍历图片</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10中Tensorflow GPU的安装</title>
    <url>/190418/</url>
    <content><![CDATA[<h3 id="Tensorflow介绍"><a href="#Tensorflow介绍" class="headerlink" title="Tensorflow介绍"></a>Tensorflow介绍</h3><blockquote>
<p>TensorFlow™是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。</p>
</blockquote>
<span id="more"></span>

<h3 id="Tensorflow2-0-GPU版的安装"><a href="#Tensorflow2-0-GPU版的安装" class="headerlink" title="Tensorflow2.0 GPU版的安装"></a>Tensorflow2.0 GPU版的安装</h3><p>首先，先确定你要安装的是Tensorflow的CPU版还是GPU版。如果是CPU，请出门右转（开个玩笑）。</p>
<p>其次，Tensorflow分为1.x版本和2.x版本。在本文写的时候，Tensorflow刚出到2.0（preview）版本。对于本文而言，均采用pip的方式安装Tensorflow，并没有采用源码编译的方式。</p>
<p>如果你在pip安装的时候下载很慢，建议你pip使用<a href="https://opsx.alibaba.com/mirror?lang=zh-CN">阿里开源镜像</a>源。具体配置方法为：</p>
<p>在阿里开源镜像中找到<code>pypi</code>，然后点击帮助。  </p>
<p>打开<code>C:\User\XXX</code>，然后在其中创建pip文件夹，打开刚创建的pip文件夹，在其中创建<code>pip.ini</code>文件。最后将下方代码粘贴进去即可。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<p>现在开始介绍Tensorflow的安装</p>
<ul>
<li><p>CPU版的安装</p>
<blockquote>
<p>如果你想安装的是Tensorflow1.x的版本，请使用<code>pip install tensorflow</code></p>
<p>如果是Tensorflow 2.x的版本，请使用&#96;pip install tensorflow&#x3D;&#x3D;2.0.0-alpha0</p>
</blockquote>
</li>
</ul>
<p>Tensorflow GPU安装时的准备工作：</p>
<p>在安装以下两个文件之前，先去<a href="https://tensorflow.google.cn/install/gpu">Tensorflow官网</a>查看GPU安装时对CUDA和cudnn的版本要求，特别要注意标红部分。</p>
<p><img src="/userImages/GPU_cuda_install.png"></p>
<ul>
<li><p>CUDA的下载与安装</p>
<p>下载网址:<a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a></p>
<p><img src="/userImages/cuda_download_1.png"></p>
<p>如果当前的CUDA Toolkit版本比较高，需要选择低版本的CUDA Toolkit，请点击_Legacy Releases_之后选择Tensorflow官网要求的版本。</p>
<p><img src="/userImages/cuda_download_2.png"></p>
<p><img src="/userImages/cuda_download_3.png"></p>
<p>最后等待下载完毕。</p>
<p><img src="/userImages/cuda_install_1.png"></p>
<p><img src="/userImages/cuda_install_2.png"></p>
<p>要特别主要自定义中的内容。</p>
<ul>
<li><p>CUDA中的内容选择</p>
<p>如果你不使用<code>Visual Studio</code>请把前面个方框中的<code>√</code>去掉。</p>
</li>
<li><p>NVIDIA GeForce Experience</p>
<p>可选可不选</p>
</li>
<li><p>Driver components</p>
<p>如果你<code>当前版本</code>高于或等于上面的<code>新版本</code>,那么此选项不选，如果你<code>当前版本</code>低于<code>新版本</code>，请选择。</p>
</li>
<li><p>Other components</p>
<p>可选可不选</p>
</li>
</ul>
<p><img src="/userImages/cuda_install_3.png"></p>
<p><img src="/userImages/cuda_install_4.png"></p>
<p><img src="/userImages/cuda_install_5.png"></p>
<p>最后直接点击<code>下一步</code>即可。</p>
</li>
<li><p>cudnn的下载与安装</p>
<p>cudnn的下载是需要登录的。</p>
<p>下载网址:<a href="https://developer.nvidia.com/cudnn">https://developer.nvidia.com/cudnn</a></p>
<p><img src="/userImages/cudnn_download_1.png"></p>
<p>在下载cudnn的时候，要特别注意cudnn对应的cuda版本号，cuda的版本要使用Tensorflow官网要求的版本号，否者会无法使用GPU版的。注意标红的第二部分。</p>
<p><img src="/userImages/cudnn_download_2.png"></p>
<p>然后点击<code>Windows 10</code>即可下载。</p>
<p>在将cudnn下载完毕后，cudnn不是安装程序，将其解压即可，然后将文件夹名改为<code>cudnn</code>，最后将该文件夹移动到<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0</code>中即可。</p>
</li>
<li><p>环境变量的配置</p>
<p>将以下两个路径添加进系统的环境变量中，最后将刚才添加的环境变量移动到最上面。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\CUPTI\libx64</span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\cudnn\bin</span><br></pre></td></tr></table></figure>

<p><img src="/userImages/cuda_and_cudnn.png"></p>
</li>
<li><p>验证是否可用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.test.is_gpu_available() <span class="comment"># 将会弃用，效果同下</span></span><br><span class="line">tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/userImages/cuda_and_cudnn_1.png"></p>
<p>  通过以上程序，如果没有出错，则说明安装成功，如果出错，请仔细阅读以上内容。</p>
]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>在Centos中架设ss服务</title>
    <url>/190425/</url>
    <content><![CDATA[<p>想必大家都被国内的“墙”折磨过，是不是很难受，是不是有时候很无能为力。这里就为大家介绍几种上网的方式。</p>
<h3 id="Google访问助手"><a href="#Google访问助手" class="headerlink" title="Google访问助手"></a>Google访问助手</h3><p>如果你使用的是这种方式，那么恭喜你，下面介绍的内容和你无关了。</p>
<p>Google访问助手下载链接：<a href="http://ggfwzs.com/">链接</a></p>
<span id="more"></span>

<h3 id="架设SS服务"><a href="#架设SS服务" class="headerlink" title="架设SS服务"></a>架设SS服务</h3><p>架设环境</p>
<ul>
<li>一台可以访问外网的VPS服务器</li>
<li>Centos7 + Python2.x</li>
</ul>
<p>架设步骤</p>
<ul>
<li>安装必须的软件包:</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yum upgrade -y</span><br><span class="line">yum groupinstall &quot;Development Tools&quot;</span><br><span class="line">yum install epel-release -y</span><br><span class="line">yum install python-setuptools python-pip m2crypto -y</span><br><span class="line"></span><br><span class="line">## 更新pip包</span><br><span class="line">python -m pip install -U pip</span><br><span class="line"></span><br><span class="line">## 安装shadowsocks</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建配置文件</p>
<p>以下内容是创建唯一密码和端口的配置文件，如果多用户使用，建议直接使用多用户配置.</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">### 单用户配置</span><br><span class="line">vim /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">  &quot;server_port&quot;:server_port,    #例如5460</span><br><span class="line">  &quot;local_port&quot;:1080,</span><br><span class="line">  &quot;password&quot;:&quot;password&quot;,</span><br><span class="line">  &quot;timeout&quot;:600,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 多用户配置</span><br><span class="line">vim /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">第一种：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;:&quot;your_server_ip&quot;, # 或者使用 0.0.0.0</span><br><span class="line">  &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;local_port&quot;:1080,</span><br><span class="line">  &quot;port_password&quot;:&#123;   #端口号与密码</span><br><span class="line">    &quot;8989&quot;:&quot;password0&quot;,   # 左边是端口号，右边是密码</span><br><span class="line">    &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">    &quot;9002&quot;:&quot;password2&quot;,</span><br><span class="line">    &quot;9003&quot;:&quot;password3&quot;,</span><br><span class="line">    &quot;9004&quot;:&quot;password4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;timeout&quot;:300,</span><br><span class="line">  &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">  &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">第二种：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;timeout&quot;: 600,</span><br><span class="line">  &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">  &quot;port_password&quot;:&#123;</span><br><span class="line">    &quot;40001&quot;: &quot;password1&quot;,</span><br><span class="line">    &quot;40002&quot;: &quot;password2&quot;,</span><br><span class="line">    &quot;40003&quot;: &quot;password3&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_comment&quot;:&#123;</span><br><span class="line">    &quot;40001&quot;: &quot;xiaoming&quot;,</span><br><span class="line">    &quot;40002&quot;: &quot;lilei&quot;,</span><br><span class="line">    &quot;40003&quot;: &quot;mike&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统级服务关闭</p>
<p>在配置完成后，需要关闭防火墙，否者会造成无法科学上网。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop iptables</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<p>若配置完成，且防火墙关闭，依旧无法科学上网，那么看是否是浏览器设置问题，若浏览器有FQ插件且处于启用状态（浏览器启用代理），停用它。</p>
</li>
<li><p>测试是否可用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 开启ss服务</span><br><span class="line">ssserver -c /etc/shadowsocks.json start</span><br></pre></td></tr></table></figure>

<p>如果可以使用，则说明配置完成</p>
</li>
<li><p>将SS服务变为系统级服务</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/shadowsocks.service</span><br><span class="line"></span><br><span class="line">### 将以下内容粘贴到打开的shadowsocks.service文件中</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>设置开机启动</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">systemctl enable shadowsocks &amp;&amp; systemctl start shadowsocks</span><br></pre></td></tr></table></figure>
</li>
<li><p>为OpenVZ的VPS服务器做BBR加速</p>
<p>本安装<strong>适用于CentOS&#x2F;RHEL7+，Ubuntu15+，Debian8+</strong> 的64位系统，如不是请先重装系统，下载rintd二进制文件(原版bbr和修改版bbr二选一即可)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd_bbr_powered -O /root/rinetd </span><br></pre></td></tr></table></figure>

<p>最后一个为魔改版BBR，上面一个为原版。选一个下载就可以了。然后修改权限</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">chmod +x rinetd</span><br></pre></td></tr></table></figure>

<p>修改rinetd的配置文件rinetd.conf,添加监听地址:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim rinetd.conf</span><br><span class="line"></span><br><span class="line"># bindadress bindport connectaddress connectport </span><br><span class="line">0.0.0.0 443 0.0.0.0 443</span><br><span class="line"></span><br><span class="line">0.0.0.0 80 0.0.0.0 80</span><br></pre></td></tr></table></figure>

<p>每一行都是一个端口，将端口改成你使用的端口就可以了。不要问我一行为什么要写两个相同的，我也不知道为什么。</p>
</li>
<li><p>将rinetd变为系统级应用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/rinetd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=rinetd</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/rinetd -f -c /root/rinetd.conf raw venet0:0</span><br><span class="line">Restart=always</span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>设置开机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable rinetd &amp;&amp; systemctl start rinetd</span><br></pre></td></tr></table></figure>

<p>在以上操作完毕后，OpenVZ架构的VPS服务器在使用SS服务时，会明显感觉到访问速度快了很多。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ss</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习总结</title>
    <url>/190502-1/</url>
    <content><![CDATA[<h2 id="Docker-中的三个基本概念"><a href="#Docker-中的三个基本概念" class="headerlink" title="Docker 中的三个基本概念"></a>Docker 中的三个基本概念</h2><ul>
<li>镜像(Image)</li>
<li>容器(Container)</li>
<li>仓库(Repository)</li>
</ul>
<span id="more"></span>

<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p>镜像不包含任何动态数据，其内容在构建之后也不会改变</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>是镜像的运行时实例 - 实际执行时镜像会在内存中变成什么。默认情况下，它完全独立于主机环境运行，仅在配置为访问主机文件和端口的情况下才执行此操作。</p>
<h2 id="非root用户执行docker"><a href="#非root用户执行docker" class="headerlink" title="非root用户执行docker"></a>非root用户执行docker</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 创建docker组，一般是存在的。</span><br><span class="line">	sudo groupadd docker</span><br><span class="line">2. 将当前用户添加到docker组</span><br><span class="line">	sudo usermod -aG docker $USER</span><br><span class="line">3. 注销当前登陆用户，从新登陆</span><br><span class="line">4. 验证是否可以行</span><br><span class="line">	docker ps</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker build -t friendlyname .<span class="comment"># 使用此目录的 Dockerfile 创建镜像</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -p 4000:80 friendlyname  <span class="comment"># 运行端口 4000 到 90 的“友好名称”映射</span></span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d -p 4000:80 friendlyname         <span class="comment"># 内容相同，但在分离模式下</span></span></span><br><span class="line">docker ps                                 <span class="comment"># 查看所有正在运行的容器的列表</span></span><br><span class="line">docker stop &lt;hash&gt;                     <span class="comment"># 平稳地停止指定的容器</span></span><br><span class="line">docker ps -a           <span class="comment"># 查看所有容器的列表，甚至包含未运行的容器</span></span><br><span class="line">docker kill &lt;hash&gt;                   <span class="comment"># 强制关闭指定的容器</span></span><br><span class="line">docker rm &lt;hash&gt;              <span class="comment"># 从此机器中删除指定的容器</span></span><br><span class="line">docker rm $(docker ps -a -q)           <span class="comment"># 从此机器中删除所有容器</span></span><br><span class="line">docker images -a                               <span class="comment"># 显示此机器上的所有镜像</span></span><br><span class="line">docker rmi &lt;imagename&gt;            <span class="comment"># 从此机器中删除指定的镜像</span></span><br><span class="line">docker rmi $(docker images -q)             <span class="comment"># 从此机器中删除所有镜像</span></span><br><span class="line">docker login             <span class="comment"># 使用您的 Docker 凭证登录此 CLI 会话</span></span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># 标记 &lt;image&gt; 以上传到镜像库</span></span><br><span class="line">docker push username/repository:tag            <span class="comment"># 将已标记的镜像上传到镜像库</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> username/repository:tag                   <span class="comment"># 运行镜像库中的镜像</span></span></span><br><span class="line">docker stack ls              <span class="comment"># 列出此 Docker 主机上所有正在运行的应用</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  <span class="comment"># 运行指定的 Compose 文件</span></span><br><span class="line">docker stack services &lt;appname&gt;       <span class="comment"># 列出与应用关联的服务</span></span><br><span class="line">docker stack ps &lt;appname&gt;   <span class="comment"># 列出与应用关联的正在运行的容器</span></span><br><span class="line">docker stack rm &lt;appname&gt;                             <span class="comment"># 清除应用</span></span><br><span class="line">docker-machine create --driver virtualbox myvm1 <span class="comment"># 创建 VM（Mac、Win7、Linux）</span></span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch <span class="string">&quot;myswitch&quot;</span> myvm1 <span class="comment"># Win10</span></span><br><span class="line">docker-machine <span class="keyword">env</span> myvm1                <span class="comment"># 查看有关节点的基本信息</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker node ls&quot;</span>         <span class="comment"># 列出 swarm 中的节点</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker node inspect &lt;node ID&gt;&quot;</span>        <span class="comment"># 检查节点</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker swarm join-token -q worker&quot;</span>   <span class="comment"># 查看加入令牌</span></span><br><span class="line">docker-machine ssh myvm1   <span class="comment"># 打开与 VM 的 SSH 会话；输入“exit”以结束会话</span></span><br><span class="line">docker-machine ssh myvm2 <span class="string">&quot;docker swarm leave&quot;</span>  <span class="comment"># 使工作节点退出 swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker swarm leave -f&quot;</span> <span class="comment"># 使主节点退出，终止 swarm</span></span><br><span class="line">docker-machine start myvm1            <span class="comment"># 启动当前未运行的 VM</span></span><br><span class="line">docker-machine stop $(docker-machine ls -q)               <span class="comment"># 停止所有正在运行的 VM</span></span><br><span class="line">docker-machine rm $(docker-machine ls -q) <span class="comment"># 删除所有 VM 及其磁盘镜像</span></span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~     <span class="comment"># 将文件复制到节点的主目录</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker stack deploy -c &lt;file&gt; &lt;app&gt;&quot;</span>   <span class="comment"># 部署应用</span></span><br></pre></td></tr></table></figure>

<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker save -o &lt;localfilename&gt; &lt;flename&gt; <span class="comment">#导出镜像到本地文件</span></span><br><span class="line">docker load --input &lt;filename&gt; <span class="comment">#从导出的本地文件中再导入到本地镜像库</span></span><br><span class="line">docker load &lt; &lt;filename&gt; <span class="comment">#同上，导入镜像以及其相关的元数据信息(包括标签等)(生成镜像文件)</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d ... <span class="comment"># 使docker容器在后台以守护态形式运行</span></span></span><br><span class="line">docker export &lt;container id&gt; &gt; &lt;localfilename&gt; <span class="comment"># 将本地的某个容器导出</span></span><br><span class="line">docker import - &lt;repository:tag&gt; <span class="comment"># 将容器快照文件导入为镜像 (生成镜像快照)</span></span><br><span class="line">docker load 和 docker import 的区别：</span><br><span class="line">  docker import 将丢弃所有的历史记录和元数据信息(仅保存容器当时的快照状态)，</span><br><span class="line">  docker load 将保存完整记录，体积较大</span><br><span class="line">  docker import 导入时可以重新指定标签等元数据信息</span><br><span class="line">docker image ls --digests <span class="comment"># 列出所有镜像的摘要</span></span><br><span class="line">docker image rm &lt;id、repository:tag&gt; <span class="comment"># 删除镜像，在通过id删除时，可以指定前3个字符以上，但是要能足够用于区分别的镜像</span></span><br><span class="line">docker image rm &lt;digest&gt; <span class="comment"># 精确删除</span></span><br></pre></td></tr></table></figure>


<p><em>Union FS 是有最大层数限制的,比如 AUFS，一个镜像不能超过127层</em></p>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>仓库名、标签均为<code>&lt;none&gt;</code>的镜像，被称为虚悬镜像</p>
<p>显示虚悬镜像：<code>docker image ls -f dangling=true</code></p>
<p>删除虚悬镜像：<code>docker image prune</code></p>
<h2 id="docker-中的过滤器"><a href="#docker-中的过滤器" class="headerlink" title="docker 中的过滤器"></a>docker 中的过滤器</h2><p>在docker image ls还支持使用过滤器参数 –filter或-f</p>
<ul>
<li>since 在某个镜像之后建立的镜像</li>
<li>before在某个镜像之前建立的镜像</li>
<li>dangling未打开标签</li>
</ul>
<p>镜像是多层存储,每一层是在前一层的基础上进行的修改;而容器同样也是多层存储,是在以镜像为基础层,在其基础上加一层作为容器运行时的存储层。</p>
<p>镜像的定制实际上就是定制每一层所添加的配置、文件.</p>
<p>在构建Dockerfile时，如果使用了scratch为基础镜像，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始，这样减少了镜像体积。</p>
<h2 id="从标准输入中读取Dockerfile"><a href="#从标准输入中读取Dockerfile" class="headerlink" title="从标准输入中读取Dockerfile"></a>从标准输入中读取Dockerfile</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line">或</span><br><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure>

<p>如果标准输入传入的是文本文件，则将其视为<code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，它没有上下文，因此不以像其他方法那样将文本文件<code>Copy</code>进镜像之类的事情</p>
<h2 id="ADD中更高级的复制文件"><a href="#ADD中更高级的复制文件" class="headerlink" title="ADD中更高级的复制文件"></a>ADD中更高级的复制文件</h2><p>ADD指令将会自动解压缩这个压缩文件到&lt;目标路径&gt;</p>
<h2 id="COPY和ADD指令选择时遵循的原则"><a href="#COPY和ADD指令选择时遵循的原则" class="headerlink" title="COPY和ADD指令选择时遵循的原则"></a>COPY和ADD指令选择时遵循的原则</h2><p>所有文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD</p>
<p>Docker 不是虚拟机,容器中的应用都应该以前台执行,而不是像虚拟机、物理机里面那样,用upstart&#x2F;systemd 去启动后台服务,容器内没有后台服务的概念。<br>启动程序就是容器应用进程,容器就是为了主进程而存在的,主进程退出,容器就失去了存在的意义。<br>当使用ENTRYPOINT后，CMD的内容将会作为参数传给ENTRYPOINT。</p>
<p><code>EXPOSE</code>指令是声明运行时容器提供的服务端口</p>
<p><code>WORKDIR</code>可以来指定工作目录(或者称为当前目录)，以后各层的当前目录就被改为指定的目录，如果目录不存在，WORKDIR自动创建目录。</p>
<p><code>USER</code>和<code>WORKDIR</code>都是改变环境状态并影响以后的层。<code>WORKDIR</code>是改变工作目录，<code>USER</code>则是改变之后层的执行<code>RUN</code>、<code>CMD</code>以及<code>ENTRYPOINT</code>这类命令的身份。</p>
<p><code>HEALTHCHECK</code>支持下列选项:</p>
<ul>
<li>–interval&#x3D;&lt;间隔&gt; :两次健康检查的间隔,默认为 30 秒;</li>
<li>–timeout&#x3D;&lt;时长&gt; :健康检查命令运行超时时间,如果超过这个时间,本次健康检查就被视为失败,默认 30 秒;</li>
<li>–retries&#x3D;&lt;次数&gt; :当连续失败指定次数后,则将容器状态视为_unhealthy_,默认3次。</li>
</ul>
<p><em><code>CMD</code>、<code>ENTRYPOINT</code>、<code>HEALTHCHECK</code>三者的共同点：在Dockerfile文件中只可以出现一次，如果出现多次，只有最后一个生效。</em></p>
<h2 id="镜像迁移"><a href="#镜像迁移" class="headerlink" title="镜像迁移"></a>镜像迁移</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker export container_id &gt; export_filename.tar</span><br><span class="line"></span><br><span class="line">cat export_filename.tar | docker import - repository:tag</span><br></pre></td></tr></table></figure>

<p>此处利用了Linux中的管道，将一个镜像文件从一台机器迁移到另一台机器</p>
<h2 id="docker-attach和docker-exec的区别"><a href="#docker-attach和docker-exec的区别" class="headerlink" title="docker attach和docker exec的区别"></a>docker attach和docker exec的区别</h2><p>相同点：</p>
<ul>
<li>两者都可以使用-d、-i参数，在同时使用这两个参数时，都是进入bash</li>
<li>-i参数是没有分配伪终端，但命令执行结果仍然返回</li>
</ul>
<p>不同点：</p>
<ul>
<li>在使用attach进入伪终端，输入exit退出时，会导致容器的停止</li>
<li>exec进入终端，输入exit退出时，不会导致容器的停止</li>
</ul>
<h2 id="容器的操作"><a href="#容器的操作" class="headerlink" title="容器的操作"></a>容器的操作</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker container rm 容器名称</span><br><span class="line">docker container prune <span class="comment"># 清理所有处于终止状态的容器</span></span><br></pre></td></tr></table></figure>

<p>如果要删除一个运行中的容器,可以添加-f参数。Docker 会发送SIGKILL信号给容器。</p>
<h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷(Volumes)</li>
<li>挂载主机目录(Bind mounts)</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在同期之间共享和重用</li>
<li>对数据卷的修改会立即生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷默认一直存在，即使容器被删除</li>
</ul>
<h3 id="数据卷操作命令"><a href="#数据卷操作命令" class="headerlink" title="数据卷操作命令"></a>数据卷操作命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker volume create &lt;volumename&gt; # 创建一个数据卷</span><br><span class="line">docker volume ls # 查看所有数据卷</span><br><span class="line">docker inspect &lt;contrainer name&gt; # 查看容器的信息</span><br><span class="line">docker volume rm &lt;volumename&gt; # 删除数据卷</span><br></pre></td></tr></table></figure>

<p>在用docker run命令的时候，使用 –mount标记来将数据卷挂载到容器里，在一次docker run中可以挂载多个数据卷。</p>
<p>数据卷是被设计用来持久化数据的，它的声明周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收机制。</p>
<h3 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h3><p>在容器中运行一个网络应用，要让外部也可以访问这些应用，可以通过-P或-p参数来执行端口映射</p>
<p>在使用<code>-P</code>标记时，Docker会随机映射一个<code>49000~49900</code>的端口到内部容器开放的网络端口。</p>
<h2 id="Compose中的两个重要概念"><a href="#Compose中的两个重要概念" class="headerlink" title="Compose中的两个重要概念"></a>Compose中的两个重要概念</h2><ul>
<li>服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目（project）：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义</li>
</ul>
<h2 id="docker-compose命令"><a href="#docker-compose命令" class="headerlink" title="docker-compose命令"></a>docker-compose命令</h2><p>命令选项</p>
<ul>
<li>-f, –file FILE 指定使用的 Compose 模板文件,默认为<code>docker-compose.yml</code>,可以多次指定。</li>
<li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li>–x-networking 使用Docker的可拔插网络后端特性</li>
<li>–x-network-driver DRIVER 指定网络后端的驱动，默认为<code>bridge</code></li>
<li>–verbose 输出更多调试信息</li>
<li>-v, –version打印版本并退出</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习总结</title>
    <url>/190502-2/</url>
    <content><![CDATA[<h1 id="git整理："><a href="#git整理：" class="headerlink" title="git整理："></a>git整理：</h1><blockquote>
<p>工作区中的.git目录为Git版本库，git add将文件提交到暂存区,git commit将文件提交到本地仓库，git push将文件提交到远程仓库。</p>
</blockquote>
<span id="more"></span>

<h1 id="历史版本回退及提交至远程仓库"><a href="#历史版本回退及提交至远程仓库" class="headerlink" title="历史版本回退及提交至远程仓库"></a>历史版本回退及提交至远程仓库</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^  可以回退版本  当回退多个版本时可以使用 HEAD~100（恢复到第100个版本）。</span><br><span class="line">git reflog 用于记录每次的命令，最上方为最近一次的命令</span><br><span class="line">git reset HEAD &lt;file&gt; 将缓存区中的修改回退到工作区。</span><br><span class="line">git checkout -- &lt;file&gt; 将版本库中的版本替换工作区的版本，可以做恢复用。</span><br><span class="line">git push 将当前分支master推送到远程</span><br><span class="line">git commit 将缓存区中的文件推送到分支master(本地)</span><br></pre></td></tr></table></figure>

<h1 id="分支的创建、切换与合并"><a href="#分支的创建、切换与合并" class="headerlink" title="分支的创建、切换与合并"></a>分支的创建、切换与合并</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt; 创建一个分支并切换，等同于git branch &lt;branch&gt; git checkout &lt;branch&gt;两条命令</span><br><span class="line">git branch 查看当前分支</span><br><span class="line">git merge 命令用于合并指定分支到当前分支</span><br><span class="line">git branch -d &lt;branch&gt; 删除分支</span><br><span class="line">git log --graph 可以查看分支合并图</span><br></pre></td></tr></table></figure>

<h1 id="对远程分支进行操作"><a href="#对远程分支进行操作" class="headerlink" title="对远程分支进行操作"></a>对远程分支进行操作</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git push origin --delete branch &lt;branchname&gt;或git push origin :&lt;branchname&gt; 删除远程仓库中的分支</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重命名远程分支：<br>1、删除远程分支：git push –delete origin <branchname><br>2、重命名本地分支：git branch -m <old> <new><br>3、推送本地分支：git push origin <NewBranchName></p>
</blockquote>
<h1 id="提交出错解决方法"><a href="#提交出错解决方法" class="headerlink" title="提交出错解决方法"></a>提交出错解决方法</h1><p>如果在提交远程仓库的时候出现“更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支”，此时应该先获取远程更新,然后合并本地的分支，最后提交.</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git fetch origin;		# 获取运程仓库</span><br><span class="line">git merge origin/master	# 将本地仓库与远程仓库合并</span><br><span class="line"></span><br><span class="line">git pull = git fetch + git merge 可能会产生冲突，需要手动解决</span><br><span class="line"></span><br><span class="line">--no-ff 参数表示禁用Fast forward</span><br></pre></td></tr></table></figure>
<p>如果出现”您要求从远程 ‘origin’ 拉取，但是未指定一个分支。因为这不是当前分支默认的远程仓库，您必须在命令行中指定一个分支名。”<br>执行以下内容：<br><code>git branch --set-upstream-to corigin/master master</code></p>
<h2 id="出错时"><a href="#出错时" class="headerlink" title="出错时"></a>出错时</h2><p>出错内容: </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">error: failed to push some refs to &#x27;https://github.com/bnq456/bnq456.github.io.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br></pre></td></tr></table></figure>
<ul>
<li>强制推送<br>在确定自己仓库中的内容低于本地仓库中的内容并且确定本地优于远程时，如果无法进行推送，可以选择强制推送<br><code>git push -u origin master -f</code></li>
<li>push前先将远程repository修改pull下来<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li>
<li>若不想merge远程和本地修改，可以先创建新的分支：<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git branch [name]</span><br><span class="line">然后push</span><br><span class="line">git push -u origin [name]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="fetch-和-pull的区别："><a href="#fetch-和-pull的区别：" class="headerlink" title="fetch 和 pull的区别："></a>fetch 和 pull的区别：</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git fetch：将远程主机的最新内容拉取到本地，是否合并由用户决定。</span><br><span class="line">git pull：将远程主机的最新内容拉取到本地后直接合并，可能会产生冲突，需要手动解决。</span><br><span class="line">解决方法：</span><br><span class="line">git reset --hard FETCH_HEAD</span><br><span class="line">git pull</span><br><span class="line">注：将本地的冲突文件冲掉，不仅需要reset到MERGE-HEAD或HEAD，还需要--hard。当后面没有hard，不会冲掉本地工作区，只会冲掉stage区。</span><br></pre></td></tr></table></figure>

<p><img src="/userImages/fetch_and_pull.png" alt="fetch和pull的不同"></p>
<h1 id="Git中工作环境的临时存储与恢复"><a href="#Git中工作环境的临时存储与恢复" class="headerlink" title="Git中工作环境的临时存储与恢复"></a>Git中工作环境的临时存储与恢复</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git stash 把当前工作现场存储起来，用于以后恢复现场继续工作</span><br><span class="line">切换回工作时：</span><br><span class="line">	git stash list 列出所有存储的工作环境</span><br><span class="line">result: stash@&#123;0&#125;: WIP on dev: cc559a8 add merge</span><br><span class="line">git stash pop 切回工作场景，或git stash apply stash@&#123;0&#125; 恢复后不删除stash中的内容，需要使用git stash drop &lt;name&gt;删除</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pop和 apply的区别<br>pop是将工作环境切回后直接删除<br>apply是先应用工作环境，然后存储的工作环境是否删除由用户自己决定。使用：git stash drop <name>进行删除</p>
</blockquote>
<blockquote>
<p>实验性质的代码最好新建分支</p>
</blockquote>
<h1 id="分支的创建、删除、合并与推送"><a href="#分支的创建、删除、合并与推送" class="headerlink" title="分支的创建、删除、合并与推送"></a>分支的创建、删除、合并与推送</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br><span class="line">git checkout &lt;branchname&gt;</span><br><span class="line">以上两条命令等同于git checkout -b &lt;branchname&gt;</span><br><span class="line">git branch -D &lt;name&gt; 表示强行删除一个分支</span><br><span class="line">git merge &lt;branchname&gt; 分支的合并，表示要将&lt;branchname&gt;分支合并到当前分支上</span><br><span class="line"></span><br><span class="line">分支的推送：</span><br><span class="line">master分支是主分支，因此要时刻与远程同步;</span><br><span class="line">dev分支是开发分支，团队所有成员都需要在上面工作，所以需要时刻与远程同步;</span><br><span class="line">bug分支是本地修复bug，可推送可不推送;</span><br><span class="line">feature分支取决与是否在上面进行开发。</span><br></pre></td></tr></table></figure>

<h1 id="多人协作："><a href="#多人协作：" class="headerlink" title="多人协作："></a>多人协作：</h1><blockquote>
<p>1、首先，可以试图用git push origin <branch-name>推送自己的修改；</p>
</blockquote>
<blockquote>
<p>2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
</blockquote>
<blockquote>
<p>3、如果合并有冲突，则解决冲突，并在本地提交；</p>
</blockquote>
<blockquote>
<p>4、没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</p>
</blockquote>
<blockquote>
<p>5、如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin&#x2F;<branch-name>。</p>
</blockquote>
<h1 id="rebase：（不是很了解）"><a href="#rebase：（不是很了解）" class="headerlink" title="rebase：（不是很了解）"></a>rebase：（不是很了解）</h1><blockquote>
<p>rebase操作可以将本地未push的分叉提交历史整理成一条直线;<br>rebase的目的是使我们在查看提交的变化时更容易，因为分叉的提交需要三方比较。</p>
</blockquote>
<h1 id="git-标签："><a href="#git-标签：" class="headerlink" title="git 标签："></a>git 标签：</h1><p>git tag <name>用于新建一个标签,默认为HEAD，当创建带有说明的标签时，用-a指定标签名，-m指定说明文字<br>git tag可以查看所有的标签<br>当给以前忘记打标签的项目打标签时，可以先找出要打标签项目的编号，然后git tag <tagname> <commit id><br>-d用于删除标签<br>    远程标签推送：<br>    git push origin <tagname>推送一个本地标签到远程<br>    git push origin –tags 将所有标签推送到远程</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">当删除远程标签时：</span><br><span class="line">1、首先先删除本地的标签 git tag -d &lt;tagname&gt;</span><br><span class="line">2、然后删除远程的标签 git push origin :refs/tags/&lt;tagname&gt;或者git push origin --delete tag &lt;tagname&gt;（作用与上两步相同）</span><br></pre></td></tr></table></figure>

<h1 id="日志文件查询"><a href="#日志文件查询" class="headerlink" title="日志文件查询"></a>日志文件查询</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL学习总结</title>
    <url>/190502-3/</url>
    <content><![CDATA[<h1 id="PG数据库："><a href="#PG数据库：" class="headerlink" title="PG数据库："></a>PG数据库：</h1><p>理解：对于PostgreSQL数据库，我个人理解为和MySQL数据库很相识，比MySQL功能多，在pg数据库中，用户可以指定表集合，这点和mongodb很像。</p>
<blockquote>
<p>模式(架构)：是指定的表集合，它还可以包含视图、索引、序列、数据类型、运算符和函数.</p>
</blockquote>
<span id="more"></span>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">创建模式:create schema &lt;schemaname&gt;</span><br></pre></td></tr></table></figure>
<h1 id="架构作用"><a href="#架构作用" class="headerlink" title="架构作用:"></a>架构作用:</h1><blockquote>
<p>1、模式有助于多用户使用一个数据库,而不会互相干扰</p>
<p>2、将数据库对象组织成逻辑组,使其更易于管理</p>
<p>3、可以将第三方模式放入单独的模式中,以避免与其他对象的名称相冲突</p>
</blockquote>
<h1 id="PostgreSQL中的连接类型："><a href="#PostgreSQL中的连接类型：" class="headerlink" title="PostgreSQL中的连接类型："></a>PostgreSQL中的连接类型：</h1><ul>
<li><p>内连接（inner join）显示两个集合共有部分（交集）</p>
<p>  select table1.columns,table2.columns from table1 inner join table2 on table1.common_filed &#x3D; table2.common_filed;</p>
</li>
<li><p>左外连接（left outer join）显示左集合的全部，右集合不满足的用空补全</p>
<p>  select table1.columns,table2.columns from table1 left outer join table2 on table1.common_filed &#x3D; table2.common_filed;</p>
</li>
<li><p>右外连接（right outer join）显示右集合的全部，左集合不满足的用空补全</p>
<p>  select table1.columns,table2.columns from table1 right outer join table2 on table1.common_filed &#x3D; table2.common_filed;</p>
</li>
<li><p>全连接（full outer join）显示两个集合的全部，不满足条件的用空补全</p>
<p>  select table1.columns,table2.columns from table1 full outer join table2 on table1.common_filed &#x3D; table2.common_filed;</p>
</li>
<li><p>跨连接（cross join）将第一个表的每一行与第二个表的每一行相匹配。</p>
<p>  select coloums from table1 cross join table2;</p>
</li>
<li><p>having子句和group by子句组合使用，用于选择函数结果满足某些条件的特定行。</p>
</li>
</ul>
<h1 id="普通用户创建与登陆："><a href="#普通用户创建与登陆：" class="headerlink" title="普通用户创建与登陆："></a>普通用户创建与登陆：</h1><blockquote>
<p>1、登陆超级用户：sudo -u postgres psql</p>
<p>2、创建用户：create user dbuser encrypted password ‘test’;</p>
<p>3、授权：alter user dbuser with createdb; alter user dbuser with login;</p>
<p>4、创建dbuser用户的数据集：create database dbusers with owner&#x3D;’dbuser’;</p>
<p>5、退出\q</p>
<p>6、普通用户登陆：psql -U dbuser -d dbusers -h localhost</p>
</blockquote>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">function</span> auditlogfunc() <span class="keyword">returns</span> <span class="keyword">trigger</span> <span class="keyword">as</span> $example_table$</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> audit(emp_id,entry_date) <span class="keyword">values</span> (new.ID, <span class="built_in">current_timestamp</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$example_table$ <span class="keyword">language</span> plpgsql;</span><br></pre></td></tr></table></figure>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> example_trigger after <span class="keyword">insert</span> <span class="keyword">on</span> company <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="keyword">execute</span> <span class="keyword">procedure</span> auditlogfunc();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PostgreSQL触发器目的：</p>
<p>1、验证输入数据</p>
<p>2、执行业务规则</p>
<p>3、为不同文件中新插入的行生成唯一值</p>
<p>4、写入其他文件以急性审计跟踪</p>
<p>5、从其他文件查询交叉引用目的</p>
<p>6、访问系统函数</p>
<p>7、将数据复制到不同的文件以实现数据一致性</p>
</blockquote>
<h1 id="触发器的查询、删除："><a href="#触发器的查询、删除：" class="headerlink" title="触发器的查询、删除："></a>触发器的查询、删除：</h1><ul>
<li>列出当前数据库的所有触发器：select * from pg_trigger;</li>
<li>列出某张表上的触发器：SELECT tgname FROM pg_trigger, pg_class WHERE tgrelid&#x3D;pg_class.oid AND relname&#x3D;’&lt;tablename&gt;’;</li>
<li>删除触发器：drop trigger <trigger_name>;</li>
</ul>
<h1 id="查询创建的函数："><a href="#查询创建的函数：" class="headerlink" title="查询创建的函数："></a>查询创建的函数：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	pg_proc.proname <span class="keyword">AS</span> &quot;函数名称&quot;,</span><br><span class="line">	pg_type.typname <span class="keyword">AS</span> &quot;返回值数据类型&quot;,</span><br><span class="line">	pg_proc.pronargs <span class="keyword">AS</span> &quot;参数个数&quot; </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	pg_proc </span><br><span class="line">	<span class="keyword">JOIN</span> pg_type <span class="keyword">ON</span> (pg_proc.prorettype <span class="operator">=</span> pg_type.oid) </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	pg_type.typname <span class="operator">!=</span> <span class="string">&#x27;void&#x27;</span> </span><br><span class="line">	<span class="keyword">AND</span> </span><br><span class="line">	pronamespace <span class="operator">=</span> (<span class="keyword">SELECT</span> pg_namespace.oid <span class="keyword">FROM</span> pg_namespace <span class="keyword">WHERE</span> nspname <span class="operator">=</span> <span class="string">&#x27;public&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>用于加速从数据库中检索数据</p>
<blockquote>
<p>创建索引:create index index_name on table_name;</p>
</blockquote>
<p>响应时间的计算模型：<br>响应时间&#x3D;网络传输时间（请求）+服务器处理时间（一层或是多层）+网络传输时间（响应）+页面前段解析时间</p>
]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Cython保护Python文件</title>
    <url>/190502-4/</url>
    <content><![CDATA[<h1 id="使用Cython保护Python代码库"><a href="#使用Cython保护Python代码库" class="headerlink" title="使用Cython保护Python代码库"></a>使用Cython保护Python代码库</h1><p>从语言层面来说，Cython是一种拓展的Python，其文件的扩展名为.pyx。这种类型的文件通过编译之后可以变成供Python直接调用的动态链接库（Linux&#x2F;Mac下是.so，Windows下是.pyd）。根据官方文档，主要如下几编译方式：</p>
<blockquote>
<ul>
<li>(推荐) 通过setup.py中调用Cython.Build进行编译</li>
<li>使用pyximport调用.pyx文件，这种方法.pyx文件相当于普通的.py文件</li>
<li>在命令行使用cython命令从.pyx文件生成.c文件，再使用外部编译器将.c文件编译成Python可用的库</li>
<li>使用Jupyter Notebook或者Sage Notebook直接运行Cython代码</li>
</ul>
</blockquote>
<span id="more"></span>

<p>这上面四种方法里最简单的是第三种方法。运行<code>cythonize -i &lt;.pyx File&gt;</code>即可编译.pyx成二进制库，并保存在与.pyx文件相同的目录下。cythonize命令有其他的参数，可以通过命令行查看。这个命令也可以通过<code>python -m Cython.Build.Cythonize -i &lt;.pyx File&gt;</code>来完成。</p>
<p>  在对Python 代码进行保护时，可以采用Cython对Python代码记性二进制转换，尽管可以对二进制文件进行逆向工程，但是依然会起到一定的保护作用.</p>
<h2 id="对项目包进行编译"><a href="#对项目包进行编译" class="headerlink" title="对项目包进行编译"></a>对项目包进行编译</h2><p>对以下结构的包进行编译:</p>
<p><img src="/userImages/Cython_tree.png" alt="tree"></p>
<ul>
<li>通过<code>setup.py</code>文件进行简单编译</li>
</ul>
<p>在使用该方法编译的时候，一个函数只有一个参数时，有可能会出现无法找到函数的情况，鉴于这种情况，请参考复杂编译的过程。以Cython官方实例为例：</p>
<p><code>setup.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">  name = <span class="string">&#x27;Hello world app&#x27;</span>,</span><br><span class="line">  ext_modules = cythonize(<span class="string">&quot;hello.py&quot;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>hello.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello_to</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello %s!&quot;</span> % name)</span><br></pre></td></tr></table></figure>

<p><img src="/userImages/Cython_example1.png" alt="example1"></p>
<p>运行<code>python setup.py build_ext --inplace</code>，生成<code>.so</code>文件，删除该文件夹中的<code>py文件</code>和<code>c文件</code>。<br>在终端导入使用：<br><img src="/userImages/Cython_example2.png" alt="example2"></p>
<ul>
<li>使用<code>setup.py</code>文件进行复杂编译</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> setuptools.extension <span class="keyword">import</span> Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"><span class="keyword">from</span> Cython.Distutils <span class="keyword">import</span> build_ext</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    ext_modules=cythonize(</span><br><span class="line">        [</span><br><span class="line">            Extension(<span class="string">&#x27;mypkg.*&#x27;</span>, [<span class="string">&#x27;mypkg/*.py&#x27;</span>]),</span><br><span class="line">            Extension(<span class="string">&#x27;mypkg.submypkg1.*&#x27;</span>, [<span class="string">&#x27;mypkg/submypkg1/*.py&#x27;</span>]),</span><br><span class="line">            Extension(<span class="string">&#x27;mypkg.submypkg2.*&#x27;</span>, [<span class="string">&#x27;mypkg/submypkg2/*.py&#x27;</span>]),</span><br><span class="line">            Extension(<span class="string">&#x27;mypkg2.*&#x27;</span>, [<span class="string">&#x27;mypkg2/*.py&#x27;</span>]),</span><br><span class="line">        ],</span><br><span class="line">        build_dir=<span class="string">&#x27;build&#x27;</span>,</span><br><span class="line">        compiler_directives=<span class="built_in">dict</span>(</span><br><span class="line">            always_allow_keywords=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    cmdclass = <span class="built_in">dict</span>(</span><br><span class="line">        build_ext=build_ext</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── mypkg</span><br><span class="line">│   │   ├── bar.c</span><br><span class="line">│   │   ├── foo.c</span><br><span class="line">│   │   ├── __init__.c</span><br><span class="line">│   │   ├── submypkg1</span><br><span class="line">│   │   │   ├── bar.c</span><br><span class="line">│   │   │   ├── foo.c</span><br><span class="line">│   │   │   └── __init__.c</span><br><span class="line">│   │   └── submypkg2</span><br><span class="line">│   │       ├── bar.c</span><br><span class="line">│   │       ├── foo.c</span><br><span class="line">│   │       └── __init__.c</span><br><span class="line">│   ├── mypkg2</span><br><span class="line">│   │   ├── bar.c</span><br><span class="line">│   │   ├── foo.c</span><br><span class="line">│   │   └── __init__.c</span><br><span class="line">│   └── temp.linux-x86_64-3.7</span><br><span class="line">│       └── build</span><br><span class="line">│           ├── mypkg</span><br><span class="line">│           │   ├── bar.o</span><br><span class="line">│           │   ├── foo.o</span><br><span class="line">│           │   ├── __init__.o</span><br><span class="line">│           │   ├── submypkg1</span><br><span class="line">│           │   │   ├── bar.o</span><br><span class="line">│           │   │   ├── foo.o</span><br><span class="line">│           │   │   └── __init__.o</span><br><span class="line">│           │   └── submypkg2</span><br><span class="line">│           │       ├── bar.o</span><br><span class="line">│           │       ├── foo.o</span><br><span class="line">│           │       └── __init__.o</span><br><span class="line">│           └── mypkg2</span><br><span class="line">│               ├── bar.o</span><br><span class="line">│               ├── foo.o</span><br><span class="line">│               └── __init__.o</span><br><span class="line">├── mypkg</span><br><span class="line">│   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── bar.py</span><br><span class="line">│   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── foo.py</span><br><span class="line">│   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── submypkg1</span><br><span class="line">│   │   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   ├── bar.py</span><br><span class="line">│   │   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   ├── foo.py</span><br><span class="line">│   │   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   │   └── __init__.py</span><br><span class="line">│   └── submypkg2</span><br><span class="line">│       ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── bar.py</span><br><span class="line">│       ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── foo.py</span><br><span class="line">│       ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│       └── __init__.py</span><br><span class="line">├── mypkg2</span><br><span class="line">│   ├── bar.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── bar.py</span><br><span class="line">│   ├── foo.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   ├── foo.py</span><br><span class="line">│   ├── __init__.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure>

<ul>
<li>运行文件<code>python setup.py build_ext --inplace</code></li>
<li>最终会在当前文件夹中生成build文件夹，同时在build文件夹中生成相应的文件夹和<code>.c</code>文件，在主目录对应的文件夹中生成<code>.so</code>文件，此时的<code>.so</code>文件就可以通过导入的方式直接使用。</li>
<li>如果需求有改动，需要删除相应的<code>.so文件</code>后重新生成该文件。</li>
</ul>
<hr>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul>
<li>此<code>always_allow_keywords=True</code>参数一定要添加，因为<code>always_allow_keywords</code>指令禁用具有大量参数的函数只允许使用关键字参数，如果不禁用，此处在传入一个参数时会找不到对应的函数。</li>
<li>在使用第二种方法时，一定要注意一点，在有celery task任务的文件中，无法进行编译，否则在编译过后会出现celery无法启动的情况。<ul>
<li>对上文出现的问题进行给出一个解答：<br> 在上文中，如果编译了带有task任务的文件，会出现以下错误   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AttributeError: <span class="string">&#x27;method-wrapper&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__module__&#x27;</span></span><br></pre></td></tr></table></figure>
 解决方法为：  <blockquote>
<ul>
<li>创建第三方真实执行逻辑的文件，在进行加密时，加密第三方逻辑文件，对celery调度任务的文件不进行加密。</li>
<li>见官方给出的解决方式<a href="https://github.com/celery/celery/issues/4342">Issues</a>，不过此处不建议更改celery源文件。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul>
<li><a href="https://bucharjan.cz/blog/using-cython-to-protect-a-python-codebase.html">Using Cython to protect a Python codebase</a></li>
<li><a href="https://python.freelycode.com/contribution/detail/981">对《Using Cython to protect a Python codebase》的翻译</a></li>
<li><a href="http://docs.cython.org/en/latest/">Cython Documentation</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Cython</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>Cython</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3爬虫之urllib模块</title>
    <url>/190502/</url>
    <content><![CDATA[<h3 id="Python2-中的urllib和Python3中的urlllib的区别"><a href="#Python2-中的urllib和Python3中的urlllib的区别" class="headerlink" title="Python2 中的urllib和Python3中的urlllib的区别"></a>Python2 中的urllib和Python3中的urlllib的区别</h3><p>在python 2中有urllib和urllib2两个库进行实现请求的发送，但是再python 3中官方将urllib2库合并在了urllib库中。所以在3中使用urllib库时一定要先了解其中的四个模块：</p>
<ul>
<li>request：这个模块是最基本的HTTP请求模块，用来模拟发送请求。</li>
<li>error：异常处理模块，用来捕获异常，保证程序不会意外终止。</li>
<li>parse：工具模块，提供了许多URL处理方法，如拆分、解析、编码等</li>
<li>robotparser:用来识别网站的robots.txt文件，判断哪些网站可以爬，一般不用。<br>此处只讲解前三个的用法。</li>
</ul>
<span id="more"></span>

<h3 id="请求的发送"><a href="#请求的发送" class="headerlink" title="请求的发送"></a>请求的发送</h3><p>1、urlopen()函数<br>在urllib.request模块中提供了最基本的构造HTTP请求的方法，可以利用它进行模拟浏览器发送一个请求，同时它还具有处理授权验证、重定向、浏览器cookies等其他内容<br>下面以百度为例子，进行网页的抓取：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">response = request.urlopen(&#x27;http://www.baidu.com&#x27;)</span><br><span class="line">print(response.read().decode(&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure>
<p>可以很简单的看出，上面很简单的三行代码已经实现了一个简单的爬虫了。只不过这个爬虫获取下来的内容没有经过任何数据处理，我们可以很容的看到百度首页的源代码。<br>之后，查看返回的内容是什么类型的。<br><code>print(type(response))</code><br>输出为：<code>&lt;class &#39;http.client.HTTPResponse&#39;&gt;</code><br>可以发现，它是一个HTTPResponse类型的对象，接下来查看有那些函数和属性，使用<code>dir(response)</code>：<br>输出为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;__abstractmethods__&#x27;, &#x27;__class__&#x27;, &#x27;__del__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__enter__&#x27;, &#x27;__eq__&#x27;, &#x27;__exit__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__next__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;_abc_impl&#x27;, &#x27;_checkClosed&#x27;, &#x27;_checkReadable&#x27;, &#x27;_checkSeekable&#x27;, &#x27;_checkWritable&#x27;, &#x27;_check_close&#x27;, &#x27;_close_conn&#x27;, &#x27;_get_chunk_left&#x27;, &#x27;_method&#x27;, &#x27;_peek_chunked&#x27;, &#x27;_read1_chunked&#x27;, &#x27;_read_and_discard_trailer&#x27;, &#x27;_read_next_chunk_size&#x27;, &#x27;_read_status&#x27;, &#x27;_readall_chunked&#x27;, &#x27;_readinto_chunked&#x27;, &#x27;_safe_read&#x27;, &#x27;_safe_readinto&#x27;, &#x27;begin&#x27;, &#x27;chunk_left&#x27;, &#x27;chunked&#x27;, &#x27;close&#x27;, &#x27;closed&#x27;, &#x27;code&#x27;, &#x27;debuglevel&#x27;, &#x27;detach&#x27;, &#x27;fileno&#x27;, &#x27;flush&#x27;, &#x27;fp&#x27;, &#x27;getcode&#x27;, &#x27;getheader&#x27;, &#x27;getheaders&#x27;, &#x27;geturl&#x27;, &#x27;headers&#x27;, &#x27;info&#x27;, &#x27;isatty&#x27;, &#x27;isclosed&#x27;, &#x27;length&#x27;, &#x27;msg&#x27;, &#x27;peek&#x27;, &#x27;read&#x27;, &#x27;read1&#x27;, &#x27;readable&#x27;, &#x27;readinto&#x27;, &#x27;readinto1&#x27;, &#x27;readline&#x27;, &#x27;readlines&#x27;, &#x27;reason&#x27;, &#x27;seek&#x27;, &#x27;seekable&#x27;, &#x27;status&#x27;, &#x27;tell&#x27;, &#x27;truncate&#x27;, &#x27;url&#x27;, &#x27;version&#x27;, &#x27;will_close&#x27;, &#x27;writable&#x27;, &#x27;write&#x27;, &#x27;writelines&#x27;]</span><br></pre></td></tr></table></figure>
<p>其中最主要函数为：read()、readinto()、getheader(name)、getheaders()、fileno()等方法。<br>在调用read()方法时可以返回网页内容，使用status属性可以查看返回的状态码。<br>在urlopen()方法中，最基本的是简单网页的GET请求抓取。但是如果要传入一个参数呢？下面就讲解参数的使用方法。  </p>
<ol>
<li>data参数<br>在讲解之前，首先需要说明的是data参数是可选的，如果传入了此参数，要以字节流编码格式的内容，即bytes类型，需要进行转化。此时的请求方式不再是GET方法，而是POST方法.因为如果使用GET方法，会将传入data暴露在url中，十分不安全。<br>实例一:    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">data = bytes(parse.urlencode(&#123;&#x27;word&#x27;: &#x27;hello world&#x27;&#125;), encoding=&#x27;utf8&#x27;)</span><br><span class="line">response = request.urlopen(&#x27;http://httpbin.org/post&#x27;, data=data)</span><br><span class="line">print(response.read().decode(&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure>
这里我们传入了一个参数word，值为hello world。由于发送的的data需要是字节流类型，此处使用到了上文提到的工具包函数parse，使用它将我们要传入的函数进行转码。在我们执行完这段代码后，服务器会给我们返回一下结果:    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;data&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;word&quot;: &quot;hello world&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">    &quot;Content-Length&quot;: &quot;16&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.7&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: null,</span><br><span class="line">  &quot;origin&quot;: &quot;115.60.58.52&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此时我们可以很容易的看到，在返回的结果中有form字段，字段中的内容就是我们传入的data中的内容，至此我们已经模拟了表单提交的过程，以POST请求方式尽心传输数据。  </li>
<li>timeout参数<br>顾名思义，这个参数就是用来设置超时的。单位为秒，意思是当请求超出了设置的值后还有得到响应，就讲异常抛出。如果此参数不指定时间，使用全局默认时间。<br>实例：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">response = request .urlopen(&#x27;http://httpbin.org/get&#x27;, timeout=0.1)</span><br><span class="line">print(response .read().decode(&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure>
运行结果：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test_urllib_001.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    response = request .urlopen(&#x27;http://httpbin.org/get&#x27;, timeout=0.1)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 222, in urlopen</span><br><span class="line">    return opener.open(url, data, timeout)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 525, in open</span><br><span class="line">    response = self._open(req, data)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 543, in _open</span><br><span class="line">    &#x27;_open&#x27;, req)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 503, in _call_chain</span><br><span class="line">    result = func(*args)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 1345, in http_open</span><br><span class="line">    return self.do_open(http.client.HTTPConnection, req)</span><br><span class="line">  File &quot;/home/rain/.pyenv/versions/3.7.0/lib/python3.7/urllib/request.py&quot;, line 1319, in do_open</span><br><span class="line">    raise URLError(err)</span><br><span class="line">urllib.error.URLError: &lt;urlopen error timed out&gt;</span><br></pre></td></tr></table></figure>
这里我们设置了超时的时间是0.1秒。程序再执行0.1秒以后，服务器依然没有任何响应，于是抛出了URLError异常。可以从<code>&lt;urlopen error timed out&gt;</code>看出是网络超时。那么问题来了，如何抓取这种情况呢？<br>实例：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request .urlopen(&#x27;http://httpbin.org/get&#x27;, timeout=0.1)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    if isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(&#x27;Time Out&#x27;)</span><br></pre></td></tr></table></figure>
我们用try: … except: …来捕获异常，此处引入了socket模块。</li>
</ol>
<p>2、Request<br>到此，我们知道了如何用urlopen方法实现一个简单的请求发送。但是这些简单参数有时候并不能满足我们的需求，比如我们需要在请求中添加header，此时就需要一个更加强大的类来实现了，这就是本节要讲的Request类。<br>实例是最好的验证。<br>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">req = request.Request(&#x27;https://baidu.com&#x27;)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>
<p>此处我们依然使用了上文的urlopen()方法，只是此时的参数不再是一个URL了，而是一个Request对象。另外，这个函数我们可以很灵活的配置我们需要的参数。看下它的构造方法吧：<br><code>urllib.request.Request(url, data=None, headers=&#123;&#125;,origin_req_host=None, unverifiable=False,method=None)</code><br>  解释下：</p>
<ul>
<li>url：请求的URL，必填项</li>
<li>data：字节流，请求时需要带的数据</li>
<li>header：请求头，在创建实例后可以通过add_header()添加</li>
<li>origin_req_host: 请求方的host名称或IP地址</li>
<li>unverifiable：表示请求是否无法是验证的，默认为False。意思是用户没有足够的权限来选择接收这个请求的结果。</li>
<li>method：请求是用的方法，如GET、POST等</li>
</ul>
<p>下面实现一个多参数构建请求的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">url = &#x27;http://httpbin.org/post&#x27;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    &#x27;name&#x27;: &quot;spider_road&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data= bytes(parse.urlencode(dict), encoding=&#x27;utf8&#x27;)</span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method =&#x27;POST&#x27;)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(&#x27;utf8&#x27;))</span><br></pre></td></tr></table></figure>
<p>我们通过四个参数四个参数构建了这个请求，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;data&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;spider_road&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">    &quot;Content-Length&quot;: &quot;16&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: null,</span><br><span class="line">  &quot;origin&quot;: &quot;115.60.58.52&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>在上节中，我们简单的提到了如何对异常做出处理，但是程序在运行过程总会出现一些其他的错误，当出现这些错误时，异常处理还是很有必要做的。<br>1、URLError<br>URLError类来自于urllib库的error模块，继承自OSError类，由request模块产生的异常都已使用这个类来捕捉。<br>实例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request.urlopen(&#x27;https://spider-road.com&#x27;)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure>
<p>上面的程序我们使用它打开了一个不存在的网址，我们使用try:… except:…来捕获了异常。<br>运行输出：<code>[Errno -2] Name or service not known</code>，此时有效得避免了程序异常终止。</p>
<p>2、HTTPError<br>它是URLError的子类，用来处理HTTP请求错误，比如认证请求失败等。它有一下3个属性：</p>
<ul>
<li>code： http状态码</li>
<li>reason：错误原因</li>
<li>headers： 返回请求头</li>
</ul>
<p>实例验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib import request, error</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = request.urlopen(&#x27;https://spider-road.com&#x27;)</span><br><span class="line">except error.HTTPError as e:</span><br><span class="line">    print(f&#x27;code:&#123;e.code&#125;\nreason:&#123;e.reason&#125;\nheaders:&#123;e.headers&#125;&#x27;)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure>
<p>由于没有该网站，所以最后返回的是：<code>[Errno 110] Connection timed out</code><br>至此，关于urllib请求和错误处理已经讲解完毕，后续还有关于此节更为高级的用法。欢迎订阅爬虫之道，我们在这里等待你的到来。</p>
]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>为Next加上彩色标签云</title>
    <url>/190520/</url>
    <content><![CDATA[<p>最近一直看hexo官方的标签云太难看，就google了一下。最终搜索到了这篇文章（<a href="https://me.idealli.com/post/d6caa003.html">传送门</a>），在此也做下记录吧！</p>
<span id="more"></span>


<ol>
<li><p>打开themes –&gt; next –&gt; layout –&gt; page.swig文件</p>
</li>
<li><p>找到<code>&#123; % if page.type === &#39;tags&#39; % &#125;</code></p>
</li>
<li><p>将下方代码进行替换即可</p>
</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">原内容：</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;tag-cloud-tags&quot;&gt;</span><br><span class="line">  &#123;% if not theme.tagcloud %&#125;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: &#x27;#ccc&#x27;, end_color: &#x27;#111&#x27;&#125;) &#125;&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;min_font: theme.tagcloud.min, max_font: theme.tagcloud.max, amount: theme.tagcloud.amount, color: true, start_color: theme.tagcloud.start, end_color: theme.tagcloud.end&#125;) &#125;&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">修改之后的内容：</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;tag-cloud-tags&quot; id=&quot;tags&quot;&gt;</span><br><span class="line">  &#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#x27;#fff&#x27;, end_color: &#x27;#fff&#x27;&#125;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var alltags=document.getElementById(&#x27;tags&#x27;);</span><br><span class="line">  var tags=alltags.getElementsByTagName(&#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">  for (var i = tags.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    var r=Math.floor(Math.random()*75+130);</span><br><span class="line">    var g=Math.floor(Math.random()*75+100);</span><br><span class="line">    var b=Math.floor(Math.random()*75+80);</span><br><span class="line">    tags[i].style.background = &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  div#posts.posts-expand .tag-cloud a&#123;</span><br><span class="line">    background-color: #f5f7f1;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-left: 10px;</span><br><span class="line">    padding-right: 10px;</span><br><span class="line">    margin-top: 18px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud a&#123;</span><br><span class="line">    background-color: #f5f7f1;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin-right: 5px;</span><br><span class="line">    margin-left: 0px;</span><br><span class="line">    margin-top: 8px;</span><br><span class="line">    margin-bottom: 0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud a:before&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    text-align: left;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>之后清理缓存，重新部署就行了。</p>
<p>最终效果如下：</p>
<p><img src="/userImages/tag-cloud.png" alt="彩色标签云"></p>
]]></content>
      <categories>
        <category>起始篇</category>
      </categories>
      <tags>
        <tag>标签云</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 3中的Urllib库的使用</title>
    <url>/190615/</url>
    <content><![CDATA[<p>在Python中有着这样一个常用的、基础的爬虫库。在Python2中为urllib.urllib，在Python3中官方为了便于管理，将和请求有关的函数封装进了urllib.request模块中。</p>
<p>在此处，使用Python3做记录。</p>
<span id="more"></span>

<h3 id="urlopen函数"><a href="#urlopen函数" class="headerlink" title="urlopen函数"></a>urlopen函数</h3><p>urlopen函数是request中的一个很常用的函数，它主要用于打开一个网页。其中有着很多的属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">resp = request.<span class="built_in">open</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure>



<h3 id="urlretrieve函数"><a href="#urlretrieve函数" class="headerlink" title="urlretrieve函数"></a>urlretrieve函数</h3><p>urlretrieve函数可以很方便的将网页保存至本地。其实用方法见下方代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">request.urlretrieve()</span><br></pre></td></tr></table></figure>



<h3 id="urlencode函数"><a href="#urlencode函数" class="headerlink" title="urlencode函数"></a>urlencode函数</h3><p>将字典类型的数据转化为url编码的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse, request</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">&quot;wd&quot;</span>: <span class="string">&quot;爬虫之道&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line"></span><br><span class="line">url = <span class="string">f&quot;https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">resp = request.urlopen(url)</span><br></pre></td></tr></table></figure>



<h3 id="parse-qs函数"><a href="#parse-qs函数" class="headerlink" title="parse_qs函数"></a>parse_qs函数</h3><p>将url编码后的参数还原为字典形式，其中的值以列表形式进行存储。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">ps = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;爬虫之道&quot;</span>, <span class="string">&quot;vxcode&quot;</span>: <span class="string">&quot;spider_rold&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">results = parse.urlencode(ps)</span><br><span class="line"></span><br><span class="line">new_results = parse.parse_qs(results)</span><br><span class="line"><span class="built_in">print</span>(new_results)</span><br></pre></td></tr></table></figure>

<h3 id="urlparse和urlsplit函数"><a href="#urlparse和urlsplit函数" class="headerlink" title="urlparse和urlsplit函数"></a>urlparse和urlsplit函数</h3><p>对URL各部分进行分割，其中在使用urlsplit函数时，没有_params_参数。（<em>注</em>：params参数指的是在以下链接中”?”前添加”;”，位于这两者之间的内容，如：_<a href="https://www.baidu.com/s;hello?wd=hello+world_%EF%BC%89">https://www.baidu.com/s;hello?wd=hello+world_）</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">&quot;wd&quot;</span>: <span class="string">&quot;爬虫之道&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line">url = <span class="string">f&quot;https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">result = parse.urlparse(url)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;scheme:&#x27;</span>, result.scheme)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;netloc:&#x27;</span>, result.netloc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>, result.path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;params:&#x27;</span>, result.params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;query:&#x27;</span>, result.query)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fragment:&#x27;</span>, result.fragment)</span><br></pre></td></tr></table></figure>

<h3 id="request-Request类"><a href="#request-Request类" class="headerlink" title="request.Request类"></a>request.Request类</h3><p>在爬虫中，如果想使用一些参数，如：请求头，请求数据等，需要使用到Request类。如果只是使用urlopen函数，没有办法进行添加请求头。在没有使用_User-Agent_的时候，如果服务器发现是爬虫，服务器可能会返回一条假的数据内容，或者是不返回内容。所以，将爬虫程序伪装成正常的浏览器访问是很有必要的一件事。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36&quot;</span>&#125;</span><br><span class="line">params = &#123;<span class="string">&quot;wd&quot;</span>: <span class="string">&quot;爬虫之道&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">qs = parse.urlencode(params)</span><br><span class="line">url = <span class="string">f&quot;https://www.baidu.com/s?<span class="subst">&#123;qs&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">req = request.Request(url, headers=headers)</span><br><span class="line">resp = request.urlopen(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure>

<p>注： 可以去挑战一下网络爬虫界的“珠穆朗玛峰” —– 拉勾网</p>
<h3 id="ProxyHandler处理器"><a href="#ProxyHandler处理器" class="headerlink" title="ProxyHandler处理器"></a>ProxyHandler处理器</h3><p>在爬取网站时，一般情况下网站都会做一些反爬虫机制，如封ip。如果只使用一个ip地址进行爬取，在网站封掉ip地址后，就无法获取数据了。所以，在有反爬虫机制的情况，反反爬虫机制便可以使用了。在urllib中通过使用ProxyHandler进行设置代理服务器。</p>
<p>在使用代理与未使用代理的区别：</p>
<p><img src="/userImages/proxy.jpg">  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment">### 未使用代理</span></span><br><span class="line">resp = request.urlopen(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用代理</span></span><br><span class="line">handler = request.ProxyHandler(&#123;<span class="string">&quot;https&quot;</span>: <span class="string">&quot;58.253.152.231:9999&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">req = request.Request(<span class="string">&quot;http://httpbin.org/get&quot;</span>)</span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure>

<p>常用的代理：</p>
<ul>
<li>西刺代理：<a href="https://www.xicidaili.com/">https://www.xicidaili.com</a></li>
<li>快代理: <a href="https://www.kuaidaili.com/free/">https://www.kuaidaili.com/free/</a></li>
</ul>
<h3 id="Cookie是什么"><a href="#Cookie是什么" class="headerlink" title="Cookie是什么"></a>Cookie是什么</h3><p>在网站汇总，http请求是无状态的。在第一次和服务器建立连接登录后，第二次请求服务器依旧不能知道当前请求的用户是谁。Cookie的出现就是为了解决该问题。第一次登录后，服务器会返回一些数据(cookie) 给浏览器，然后浏览器将数据保存在本地。当用户发送第二次请求时，浏览器会自动的将保存在本地的数据(cookie)一起发送给服务器。服务通过判断不同的cookie信息，进行确认用户。cookie的存储大小是有限的一般不会超过4KB，因此在设置cookie对的时候，只能存储少量数据。</p>
<h4 id="cookie的格式："><a href="#cookie的格式：" class="headerlink" title="cookie的格式："></a>cookie的格式：</h4><p>Set-Cookie: NAME&#x3D;VALUE；Expires&#x3D;DATE；Path&#x3D;PATH；Domain&#x3D;DOMAIN_NAME；SECURE</p>
<p>参数含义：</p>
<ul>
<li>NAME：Cookie的名字</li>
<li>VALUE：Cookie的值</li>
<li>Expires:  Cookie的过期时间</li>
<li>Path：Cookie作用的路径</li>
<li>Domain： Cookie作用的域名</li>
<li>SECURE：是否只在HTTP协议下起作用</li>
</ul>
<h3 id="使用cookielib库和HTTPCookieProcessor模块模拟登陆"><a href="#使用cookielib库和HTTPCookieProcessor模块模拟登陆" class="headerlink" title="使用cookielib库和HTTPCookieProcessor模块模拟登陆"></a>使用cookielib库和HTTPCookieProcessor模块模拟登陆</h3><p>在Python中使用cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器一起使用的。</p>
<ul>
<li>http.cookiejar：提供用于存储cookie的对象</li>
<li>HTTPCookieProcessor：处理cookie对象并构建handler对象</li>
</ul>
<h4 id="http-cookiejar模块"><a href="#http-cookiejar模块" class="headerlink" title="http.cookiejar模块"></a>http.cookiejar模块</h4><p>在该模块中主要有三个类，CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。其作用如下：</p>
<ul>
<li>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie，向传出的HTTP请求添加cookie对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie失效。</li>
<li>FileCookieJar (filename, delayload&#x3D;None, policy&#x3D;None)：从CookieJar派生而来，用来创建FileCookieJar实例。检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名，delayload为True是支持延迟访问文件，即只有在需要时才读取文件或将数据存储在文件中。</li>
<li>MozillaCookieJar (filename, delayload&#x3D;None, policy&#x3D;None)：从FileCookieJar派生而来，创建与Mozilla浏览器cookies.txt兼容的FileCookieJar实例。</li>
<li>LWPCookieJar (filename, delayload&#x3D;None, policy&#x3D;None)：从FileCookieJar派生而来，创建与libwww·per标准的Set-Cookies3文件格式兼容的FileCookieJar实例。</li>
</ul>
<h3 id="保存Cookie至本地"><a href="#保存Cookie至本地" class="headerlink" title="保存Cookie至本地"></a>保存Cookie至本地</h3><p>保存cookie到本地，可以使用cookiejar的save方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&#x27;cookies.txt&#x27;</span>)</span><br><span class="line">handler = request.HTTPCookieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">handlers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = request.Request(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>, headers=handlers)</span><br><span class="line"></span><br><span class="line">resp = opener.<span class="built_in">open</span>(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br><span class="line"></span><br><span class="line">cookiejar.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="加载本地cookie"><a href="#加载本地cookie" class="headerlink" title="加载本地cookie"></a>加载本地cookie</h3><p>从本地文件读取cookie信息，可以使用cookiejar中的load方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> http.cookiejar <span class="keyword">import</span> MozillaCookieJar</span><br><span class="line"></span><br><span class="line">cookiejar = MozillaCookieJar(<span class="string">&#x27;cookies.txt&#x27;</span>)</span><br><span class="line">cookiejar.load(ignore_discard=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookiejar:</span><br><span class="line">    <span class="built_in">print</span>(cookie)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>BeautifulSoup4库</title>
    <url>/190628-1/</url>
    <content><![CDATA[<p>和lxml一样，BeautifulSoup也是一个HTML&#x2F;XML的解析器，主要的功能也是解析和提取HTML&#x2F;XML数据。</p>
<p>lxml只会局部遍历，而BeautifulSoup是基于HTML DOM的，它会加载整个文档，解析整个DOM树，因此在时间和内存上也会有很大的开销，所以性能要低于lxml。</p>
<p>BeautifulSoup用来解析HTML比较简单，其API设计的非常人性化，同时BeautifulSoup也支持CSS选择器、Python标准库中的HTML解析器、lxml的XML。</p>
<span id="more"></span>

<p>安装：<code>pip install bs4</code></p>
<p>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><table>
<thead>
<tr>
<th>解析工具</th>
<th>解析速度</th>
<th>使用难度</th>
</tr>
</thead>
<tbody><tr>
<td>BeautifulSoup4</td>
<td>最慢</td>
<td>最简单</td>
</tr>
<tr>
<td>lxml</td>
<td>快</td>
<td>简单</td>
</tr>
<tr>
<td>正则</td>
<td>最快</td>
<td>最难</td>
</tr>
</tbody></table>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br></pre></td></tr></table></figure>

<p>BeautifulSoup(markup, features):在使用的时候需要指定解析器，如果未指定，BeautifulSoup使用的Python标准库中的HTML解析器，同时beautifulsoup也支持第三方的解析器如lxml。另一个可供选择的解析器是纯Python实现的html5lib，html5lib的解析方式与浏览器相同。</p>
<p>安装lxml：<code>pip install lxml</code></p>
<p>安装html5lib: <code>pip install html5lib</code></p>
<p>主要解析器的优缺点：</p>
<p><img src="/userImages/20190629_000.png" alt="解析器"></p>
<h3 id="四个常用的对象"><a href="#四个常用的对象" class="headerlink" title="四个常用的对象"></a>四个常用的对象</h3><p>BeautifulSoup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：</p>
<ol>
<li>Tag</li>
<li>NavigatableString</li>
<li>BeautifulSoup</li>
<li>Comment</li>
</ol>
<h3 id="操作讲解"><a href="#操作讲解" class="headerlink" title="操作讲解"></a>操作讲解</h3><p>以下内容以4个例子的形式进行讲解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div data-v-a6e3291a=&quot;&quot; class=&quot;correlation-degree&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-wrap recruit-margin&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;TEG15-计费产品web前端开发工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;TEG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责腾讯计费平台基础支付前端架构设计和开发工作； 参与需求评审、架构设计、编码设计和上线运维； 负责用户体验优化，包括但不限于：业务流程、前端展示、性能、安全等。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;PCG19-腾讯视频媒资后台开发工程师&lt;/h4&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;PCG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;北京,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;腾讯视频&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责腾讯视频媒资中台开发工作。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;TEG15-计费系统前端测试工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;TEG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责web端/后台系统测试工作，从整个项目角度规划测试方法，达成项目质量目标； 负责web端/后台系统的自动化测试、性能测试，稳定性以及其它专项测试； 负责研究web端/后台系统测试技术，跟进业界测试技术发展，引进先进测试方法并开展二次开发，建立团队质量体系建设，有效提升测试效率&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;32032-资深后台开发工程师（上海）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;IEG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;上海,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;游戏服务器的功能开发和现有系统的持续优化； 负责服务器压力测试和性能优化； 负责服务器外网运营的持续跟进和优化。 &lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;WXG03-搜索自然语言算法工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;WXG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;广州,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责包括新词发现、命名实体识别、查询理解、意图提取、知识图谱、搜索喜好偏向性等相关系统的建设，用以优化微信小程序搜索各产品方向的流量分发，并参与工程实践。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;WXG03-搜索检索算法工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;WXG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;广州,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责微信小程序搜索各个产品方向的检索工作，内容包括页面识别、页面核心数据提取、页面分类、页面评分、词权重、排序等相关工作，并与开发工程师配合进行工程实践。 &lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;23486-证券业务C++后台开发高级工程师（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;CDG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责证券交易、风控、清算等系统的开发维护，建设证券业务相关的技术基础平台。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;22989-腾讯云数据平台产品中心运营开发&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;CSIG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责腾讯云数据平台产品的设计和研发。 负责云产品数据管理和服务的设计和研发。 负责构建和完善云底层数据的存储和查询，优化数据的质量和监控能力。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;18428-证券业务测试工程师&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;CDG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;北京,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;财付通&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责证券类产品的功能、性能、安全、自动化等测试工作，包括终端/H5及后台系统的测试。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a data-v-a6e3291a=&quot;&quot; class=&quot;recruit-list-link&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;h4 data-v-a6e3291a=&quot;&quot; class=&quot;recruit-title&quot;&gt;30360-后台平台开发（深圳）&lt;/h4&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-tips&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;PCG&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;深圳总部,中国&lt;/span&gt; | </span></span><br><span class="line"><span class="string">          &lt;span data-v-a6e3291a=&quot;&quot;&gt;技术&lt;/span&gt; | &lt;span data-v-a6e3291a=&quot;&quot;&gt;2019年06月28日&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt; </span></span><br><span class="line"><span class="string">        &lt;p data-v-a6e3291a=&quot;&quot; class=&quot;recruit-text&quot;&gt;负责QQ平台海量用户和数据的基础后台研发工作； 负责AI基础架构系统后台研发工作； 负责推荐系统，大数据分析计算后台研发工作。&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/a&gt; </span></span><br><span class="line"><span class="string">      &lt;div data-v-a6e3291a=&quot;&quot; class=&quot;recruit-collection&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;icon-collection&quot;&gt;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;span data-v-a6e3291a=&quot;&quot; class=&quot;collection-text&quot;&gt;收藏&lt;/span&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>获取所有的class属性为“recruit-list”的div标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">divs = soup.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;recruit-list&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    <span class="built_in">print</span>(div)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取第二个class属性为“recruit-list”的div标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">div = soup.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;recruit-list&quot;</span>&#125;, limit=<span class="number">2</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(div)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的h4标签中的class属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h4_texts = soup.find_all(<span class="string">&#x27;h4&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> h4_text <span class="keyword">in</span> h4_texts:</span><br><span class="line">    <span class="built_in">print</span>(h4_text[<span class="string">&#x27;class&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的职位信息（纯文本）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aEs = soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>方法一</p>
<p>输出的字符串中可能包含了很多空格或空行,使用 <code>.stripped_strings</code> 可以去除多余空白内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    infos = <span class="built_in">list</span>(aE.stripped_strings)</span><br><span class="line">    <span class="built_in">print</span>(infos)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">job = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    h4 = aE.find(<span class="string">&#x27;h4&#x27;</span>).string</span><br><span class="line">    ps = aE.find_all(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">    spans = ps[<span class="number">0</span>].find_all(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">    span = <span class="string">&#x27;|&#x27;</span>.join([s.string <span class="keyword">for</span> s <span class="keyword">in</span> spans])</span><br><span class="line">    p2 = ps[<span class="number">1</span>].string</span><br><span class="line">    job[<span class="string">&#x27;title&#x27;</span>] = h4</span><br><span class="line">    job[<span class="string">&#x27;info&#x27;</span>] = span</span><br><span class="line">    job[<span class="string">&#x27;desc&#x27;</span>] = p2</span><br><span class="line">    <span class="built_in">print</span>(job)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法三</p>
<p>该方法提取出的内容中包含换行、空格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> aE <span class="keyword">in</span> aEs:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(aE.strings))</span><br></pre></td></tr></table></figure></li>
</ol>
<p>_注意_：</p>
<p>strings和stripped_strings、string属性和get_text方法：</p>
<ol>
<li>string：获取某个标签下的非标签字符串。返回值为字符串。</li>
<li>strings：获取某个标签下的所有非标签字符串，返回结果为一个生成器。</li>
<li>stripped_strings：获取某个标签下的所有非空行、非换行的非标签字符串，返回结果为一个生成器。</li>
<li>get_text：获取某个标签下的所有非标签字符串，返回结果为字符串。</li>
</ol>
</li>
</ul>
<h3 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h3><h4 id="find和find-all方法"><a href="#find和find-all方法" class="headerlink" title="find和find_all方法"></a>find和find_all方法</h4><p>搜索文档树，一般采用较多的是这两个方法，一个是find，另一个是find_all方法。find方法是在文档树中找到第一个满足条件的标签后就返回结果。find_all方法是在文档树中找到所有满足条件的标签后返回结果。在这两个方法中最常用的用法是name和attr参数，其中也可以直接传入关键字，在传入关键字”class”时，需要将”class”变为”class_”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="select方法"><a href="#select方法" class="headerlink" title="select方法"></a>select方法</h4><p>在使用css选择器的方式时，需要使用select方法。以下为几种常用的css选择器方法：</p>
<ol>
<li><p>通过标签名查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过类名查找</p>
<p>通过类名，应该在前面加一个”.”,比如要查找class&#x3D;sister的标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;.sister&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过id查找</p>
<p>通过id查找，应该在id的名字前面加一个”#”号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;#link1&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过组合查找</p>
<p>组合查找时，标签名和类名、id名进行组合的方式进行查找，例如查找p标签中，id等于link1的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;p #link1&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>直接子标签查找，则用”&gt;”分隔</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;head &gt; title&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过属性查找</p>
<p>查找时还可以加入属性元素，属性元素需要使用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取内容</p>
<p>以上的select方法返回的结果都是以列表的形式返回的，可以进行遍历输出，然后使用get_text()方法获取其他的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.select(<span class="string">&#x27;title&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;title&#x27;</span>)[<span class="number">0</span>].get_text())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> soup.select(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(title.get_text())</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>bs4</tag>
      </tags>
  </entry>
  <entry>
    <title>XPath语法详解</title>
    <url>/190628/</url>
    <content><![CDATA[<h3 id="Xpath语法和lxml模块"><a href="#Xpath语法和lxml模块" class="headerlink" title="Xpath语法和lxml模块"></a>Xpath语法和lxml模块</h3><h4 id="什么是XPath？"><a href="#什么是XPath？" class="headerlink" title="什么是XPath？"></a>什么是XPath？</h4><p>xpath (XML Path Language)是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。</p>
<span id="more"></span>

<h4 id="XPath开发工具"><a href="#XPath开发工具" class="headerlink" title="XPath开发工具"></a>XPath开发工具</h4><ol>
<li>Chrom插件XPath Helper</li>
<li>FireFox插件XPath Checker</li>
</ol>
<h4 id="XPath语法"><a href="#XPath语法" class="headerlink" title="XPath语法"></a>XPath语法</h4><h5 id="选取节点："><a href="#选取节点：" class="headerlink" title="选取节点："></a>选取节点：</h5><p>Xpath使用路径表达式选取XML文档中的节点或 节点集。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>nodename</td>
<td>选取此节点的所有结点</td>
<td>bookstore</td>
<td>选取bookstore下所有的节点</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>如果是在最前面，代表从根节点选取。否者选取某节点下的某个节点</td>
<td>&#x2F;bookstore</td>
<td>选取根元素下所有的bookstore节点</td>
</tr>
<tr>
<td>&#x2F;&#x2F;</td>
<td>从全局节点中选择节点</td>
<td>&#x2F;&#x2F;book</td>
<td>选取所有的bookstore节点</td>
</tr>
<tr>
<td>@</td>
<td>选取某个节点的属性</td>
<td>&#x2F;&#x2F;book[@id]</td>
<td>选取所有拥有id属性的book节点</td>
</tr>
</tbody></table>
<h5 id="谓语："><a href="#谓语：" class="headerlink" title="谓语："></a>谓语：</h5><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;bookstore&#x2F;book[1]</td>
<td>选取bookstore下的第一个book元素</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[last()]</td>
<td>选取bookstore下的倒数第二个book元素</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[position() &lt; 3]</td>
<td>选取bookstore下前两个book元素</td>
</tr>
<tr>
<td>&#x2F;&#x2F;book[@id]</td>
<td>选取拥有id属性的所有book元素</td>
</tr>
<tr>
<td>&#x2F;&#x2F;book[@id&#x3D;10]</td>
<td>选取所有id&#x3D;10的所有book元素</td>
</tr>
</tbody></table>
<h5 id="通配符："><a href="#通配符：" class="headerlink" title="通配符："></a>通配符：</h5><p><code>*</code> 表示通配符</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意节点</td>
<td>&#x2F;bookstore&#x2F;*</td>
<td>选取bookstore下所有的子元素</td>
</tr>
<tr>
<td>@*</td>
<td>匹配节点中的任何属性</td>
<td>&#x2F;&#x2F;book[@*]</td>
<td>选取所有带有属性的book元素</td>
</tr>
</tbody></table>
<h5 id="选取多个路径："><a href="#选取多个路径：" class="headerlink" title="选取多个路径："></a>选取多个路径：</h5><p>通过在路径表达式中使用“|”运算符，可以选取若干路径。</p>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//bookstore/book | //book/title</span><br><span class="line">### 选取所有book元素以及book元素下所有的title元素</span><br></pre></td></tr></table></figure>

<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>&#124;</td>
<td>计算两个节点集</td>
<td>&#x2F;&#x2F;book &#124; &#x2F;&#x2F;cd</td>
<td>返回所有拥有book 和cd元素的节点集</td>
</tr>
<tr>
<td>+</td>
<td>加法</td>
<td>6+4</td>
<td>10</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>6-4</td>
<td>2</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>6*4</td>
<td>24</td>
</tr>
<tr>
<td>div</td>
<td>除法</td>
<td>8 div 4</td>
<td>2</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>等于</td>
<td>id&#x3D;101</td>
<td>如果id&#x3D;101，则返回True，否则返回False</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>id !&#x3D; 101</td>
<td>如果id !&#x3D; 101，则返回True，否则返回False</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>id &lt; 101</td>
<td>如果id &gt; 101，则返回True，否则返回False</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于或等于</td>
<td>id &lt;&#x3D; 101</td>
<td>如果id &lt;&#x3D; 101，则返回True，否则返回False</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>id &gt; 101</td>
<td>如果id &gt; 101，则返回True，否则返回False</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于或等于</td>
<td>id &gt;&#x3D; 101</td>
<td>如果id &gt;&#x3D; 101，则返回True，否则返回False</td>
</tr>
<tr>
<td>or</td>
<td>或</td>
<td>id &#x3D;100 or id &#x3D; 101</td>
<td>如果id &#x3D; 100 或id&#x3D;101，返回True， 否则返回False</td>
</tr>
<tr>
<td>and</td>
<td>与</td>
<td>id &gt; 100 and id &lt; 150</td>
<td>如果100 &lt; id &lt; 101,返回True，否则返回False</td>
</tr>
<tr>
<td>mod</td>
<td>计算除法的余数</td>
<td>5 mod 2</td>
<td>1</td>
</tr>
</tbody></table>
<p><em>注意:</em></p>
<ol>
<li><p>&#x2F;和&#x2F;&#x2F;的区别：&#x2F;代表只获取直接子节点， &#x2F;&#x2F;代表获取子孙节点。</p>
</li>
<li><p>contains：有时某个属性中包含多个值，可以使用模糊匹配的方式获取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//div[contaions(@class, &#x27;job_detail&#x27;)]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h3><p>lxml是一个HTML&#x2F;XML的解析器，主要的功能是如何解析和提取HTML&#x2F;XML数据。</p>
<p>lxml和正则一样，也是C实现的，是一款高性能的Python HTML&#x2F;XML解析器，它可以用来快速的定位特定元素以及节点信息。</p>
<p>安装：<code>pip install lxml</code></p>
<h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><p>在用lxml解析HTML代码的时候，如果HTML代码不规范，lxml库会自动的将其补全。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用lxml的etree库</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link0.html&quot;&gt;First item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;Second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;Third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;Fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;Fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_result</span>(<span class="params">html</span>):</span><br><span class="line">    result = etree.tostring(html, encoding=<span class="string">&#x27;utf-8&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    </span><br><span class="line">print_result(html)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link0.html&quot;</span>&gt;</span>First item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>Second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>Third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span>Fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>Fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在解析html文件时，如果使用的<code>lxml.etree.parse</code>解析。该函数默认使用的解析器是<code>XML</code>解析器，所以，如果html文件中缺少相应标签，解析就会出错，此时可以自行创建解析器。</p>
<h4 id="lxml的使用"><a href="#lxml的使用" class="headerlink" title="lxml的使用"></a>lxml的使用</h4><p>以上文的text为例：</p>
<ul>
<li><p>获取ul标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">uls = html.xpath(<span class="string">&#x27;//ul&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> ut <span class="keyword">in</span> uls:</span><br><span class="line">    print_result(ut)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取&lt;li class&#x3D;”item-1”&gt;标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li_items_1 = html.xpath(<span class="string">&quot;//li[@class=&#x27;item-1&#x27;]&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li_item_1 <span class="keyword">in</span> li_items_1:</span><br><span class="line">    print_result(li_item_1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有&lt;li class&#x3D;”item-1”&gt;中a标签中的链接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li_items_1_as_href = html.xpath(<span class="string">&quot;//li[@class=&#x27;item-1&#x27;]/a/@href&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li_items_1_a_href <span class="keyword">in</span> li_items_1_as_href:</span><br><span class="line">    <span class="built_in">print</span>(li_items_1_a_href)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有a标签中的文字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">as_text = html.xpath(<span class="string">&quot;//a/text()&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> a_text <span class="keyword">in</span> as_text:</span><br><span class="line">    <span class="built_in">print</span>(a_text)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程爬虫</title>
    <url>/190630/</url>
    <content><![CDATA[<h3 id="多线程介绍"><a href="#多线程介绍" class="headerlink" title="多线程介绍"></a>多线程介绍</h3><p>多线程时为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。就好比多线程是火车的每一节车厢，而进程就是火车，车厢离开火车无法启动。多线程的出现是为了提高效率。</p>
<span id="more"></span>

<h3 id="threading模块介绍"><a href="#threading模块介绍" class="headerlink" title="threading模块介绍"></a>threading模块介绍</h3><p>threading模块是python中专门提供用来多线程编程的模块。threading模块中最常用的类是Thread。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coding</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> 正在写代码&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawing</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> 正在画图&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi_thread</span>():</span><br><span class="line">    t1 = threading.Thread(target=coding)</span><br><span class="line">    t2 = threading.Thread(target=drawing)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multi_thread()</span><br></pre></td></tr></table></figure>

<h4 id="查看线程数"><a href="#查看线程数" class="headerlink" title="查看线程数"></a>查看线程数</h4><p>使用threading.enumerate()函数可以看到当前线程的数量</p>
<h4 id="查看当前线程的名字"><a href="#查看当前线程的名字" class="headerlink" title="查看当前线程的名字"></a>查看当前线程的名字</h4><p>使用threading.current_thread()函数可以看到当前线程的信息。</p>
<h4 id="继承自threading-Thread类"><a href="#继承自threading-Thread类" class="headerlink" title="继承自threading.Thread类"></a>继承自threading.Thread类</h4><p>为了让线程代码得到更好的封装，可以使用到threading模块下的Thread类，继承自Thread类后，然后实现run方法，线程代码会自动运行run方法中的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodingThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread()&#125;</span> 正在写代码&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread()&#125;</span> 正在画图&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi_thread</span>():</span><br><span class="line">    t1 = CodingThread()</span><br><span class="line">    t2 = DrawingThread()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multi_thread()</span><br></pre></td></tr></table></figure>

<h4 id="多线程共享全局变量的问题"><a href="#多线程共享全局变量的问题" class="headerlink" title="多线程共享全局变量的问题"></a>多线程共享全局变量的问题</h4><p>多线程都是在同一个进程中运行的，因此在进程中的全局变量多有线程都是可共享的。由于线程执行的顺序是无序的，线程如果同时执行，有可能会造成数据错误。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">tickets = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ticket</span>():</span><br><span class="line">    <span class="keyword">global</span> tickets</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        tickets += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;tickets: <span class="subst">&#123;tickets&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=get_ticket)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>为了解决以上使用共享全局变量的问题，threading提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时无法使用，直到当前线程处理完成后，把锁释放，其他线程才能使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">tickets = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ticket</span>():</span><br><span class="line">    <span class="keyword">global</span> tickets</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        tickets += <span class="number">1</span></span><br><span class="line">    lock.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;tickets: <span class="subst">&#123;tickets&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=get_ticket)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>_注意_：lock锁加在修改全局变量的位置，如果只是访问全局变脸没有必要加锁。</p>
<h4 id="Lock生产者和消费者模式"><a href="#Lock生产者和消费者模式" class="headerlink" title="Lock生产者和消费者模式"></a>Lock生产者和消费者模式</h4><p>生产者和消费者模式是多线程开发中经常看到的一种模式。生产者的线程专门用来生产一些数据，然后存放在一个中间变量中。消费者再从这个中间变量中取出数据进行消费。但是因为要使用中间变量，中间变量由于经常是些全局变量，因此在使用的时候需要使用Lock锁来保证数据完整性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gMoney = <span class="number">1000</span></span><br><span class="line">gLock = threading.Lock()</span><br><span class="line"><span class="comment"># 记录生产者生产次数，在达到10次时停止生产</span></span><br><span class="line">gTimes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">            gLock.acquire()</span><br><span class="line">            <span class="keyword">if</span> gTimes &gt;= <span class="number">10</span>:</span><br><span class="line">                gLock.release()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            gMoney += money</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 当前存入 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元&quot;</span>)</span><br><span class="line">            gTimes += <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gLock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">500</span>)</span><br><span class="line">            gLock.acquire()</span><br><span class="line">            <span class="keyword">if</span> gMoney &gt; money:</span><br><span class="line">                gMoney -= money</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元&quot;</span>)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> gMoney &gt;= <span class="number">10</span>:</span><br><span class="line">                    gLock.release()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 想取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元，不足！&quot;</span>)</span><br><span class="line">            gLock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Consumer(name=<span class="string">f&quot;消费者线程<span class="subst">&#123;x&#125;</span>&quot;</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Producer(name=<span class="string">f&quot;生产者线程<span class="subst">&#123;x&#125;</span>&quot;</span>).start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="Condition生产者和消费者模式"><a href="#Condition生产者和消费者模式" class="headerlink" title="Condition生产者和消费者模式"></a>Condition生产者和消费者模式</h4><p>Lock中的生产者与消费者模式可以正常运行，但是存在一个问题，在消费者中，总是通过while死循环上锁的方式判断money的多少。由于上锁是一个很消耗CPU资源的行为，因此此方式不是最好的。还有一种更好的方式是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作，还可以提升程序的性能。threading.Condition类似threading.Lock，可以在修改全局数据的时候进行加锁，也可以在修改完毕后解锁。以下对部分常用函数进行简单介绍：</p>
<ol>
<li>acquire：上锁</li>
<li>release：解锁</li>
<li>wait：将当前线程处于等待状态，并且释放锁。可以被其他线程使用notify和notify_all函数进行唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。</li>
<li>notify：通知某个正在等待的线程，默认是第一个等待的线程。</li>
<li>notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gMoney = <span class="number">1000</span></span><br><span class="line">gCondition = threading.Condition()</span><br><span class="line"><span class="comment"># 记录生产者生产次数，在达到10次时停止生产</span></span><br><span class="line">gTimes = <span class="number">0</span></span><br><span class="line">gTotalTimes = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gCondition</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">            gCondition.acquire()</span><br><span class="line">            <span class="keyword">if</span> gTimes &gt;= gTotalTimes:</span><br><span class="line">                gCondition.release()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;当前生产者总共生产了<span class="subst">&#123;gTimes&#125;</span>次&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            gMoney += money</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 当前存入 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元&quot;</span>)</span><br><span class="line">            gTimes += <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gCondition.notify_all()</span><br><span class="line">            gCondition.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> gMoney</span><br><span class="line">        <span class="keyword">global</span> gCondition</span><br><span class="line">        <span class="keyword">global</span> gTimes</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            money = random.randint(<span class="number">100</span>, <span class="number">500</span>)</span><br><span class="line">            gCondition.acquire()</span><br><span class="line">            <span class="keyword">while</span> gMoney &lt; money:</span><br><span class="line">                <span class="keyword">if</span> gTimes &gt;= gTotalTimes:</span><br><span class="line">                    gCondition.release()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 想取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元，不足！&quot;</span>)</span><br><span class="line">                gCondition.wait()</span><br><span class="line"></span><br><span class="line">            gMoney -= money</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;threading.current_thread()&#125;</span> 取出 <span class="subst">&#123;money&#125;</span> 元，剩余 <span class="subst">&#123;gMoney&#125;</span> 元&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            gCondition.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Consumer(name=<span class="string">f&quot;消费者线程<span class="subst">&#123;x&#125;</span>&quot;</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Producer(name=<span class="string">f&quot;生产者线程<span class="subst">&#123;x&#125;</span>&quot;</span>).start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="Queue线程安全队列"><a href="#Queue线程安全队列" class="headerlink" title="Queue线程安全队列"></a>Queue线程安全队列</h3><p>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你想把一些数据存储到某个队列中，可以使用Python内置的Queue模块。Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO(先进先出)队列、LIFO(后进先出)队列。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列实现线程间的同步。相关函数：</p>
<ol>
<li>初始化Queue(maxsize)：创建一个先进先出的队列</li>
<li>qsize()：返回队列的大小</li>
<li>empty()：判断队列是否为空</li>
<li>full()：判断队列是否满了</li>
<li>get()：从队列中取最后一个数据</li>
<li>put()：将一个数据放到队列中</li>
</ol>
<h4 id="使用生产者消费者模式多线程下载表情包"><a href="#使用生产者消费者模式多线程下载表情包" class="headerlink" title="使用生产者消费者模式多线程下载表情包"></a>使用生产者消费者模式多线程下载表情包</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(threading.Thread):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, page_queue, img_queue, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Producer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.img_queue = img_queue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.page_queue.empty():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            url = self.page_queue.get()</span><br><span class="line">            self.parse_page(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_page</span>(<span class="params">self, url</span>):</span><br><span class="line">        response = requests.get(url, headers=self.headers)</span><br><span class="line">        text = response.text</span><br><span class="line">        html = etree.HTML(text)</span><br><span class="line">        imgs = html.xpath(<span class="string">&#x27;//a[@class=&quot;col-xs-6 col-sm-3&quot;]/img&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> img <span class="keyword">in</span> imgs:</span><br><span class="line">            <span class="keyword">if</span> img.get(<span class="string">&#x27;class&#x27;</span>) == <span class="string">&#x27;gif&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            img_url = img.get(<span class="string">&#x27;data-original&#x27;</span>)</span><br><span class="line">            suffix = os.path.splitext(img_url)[<span class="number">1</span>].replace(<span class="string">&#x27;.null&#x27;</span>, <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">            alt = img.get(<span class="string">&#x27;alt&#x27;</span>)</span><br><span class="line">            alt = re.sub(<span class="string">r&#x27;[，。？！!?,/\\.]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, alt)</span><br><span class="line">            img_name = alt + suffix</span><br><span class="line">            self.img_queue.put((img_url, img_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(threading.Thread):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, page_queue, img_queue, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Consumer, self).__init__(*args, **kwargs)</span><br><span class="line">        self.page_queue = page_queue</span><br><span class="line">        self.img_queue = img_queue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.img_queue.empty():</span><br><span class="line">                <span class="keyword">if</span> self.page_queue.empty():</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            img = self.img_queue.get(block=<span class="literal">True</span>)</span><br><span class="line">            url, filename = img</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;images&#x27;</span>):</span><br><span class="line">                os.makedirs(<span class="string">&#x27;images/&#x27;</span>)</span><br><span class="line">            result = util.retrieve(url, headers=self.headers, path=<span class="string">&#x27;images/&#x27;</span>+filename)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;filename&#125;</span> 下载完成!&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;filename&#125;</span> 下载失败！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    page_queue = Queue(<span class="number">100</span>)</span><br><span class="line">    img_queue = Queue(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        url = <span class="string">f&#x27;http://www.doutula.com/photo/list/?page=<span class="subst">&#123;x&#125;</span>&#x27;</span></span><br><span class="line">        page_queue.put(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = Producer(page_queue, img_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = Consumer(page_queue, img_queue)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># util.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse, request</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retrieve</span>(<span class="params">url, headers=<span class="literal">None</span>, path=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(headers, <span class="built_in">dict</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    opener = request.build_opener()</span><br><span class="line">    opener.addheaders = [result <span class="keyword">for</span> result <span class="keyword">in</span> <span class="built_in">zip</span>(headers.keys(), headers.values())]</span><br><span class="line">    request.install_opener(opener)</span><br><span class="line">    request.urlretrieve(url, path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">urlopen</span>(<span class="params">url, headers=<span class="literal">None</span>, data=<span class="literal">None</span>,origin_req_host=<span class="literal">None</span>, unverifiable=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 method=<span class="literal">None</span></span>):</span><br><span class="line">    req = request.Request(url, headers=headers, data=data, origin_req_host=origin_req_host,</span><br><span class="line">                          unverifiable=unverifiable, method=method)</span><br><span class="line">    resp = request.urlopen(req)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>

<h3 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h3><p>Python自带的解释器是CPython。CPython解释器的多线程实际上是一个伪多线程（在多核CPU中，只能利用一核，无法利用多核的优势）。同一时刻只有一个线程执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中便引入了GIL（Global Intepreter Lock），叫做全局解释器锁。因为在CPython解释器的内存管理不是线程安全的，所以还有其他的解释器。</p>
<ul>
<li><p>Ipython</p>
<p>Ipython是基于CPython之上一个交互解释器，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p>
</li>
<li><p>PyPy</p>
<p>PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。在PyPy中，同样也是存在GIL锁的。</p>
</li>
<li><p>Jython</p>
<p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。不存在GIL锁。</p>
</li>
<li><p>IronPython</p>
<p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。不存在GIL锁。</p>
</li>
</ul>
<p>GIL虽然是一个假的多线程，但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title>一次完整的HTTP请求过程</title>
    <url>/190724/</url>
    <content><![CDATA[<h3 id="一次完整的HTTP请求过程"><a href="#一次完整的HTTP请求过程" class="headerlink" title="一次完整的HTTP请求过程"></a>一次完整的HTTP请求过程</h3><p>搬运来的，直接上链接吧：</p>
<p>链接：<a href="https://www.cnblogs.com/xuzekun/p/7527736.html">飞机起飞</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP请求过程</tag>
      </tags>
  </entry>
  <entry>
    <title>动态网页数据抓取</title>
    <url>/190703/</url>
    <content><![CDATA[<h2 id="动态页面数据抓取"><a href="#动态页面数据抓取" class="headerlink" title="动态页面数据抓取"></a>动态页面数据抓取</h2><h3 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a>什么是AJAX</h3><p>AJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。在后台与服务器进行少量数据换时，可以在不重新加载整个网页的情况下，利用Ajax对网页实现异步更新。在传统的网页中，如果要获取更新内容，需要重新加载整个页面。因为传统的网页数据传输格式使用的是XML语法。在Ajax加载的网页中，数据的交互使用的是JSON格式。</p>
<span id="more"></span>

<h3 id="获取ajax数据的格式"><a href="#获取ajax数据的格式" class="headerlink" title="获取ajax数据的格式"></a>获取ajax数据的格式</h3><ol>
<li>直接分析ajax调用的接口，然后通过代码请求接口。</li>
<li>使用selenium+chromedriver模拟浏览器的行为获取数据。</li>
</ol>
<table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分析接口</td>
<td>直接可以请求到数据，不需要做一些解析工具，代码量少，性能高。</td>
<td>分析接口比较复杂，特别是一些通过js混淆的接口，需要有js的功底。容易被发现是爬虫。</td>
</tr>
<tr>
<td>selenium</td>
<td>直接模拟浏览器的行为，浏览器能请求到的，使用selenium也同样可以获取。爬虫更稳定。</td>
<td>代码量多，性能低。</td>
</tr>
</tbody></table>
<h3 id="selenium-chromdriver获取动态数据"><a href="#selenium-chromdriver获取动态数据" class="headerlink" title="selenium + chromdriver获取动态数据"></a>selenium + chromdriver获取动态数据</h3><p>Selenium是一个自动化测试工具，可以在模拟人类在浏览器上的行为，自动处理浏览器上的一些行为，如点击，填充数据，删除cookie等。chromedriver是一个chrome浏览器的驱动程序。</p>
<p>Chromedriver：<a href="http://npm.taobao.org/mirrors/chromedriver">http://npm.taobao.org/mirrors/chromedriver</a></p>
<h3 id="安装Selenium和chromedriver"><a href="#安装Selenium和chromedriver" class="headerlink" title="安装Selenium和chromedriver"></a>安装Selenium和chromedriver</h3><ol>
<li>安装selenium：<code>pip install selenium</code></li>
<li>安装chromedriver：下载完毕后，放到自己能找到的英文目录中即可。</li>
</ol>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>以一个例子快速开始</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver_path = <span class="string">&#x27;./driver/chromedriver.exe&#x27;</span></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line"></span><br><span class="line">driver.get(url)</span><br><span class="line"><span class="built_in">print</span>(driver.page_source)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<p>在运行之后会出现一个浏览器框，并自动的访问百度</p>
<h3 id="selenium官方文档"><a href="#selenium官方文档" class="headerlink" title="selenium官方文档"></a>selenium官方文档</h3><p><a href="https://selenium-python.readthedocs.io/index.html">https://selenium-python.readthedocs.io/index.html</a></p>
<h3 id="关闭页面"><a href="#关闭页面" class="headerlink" title="关闭页面"></a>关闭页面</h3><ol>
<li>driver.close()：关闭当前页面</li>
<li>driver.quit()：退出整个浏览器</li>
</ol>
<h3 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h3><ol>
<li><p><code>find_element_by_id</code>：根据id查找某个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.ID, <span class="string">&#x27;su&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find_element_by_class_name</code>：根据类名查找元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_class_name(<span class="string">&#x27;s_ipt&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.CLASS, <span class="string">&#x27;s_ipt&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find_element_by_name</code>：根据name属性的值来查找元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_name(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.NAME,<span class="string">&#x27;email&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find_element_by_tag_name</code>：根据标签名来查找元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_tag_name(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.TAG_NAME,<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find_element_by_xpath</code>：根据xpath语法来获取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_xpath(<span class="string">&#x27;//div&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.XPATH,<span class="string">&#x27;//div&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find_element_by_css_selector</code>：根据css选择器选择元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_css_selector(<span class="string">&#x27;//div&#x27;</span>)</span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line">submitTag = driver.find_element(By.CSS_SELECTOR,<span class="string">&#x27;//div&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>By</code>模块导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>注意</em>：<code>find_element</code>是获取第一个满足条件的元素。<code>find_elements</code>是获取所有满足条件的元素</p>
<h3 id="操作表单元素"><a href="#操作表单元素" class="headerlink" title="操作表单元素"></a>操作表单元素</h3><ol>
<li><p>在操作输入框时需要分为两步，一：找到表单元素，二：填充数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputTag = driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">inputTag.send_keys(<span class="string">&quot;Python&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用clear方法可以清除输入框中的内容</p>
<p><code>inputTag.clear()</code></p>
</li>
<li><p>操作checkbox时，需要先选中checkbox标签，然后执行click事件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rememberTag = driver.find_element_by_name(<span class="string">&quot;rememberMe&quot;</span>)</span><br><span class="line">rememberTag.click()</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择select时，不能直接点击，因为点击后还需要选中元素。因此在selenium中专门为select标签设置了一个类<code>selenium.webdriver.support.ui.Select</code>。将获取到的元素当成参数传到这个类中，创建这个对象，之后就可以使用这个对象进行选择了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line"><span class="comment">### 选中标签创建对象</span></span><br><span class="line">selectTag = Select(driver.find_element_by_name(<span class="string">&quot;jumpMenu&quot;</span>))</span><br><span class="line"><span class="comment">### 根据索引选择</span></span><br><span class="line">selectTag.select_by_index(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 根据值选择</span></span><br><span class="line">selectTag.select_by_value(<span class="string">&quot;https://www.python.org&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 根据可视化文本选择</span></span><br><span class="line">selectTag.select_by_visible_text(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 取消选中的所有选项</span></span><br><span class="line">selectTag.deselect_all()</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作按钮：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputTag = driver.find_element_by_id(<span class="string">&quot;su&quot;</span>)</span><br><span class="line">inputTag.click()</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="行为链"><a href="#行为链" class="headerlink" title="行为链"></a>行为链</h3><p>有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类<code>ActionChains</code>来完成。如将鼠标移到某个元素并执行点击事件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputTag = driver.find_element(By.ID, <span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">submitTag = driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"></span><br><span class="line">actions = webdriver.ActionChains(driver)</span><br><span class="line">actions.move_to_element(inputTag)</span><br><span class="line">actions.send_keys_to_element(inputTag, <span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line">actions.move_to_element(submitTag)</span><br><span class="line">actions.click(submitTag)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure>

<p>更多鼠标相关操作</p>
<ul>
<li>click_and_hold(element)：点击但不松开鼠标</li>
<li>context_click(element)：右键点击</li>
<li>double_click(element)：双击</li>
</ul>
<p>更多方法：<a href="https://selenium-python.readthedocs.io/api.html">https://selenium-python.readthedocs.io/api.html</a></p>
<h3 id="Cookie操作"><a href="#Cookie操作" class="headerlink" title="Cookie操作"></a>Cookie操作</h3><ol>
<li><p>获取所有的cookie</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> driver.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(cookie)</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据cookie的key获取value</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = driver.get_cookie(key)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除所有的cookie</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_all_cookies()</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除某个cookie</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_cookie(key)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="页面等待"><a href="#页面等待" class="headerlink" title="页面等待"></a>页面等待</h3><p>现在的网页多采用 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，在使用了WebElement时，就会抛出NullPointer的异常。为了解决这个问题。所以 Selenium 提供了两种等待方式：一种是隐式等待、一种是显式等待。</p>
<ul>
<li><p>隐式等待</p>
<p>调用<code>driver.implicitly_wait</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 请求网页</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.douban.com/&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式等待</p>
<p>显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用<code>selenium.webdriver.support.excepted_conditions</code>期望的条件和<code>selenium.webdriver.support.ui.WebDriverWait</code>来配合完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">&quot;http://somedomain/url_that_delays_loading&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">&quot;myDynamicElement&quot;</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他的等待条件</p>
<ol>
<li><code>presence_of_element_located</code>：某个元素已经加载完毕了。</li>
<li><code>presence_of_all_emement_located</code>：网页中所有满足条件的元素都加载完毕了。</li>
<li><code>element_to_be_cliable</code>：某个元素是可以点击了。</li>
</ol>
<p>更多条件请参考：<a href="http://selenium-python.readthedocs.io/waits.html">http://selenium-python.readthedocs.io/waits.html</a></p>
</li>
</ul>
<h3 id="切换页面"><a href="#切换页面" class="headerlink" title="切换页面"></a>切换页面</h3><p>在切换页面时，<code>selenium</code>提供了一个叫做<code>switch_to_window</code>来进行切换，具体切换到哪个页面，可以从<code>driver.window_handles</code>中找到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个新的页面</span></span><br><span class="line">self.driver.execute_script(<span class="string">&quot;window.open(&#x27;&quot;</span>+url+<span class="string">&quot;&#x27;)&quot;</span>)</span><br><span class="line"><span class="comment"># 切换到这个新的页面中</span></span><br><span class="line">self.driver.switch_to_window(self.driver.window_handles[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--proxy-server=http://113.12.202.50:50327&quot;</span>)</span><br><span class="line">driver_path = <span class="string">&quot;./driver/chromedriver.exe&quot;</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path, options=options)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&#x27;http://httpbin.org/ip&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="WebElement元素"><a href="#WebElement元素" class="headerlink" title="WebElement元素"></a>WebElement元素</h3><p><code>from selenium.webdriver.remote.webelement import WebElement</code>类是每个获取出来的元素的所属类</p>
<p>常用属性：</p>
<ol>
<li>get_attribute：这个标签的某个属性的值。</li>
<li>screentshot：获取当前页面的截图。这个方法只能在<code>driver</code>上使用。<code>driver</code>的对象类，也是继承自<code>WebElement</code>。</li>
</ol>
<h3 id="对带有页面嵌套的豆瓣进行登录"><a href="#对带有页面嵌套的豆瓣进行登录" class="headerlink" title="对带有页面嵌套的豆瓣进行登录"></a>对带有页面嵌套的豆瓣进行登录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver_path = <span class="string">&quot;./driver/chromedriver.exe&quot;</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.douban.com&#x27;</span>)</span><br><span class="line">iframe = driver.find_element_by_tag_name(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to.frame(iframe)</span><br><span class="line"></span><br><span class="line">login = driver.find_element_by_class_name(<span class="string">&quot;account-tab-account&quot;</span>)</span><br><span class="line"></span><br><span class="line">actions = webdriver.ActionChains(driver)</span><br><span class="line">actions.move_to_element(login)</span><br><span class="line">actions.click()</span><br><span class="line">actions.perform()</span><br><span class="line"></span><br><span class="line">username = driver.find_element_by_id(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">password = driver.find_element_by_id(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">submit = driver.find_element_by_xpath(<span class="string">&quot;//div[@class=&#x27;account-form-field-submit &#x27;]/a&quot;</span>)</span><br><span class="line"></span><br><span class="line">actions.move_to_element(username)</span><br><span class="line">actions.send_keys_to_element(username, <span class="string">&quot;your username&quot;</span>)</span><br><span class="line">actions.move_to_element(password)</span><br><span class="line">actions.send_keys_to_element(password, <span class="string">&quot;your password&quot;</span>)</span><br><span class="line">actions.move_to_element(submit)</span><br><span class="line">actions.click()</span><br><span class="line">actions.perform()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>注意：在使用以下内容时会出现警告信息，身为有代码洁癖的人，最不能忍受运行中出现警告信息。</p>
<p>警告信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DeprecationWarning: use driver.switch_to.frame instead driver.switch_to_frame(iframe)</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iframe = driver.find_element_by_tag_name(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to_frame(iframe)</span><br></pre></td></tr></table></figure>

<p>将上文改为即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iframe = driver.find_element_by_tag_name(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to.frame(iframe)</span><br></pre></td></tr></table></figure>

<p>对框架的解决方式推荐一篇文章：<a href="https://www.cnblogs.com/dydxw/p/10551160.html">Selenium（十二）嵌套frame定位</a></p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>Selenium</tag>
        <tag>chromedriver</tag>
      </tags>
  </entry>
  <entry>
    <title>通过图像像素值对图像进行降噪处理</title>
    <url>/191028/</url>
    <content><![CDATA[<h3 id="如何更好获取图像的像素值"><a href="#如何更好获取图像的像素值" class="headerlink" title="如何更好获取图像的像素值"></a>如何更好获取图像的像素值</h3><p>对于一张彩色的验证码，肯定少不了RBG三通道或者是RGBA四通道，其中在四通道的图像中，是在原来的基础上加上了alpha通道，即透明度。</p>
<p>彩色的图像虽然人为可以更好的区分，但是对于机器而言，并不能去区分。因此如何让机器进行区分这就是接下来要说明的问题。</p>
<p>首先，对于人而言，彩色的图像有时候是很容易区分出来的，对于机器而言，灰色或者黑白的图像才是机器容易识别的。因此，对于有颜色上区别的验证码而言，可以使用像素值过滤的方式进行降噪。当然，该方法只能解决部分，并不是通用的方法。</p>
<span id="more"></span>

<p>在开始接下来的内容之前需要先明白灰度值的计算公式:<code>Gray = R*0.299 + G*0.587 + B*0.114</code>，该公式为一个心理公式。</p>
<p>之后对于黑白图像，在图像中0表示黑色，255表示白色。</p>
<h3 id="图像降噪处理之图像灰度化转换"><a href="#图像降噪处理之图像灰度化转换" class="headerlink" title="图像降噪处理之图像灰度化转换"></a>图像降噪处理之图像灰度化转换</h3><p>以下代码均运行在jupyter notebook中。</p>
<p>开篇来张图：</p>
<p><img src="/userImages/a.jpeg"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">filenames = glob.glob(<span class="string">&#x27;images/*.jpeg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">filename = filenames[<span class="number">0</span>]</span><br><span class="line">img = plt.imread(filename)</span><br><span class="line"></span><br><span class="line">plt.imshow(img)</span><br></pre></td></tr></table></figure>

<p>对于给出的这张图片可以很明显的看出，可以根据不同的颜色进行图像降噪、去干绕线。</p>
<p>首先需要将彩色图片转为灰色图片，这样才能保证多通道的数据图像变成单通道的数据图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rgb2gray</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(img[...,:<span class="number">3</span>], [<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>])</span><br><span class="line"></span><br><span class="line">gray = rgb2gray(img)</span><br><span class="line"></span><br><span class="line">plt.imshow(gray, cmap = plt.get_cmap(<span class="string">&#x27;gray&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/userImages/a_gray.png"></p>
<p>在将图像转化为灰度图像之后，就可以很明显的看出，图像的像素值由原来的三通道变成了单通道数据。</p>
<p><img src="/userImages/2019-10-28-00.png"></p>
<h3 id="图像降噪处理之灰度图像像素值平均值"><a href="#图像降噪处理之灰度图像像素值平均值" class="headerlink" title="图像降噪处理之灰度图像像素值平均值"></a>图像降噪处理之灰度图像像素值平均值</h3><p>平均值，是反应一组数据的最好表现。在图像像素值中，通过平均值进行过滤可以达到意想不到的效果。</p>
<p>如果一张图片中有很多无关紧要的干扰因素，如空白区域，可以考虑将图像的像素值进行设定到一定的范围中，这样就是这些验证码的平均像素值了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">avg_image</span>(<span class="params">image, w, h</span>):</span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="keyword">if</span> image[i, j] &lt; <span class="number">180</span>:</span><br><span class="line">                points.append(image[i, j])</span><br><span class="line"></span><br><span class="line">    avg_point = <span class="built_in">sum</span>(points) // <span class="built_in">len</span>(points)</span><br><span class="line">    <span class="keyword">return</span> avg_point</span><br><span class="line"></span><br><span class="line">w,h = gray.shape</span><br><span class="line"></span><br><span class="line">avg_point = avg_image(gray, w, h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">cgray = copy.copy(gray)</span><br></pre></td></tr></table></figure>

<p><img src="/userImages/2019-10-28-01.png"></p>
<h3 id="图像降噪处理之像素值的增强与削弱"><a href="#图像降噪处理之像素值的增强与削弱" class="headerlink" title="图像降噪处理之像素值的增强与削弱"></a>图像降噪处理之像素值的增强与削弱</h3><p>在此处我们规定，图像的削弱点为平均值的像素值，这样可以保证对深颜色的再次加深，浅色的再次削弱。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">        r = gray[i, j] - avg_point</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">1</span>:</span><br><span class="line">            cgray[i, j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> r &gt; <span class="number">0</span>:</span><br><span class="line">            cgray[i, j] = <span class="number">255</span></span><br></pre></td></tr></table></figure>

<p>在经过上述处理后，效果就变为</p>
<p><img src="/userImages/2019-10-30-00.png"></p>
<h3 id="图像降噪处理之8邻域、4邻域降噪"><a href="#图像降噪处理之8邻域、4邻域降噪" class="headerlink" title="图像降噪处理之8邻域、4邻域降噪"></a>图像降噪处理之8邻域、4邻域降噪</h3><p> <code>8邻域降噪</code> 的前提是将图片灰度化，即将彩色图像转化为灰度图像。以RGN色彩空间为例，彩色图像中每个像素的颜色由R 、G、B三个分量决定，每个分量由0到255种取值，这个一个像素点可以有一千多万种颜色变化。而灰度则是将三个分量转化成一个，使每个像素点只有0-255种取值，这样可以使后续的图像计算量变得少一些。</p>
<p>图片越接近白色的点像素越接近255，越接近黑色的点像素越接近0，而且验证码字符肯定是非白色的。对于其中噪点大部分都是孤立的小点的，而且字符都是串联在一起的。<code>8邻域降噪</code> 的原理就是依次遍历图中所有非白色的点，计算其周围8个点中属于非白色点的个数，如果数量小于一个固定值，那么这个点就是噪点。对于不同类型的验证码这个阈值是不同的，所以可以在程序中配置，不断尝试找到最佳的阈值  。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">depoint</span>(<span class="params">img, k</span>):</span><br><span class="line">    pixdata = img</span><br><span class="line">    w, h = img.shape</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, w-<span class="number">1</span>):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y - <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x, y + <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x - <span class="number">1</span>, y] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x + <span class="number">1</span>, y] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x - <span class="number">1</span>, y - <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x - <span class="number">1</span>, y + <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x + <span class="number">1</span>, y - <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pixdata[x + <span class="number">1</span>, y + <span class="number">1</span>] &gt; <span class="number">254</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; k:</span><br><span class="line">                pixdata[x, y] = <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> pixdata</span><br><span class="line"></span><br><span class="line">np_img = depoint(cgray, <span class="number">8</span>)</span><br><span class="line">np_img = depoint(np_img, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/userImages/2019-10-30-01.png"></p>
<p>虽然看起来效果和经过像素值削弱过的图像没有两样，这是因为，在图像经过像素值调整的时候直接将图像的像素值做了调整，如果将两者顺序进行调整，将会看到不同效果。</p>
<h3 id="图像降噪处理之pycapt库的使用"><a href="#图像降噪处理之pycapt库的使用" class="headerlink" title="图像降噪处理之pycapt库的使用"></a>图像降噪处理之pycapt库的使用</h3><p>之所以引用这个库，是因为在降噪的过程中，以上的方法会降噪不是很好，如上图，可以看出仍旧有两条干扰线，使用pycapt库是为了将剩余的噪音处理掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pycapt</span><br><span class="line">img = Image.fromarray(np_img.astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line">img = pycapt.dele_line(img, <span class="number">2</span>)</span><br><span class="line">img = pycapt.dele_noise(img, N=<span class="number">2</span>, Z=<span class="number">1</span>)</span><br><span class="line">img = pycapt.tran_90(img)</span><br><span class="line">img = pycapt.dele_line(img, <span class="number">2</span>)</span><br><span class="line">img = pycapt.dele_noise(img, N=<span class="number">2</span>, Z=<span class="number">1</span>)</span><br><span class="line">img = pycapt.tran_90(img)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/userImages/2019-10-30-02.png"></p>
<p>处理前的效果：</p>
<p><img src="/userImages/2019-10-30-01.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>图像降噪处理有很多的方法，此处只是使用了一种大众化的方法，该方法可以解决很多有色值差的图像，但是，效果并不是很好。所以想要好的降噪后的图像，需要不断的寻找更好的方法。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>降噪</tag>
        <tag>像素值</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac中使用Navicat Premium</title>
    <url>/191217/</url>
    <content><![CDATA[<h3 id="给一个飞机链接"><a href="#给一个飞机链接" class="headerlink" title="给一个飞机链接"></a>给一个飞机链接</h3><p>链接1：<a href="https://linan.blog/2019/Navicat-Premium2/">起飞</a><br>链接2：<a href="https://hacpai.com/article/1571890862655">起飞</a></p>
<h3 id="Navicat-Keygen"><a href="#Navicat-Keygen" class="headerlink" title="Navicat Keygen"></a>Navicat Keygen</h3><p>由于原文的中的navicat-keygen无法使用了，可以采用以下的一个，效果相同</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/kervin521/navicat-keygen</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>激活</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask学习之路</title>
    <url>/200720/</url>
    <content><![CDATA[<blockquote>
<p>线程是可单独管理的最小指令集</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">上下文</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">current_app</td>
<td align="left">程序上下文</td>
<td align="left">当前激活程序的程序实例</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">程序上下文</td>
<td align="left">处理请求时用作临时存储的对象。每次请求都会重设</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">请求上下文</td>
<td align="left">请求对象，封装了客户端发出的http请求中的内容</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">请求上下文</td>
<td align="left">用户会话，用于存储请求之间需要“记住”的值的字典</td>
</tr>
</tbody></table>
<p>Flask 在分发请求之前激活（或推送）程序和请求上下文，请求处理完成后再将其删除。</p>
<span id="more"></span>

<h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td align="left">请求页面，并返回页面内容</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td align="left">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">大多用于提交表单或上传文件，数据包含在请求体中</td>
</tr>
</tbody></table>
<h3 id="常见的错误代码及错误原因"><a href="#常见的错误代码及错误原因" class="headerlink" title="常见的错误代码及错误原因"></a>常见的错误代码及错误原因</h3><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">说明</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">继续</td>
<td align="left">请求者应当继续提出请求。服务器已经收到请求的部分内容，正在等待其余部分</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">切换协议</td>
<td align="left">请求者已要求服务器切换协议，服务器已确认并准备切换</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">成功</td>
<td align="left">服务器已成功处理了请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">已创建</td>
<td align="left">请求成功并企鹅服务器创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">已接受</td>
<td align="left">服务器已接受请求，但尚未处理</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">非授权信息</td>
<td align="left">服务器已成功处理了请求，但返回的信息可能来自另个源</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">无内容</td>
<td align="left">服务器成功处理了请求，但没有返回任何内容</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">重置内容</td>
<td align="left">服务器成功处理了请求，内容被重置</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">部分内容</td>
<td align="left">服务器成功处理部分请求</td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">多种选择</td>
<td align="left">针对请求，服务器可执行多种操作</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">永久移动</td>
<td align="left">请求的网页已永久移动到新位置，即永久重定向</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">临时移动</td>
<td align="left">请求的页面暂时跳转到其他页面，即暂时重定向</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">查看其他位置</td>
<td align="left">如果原来的请求是POST，重定向目标文档应该通过GET提取</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">未修改</td>
<td align="left">此次请求返回的页面未修改，继续使用上次的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">使用代理</td>
<td align="left">请求者应该使用代理访问该网页</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">临时重定向</td>
<td align="left">请求的资源临时从其他位置响应</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">错误请求</td>
<td align="left">服务器无法解析该请求</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">未授权</td>
<td align="left">请求没有进行身份验证或验证未通过</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">禁止访问</td>
<td align="left">服务器拒绝此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">未找到</td>
<td align="left">服务器找不到请求的网页</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">方法禁用</td>
<td align="left">服务器禁用了请求中指定的方法</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">不接受</td>
<td align="left">无法使用请求的内容响应请求的网页</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">需要代理授权</td>
<td align="left">请求者需要使用代理授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">请求超时</td>
<td align="left">服务器请求超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">冲突</td>
<td align="left">服务器在完成请求时发生冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">已删除</td>
<td align="left">请求的资源已永久删除</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">需要有效长度</td>
<td align="left">服务器不接受不包含有效内容长度标头字段的请求</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">未满足前提条件</td>
<td align="left">服务器未满足请求者在请求中设置的其中一个前提条件</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">请求实体过大</td>
<td align="left">请求实体过大，超出服务器的处理能力</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">请求URI过长</td>
<td align="left">请求网址过长，服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">不支持类型</td>
<td align="left">请求格式不被请求页面支持</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">请求范围不符</td>
<td align="left">页面无法提供请求的范围</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">未满足期望值</td>
<td align="left">服务器未满足期望请求标头字段的要求</td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">服务器内部错误</td>
<td align="left">服务器遇到错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">未实现</td>
<td align="left">服务器不具备完成请求的功能</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">错误网关</td>
<td align="left">服务器作为网关或代理，从上游服务器收到无效响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">服务不可用</td>
<td align="left">服务器目前无法使用</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">网管超时</td>
<td align="left">服务器作为网关或代理，但是没有及时从上游服务器收到请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP版本不支持</td>
<td align="left">服务器不支持请求中所用的HTTP协议版本</td>
</tr>
</tbody></table>
<h3 id="常用的匹配规则"><a href="#常用的匹配规则" class="headerlink" title="常用的匹配规则"></a>常用的匹配规则</h3><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\w</td>
<td align="left">匹配字母、数字及下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配不是字母、数字及下划线的字符</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任意空白字符，等价于[\t\n\r\f]</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任意非空白字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配任意数字，等价于[0-9]</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配任意非数字的字符</td>
</tr>
<tr>
<td align="left">\A</td>
<td align="left">匹配字符串开头</td>
</tr>
<tr>
<td align="left">\Z</td>
<td align="left">匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td>
</tr>
<tr>
<td align="left">\z</td>
<td align="left">匹配字符串结尾，如果存在换行，同时还会匹配换行符</td>
</tr>
<tr>
<td align="left">\G</td>
<td align="left">匹配最后匹配完成的位置</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配一行字符串的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配一行字符串的结尾</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">用来表示一组字符，单独列出，比如[amk]匹配a、m或k</td>
</tr>
<tr>
<td align="left">[^…]</td>
<td align="left">不在[]中的字符，比如[^abc]匹配除了a、b、c之外的字符</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配0个或多个表达式</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配1个或多个表达式</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配0个或1个前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">精确匹配n个前面的表达式</td>
</tr>
<tr>
<td align="left">{n, m}</td>
<td align="left">匹配n到m次由前面正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td align="left">a|b</td>
<td align="left">匹配a或b</td>
</tr>
<tr>
<td align="left">()</td>
<td align="left">匹配括号内的表达式，也表示一个组</td>
</tr>
</tbody></table>
<h3 id="Python中的正则修饰符"><a href="#Python中的正则修饰符" class="headerlink" title="Python中的正则修饰符"></a>Python中的正则修饰符</h3><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">re.I</td>
<td align="left">使匹配对大小写不敏感</td>
</tr>
<tr>
<td align="left">re.L</td>
<td align="left">做本地化识别(locale-aware)匹配</td>
</tr>
<tr>
<td align="left">re.M</td>
<td align="left">多行匹配，影响<code>^</code>和<code>$</code></td>
</tr>
<tr>
<td align="left">re.S</td>
<td align="left">使<code>.</code>匹配包括换行符在内的所有字符</td>
</tr>
<tr>
<td align="left">re.U</td>
<td align="left">根据Unicode字符集解析字符。影响<code>\w</code>、<code>\W</code>、<code>\b</code>和<code>\B</code></td>
</tr>
<tr>
<td align="left">re.X</td>
<td align="left">该标志通过给予你更灵活的格式以便你将正则表达式写的更易于理解</td>
</tr>
</tbody></table>
<p><em>在网页匹配中，常用<code>re.S</code>和<code>re.I</code></em></p>
]]></content>
      <categories>
        <category>上下文全局变量</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/20200712/</url>
    <content><![CDATA[<p>“CSS” 列指示该属性是在哪个 CSS 版本中定义的。（CSS1、CSS2 还是 CSS3。）</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">示例说明</th>
<th align="left">CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.class</td>
<td align="left">.intro</td>
<td align="left">选择所有class&#x3D;”intro”的元素</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">#id</td>
<td align="left">#firstname</td>
<td align="left">选择所有id&#x3D;”firstname”的元素</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">*</td>
<td align="left">选择所有元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">element</td>
<td align="left">p</td>
<td align="left">选择所有 <code>&lt;p&gt;</code> 元素</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">element,element</td>
<td align="left">div,p</td>
<td align="left">选择所有<code>&lt;div&gt;</code>元素和<code>&lt;p&gt;</code>元素</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">element element</td>
<td align="left">div p</td>
<td align="left">选择<code>&lt;div&gt;</code>元素内所有的<code>&lt;p&gt;</code>元素</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">element&gt;element</td>
<td align="left">div&gt;p</td>
<td align="left">选择所有父级是<code>&lt;div&gt;</code>元素的<code>&lt;p&gt;</code>元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">element+element</td>
<td align="left">div+p</td>
<td align="left">选择所有紧接着<code>&lt;div&gt;</code>元素之后的<code>&lt;p&gt;</code>元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">[attribute]</td>
<td align="left">[target]</td>
<td align="left">选择所有带有target属性的元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">[attribute&#x3D;value]</td>
<td align="left">[target&#x3D;_blank]</td>
<td align="left">选择所有使用<code>target=&quot;_blank&quot;</code>的元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">[attribute~&#x3D;value]</td>
<td align="left">[title~&#x3D;flower]</td>
<td align="left">选择 title 属性包含单词 “flower” 的所有元素素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">[attribute|&#x3D;language]</td>
<td align="left">[lang|&#x3D;en]</td>
<td align="left">选择 lang 属性值以 “en” 开头的所有元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">:link</td>
<td align="left">a:link</td>
<td align="left">选择所有未访问链接</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">:visited</td>
<td align="left">a:visited</td>
<td align="left">选择所有访问过的链接</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">:active</td>
<td align="left">a:active</td>
<td align="left">选择所有活动链接</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">:hover</td>
<td align="left">a:hover</td>
<td align="left">选择鼠标指针位于其上的链接</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">:focus</td>
<td align="left">input:focus</td>
<td align="left">选择获得焦点的 input 元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">:first-letter</td>
<td align="left">p:first-letter</td>
<td align="left">选择每一个<code>&lt;p&gt;</code>元素的首字母</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">:first-line</td>
<td align="left">p:first-line</td>
<td align="left">选择每一个<code>&lt;p&gt;</code>元素的首行</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">:first-child</td>
<td align="left">p:first-child</td>
<td align="left">选择属于父元素的第一个子元素的每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">:before</td>
<td align="left">p:before</td>
<td align="left">在每个<code>&lt;p&gt;</code> 元素的内容之前插入内容</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">:after</td>
<td align="left">p:after</td>
<td align="left">在每个 <code>&lt;p&gt;</code> 元素的内容之后插入内容</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">:lang(language)</td>
<td align="left">p:lang(it)</td>
<td align="left">选择带有以 “it” 开头的 lang 属性值的每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">element1~element2</td>
<td align="left">p~ul</td>
<td align="left">选择前面有<code>&lt;p&gt;</code>元素的每个<code>&lt;ul&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">[attribute^&#x3D;value]</td>
<td align="left">a[src^&#x3D;”https”]</td>
<td align="left">选择其 src 属性值以 “https” 开头的每个 <code>&lt;a&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">[attribute$&#x3D;value]</td>
<td align="left">a[src$&#x3D;”.pdf”]</td>
<td align="left">选择其 src 属性以 “.pdf” 结尾的所有 <code>&lt;a&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">[attribute*&#x3D;value]</td>
<td align="left">a[src*&#x3D;”abc”]</td>
<td align="left">选择其 src 属性中包含 “abc” 子串的每个 <code>&lt;a&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:first-of-type</td>
<td align="left">p:first-of-type</td>
<td align="left">选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:last-of-type</td>
<td align="left">p:last-of-type</td>
<td align="left">选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:only-of-type</td>
<td align="left">p:only-of-type</td>
<td align="left">选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:only-child</td>
<td align="left">p:only-child</td>
<td align="left">选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:nth-child(n)</td>
<td align="left">p:nth-child(2)</td>
<td align="left">选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:nth-last-child(n)</td>
<td align="left">p:nth-lat-child(2)</td>
<td align="left">选择属于其父元素的倒数第二个子元素的每个 <code>&lt;p</code>&gt; 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:nth-of-type(n)</td>
<td align="left">p:nth-of-type(2)</td>
<td align="left">选择属于其父元素第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:nth-last-of-type(n)</td>
<td align="left">p:nth-last-of-type(2)</td>
<td align="left">选择属于其父元素倒数第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:last-child</td>
<td align="left">p:last-child</td>
<td align="left">选择属于其父元素最后一个子元素每个 <code>&lt;p&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:root</td>
<td align="left">:root</td>
<td align="left">选择文档的根元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:empty</td>
<td align="left">p:empty</td>
<td align="left">选择没有子元素的每个 <code>&lt;p&gt;</code> 元素（包括文本节点）</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:target</td>
<td align="left">#news:target</td>
<td align="left">选择当前活动的 #news 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:enabled</td>
<td align="left">input:enabled</td>
<td align="left">选择每个启用的 <code>&lt;input&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:disabled</td>
<td align="left">input:disabled</td>
<td align="left">选择每个禁用的 <code>&lt;input&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:checked</td>
<td align="left">input:checked</td>
<td align="left">选择每个被选中的 <code>&lt;input&gt;</code> 元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:not(selector)</td>
<td align="left">:not(p)</td>
<td align="left">选择非<code>&lt;p&gt;</code> 元素的每个元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:out-of-range</td>
<td align="left">:out-of-range</td>
<td align="left">匹配值在指定区间之外的input元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:in-range</td>
<td align="left">:in-range</td>
<td align="left">匹配值在指定区间之内的input元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:read-write</td>
<td align="left">:read-write</td>
<td align="left">用于匹配可读及可写的元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:read-only</td>
<td align="left">:read-only</td>
<td align="left">用于配置只读属性的元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:optional</td>
<td align="left">:optional</td>
<td align="left">用于匹配可选的输入元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:required</td>
<td align="left">:required</td>
<td align="left">用于匹配设置了<code>required</code>属性的元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:valid</td>
<td align="left">:valid</td>
<td align="left">用于匹配输入值为合法的元素</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">:invalid</td>
<td align="left">:invalid</td>
<td align="left">用于匹配输入值为非法的元素</td>
<td align="left">3</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>lxml</category>
      </categories>
      <tags>
        <tag>lxml</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Pip 更新所有包</title>
    <url>/20200412/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查看可更新包：</span><br><span class="line">pip <span class="built_in">list</span>  --outdated --<span class="built_in">format</span>=columns</span><br><span class="line">批量下载并更新：</span><br><span class="line">pip install pip-review</span><br><span class="line">pip-review --local --interactive</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>Pip</tag>
      </tags>
  </entry>
  <entry>
    <title>BaseServer</title>
    <url>/BaseServer/</url>
    <content><![CDATA[<h3 id="服务器类型"><a href="#服务器类型" class="headerlink" title="服务器类型"></a>服务器类型</h3><blockquote>
<p>5种类型：BaseServer，TCPServer，UnixStreamServer，UDPServer，UnixDatagramServer。注意：BaseServer不直接对外服务。</p>
</blockquote>
<span id="more"></span>

<h3 id="服务器对象"><a href="#服务器对象" class="headerlink" title="服务器对象"></a>服务器对象</h3><ul>
<li>class SocketServer.BaseServer:这是模块中的所有服务器对象的超类。它定义了接口，如下所述，但是大多数的方法不实现，在子类中进行细化。</li>
<li>BaseServer.fileno():返回服务器监听套接字的整数文件描述符。通常用来传递给select.select(), 以允许一个进程监视多个服务器。</li>
<li>BaseServer.handle_request():处理单个请求。处理顺序:get_request(),verify_request(),process_request()。如果用户提供handle()方法抛出异常，将调用服务器的handle_error()方法。如果self.timeout内没有请求收到， 将调用handle_timeout()并返回handle_request()。</li>
<li>BaseServer.serve_forever(poll_interval&#x3D;0.5):处理请求，直到一个明确的shutdown()请求。每poll_interval秒轮询一次shutdown。忽略self.timeout。如果你需要做周期性的任务，建议放置在其他线程。</li>
<li>BaseServer.shutdown():告诉serve_forever()循环停止并等待其停止。python2.6版本。</li>
<li>BaseServer.address_family::地址家族，比如socket.AF_INET和socket.AF_UNIX。</li>
<li>BaseServer.RequestHandlerClass:用户提供的请求处理类，这个类为每个请求创建实例。</li>
<li>BaseServer.server_address:服务器侦听的地址。格式根据协议家族地址的各不相同，请参阅socket模块的文档。</li>
<li>BaseServer.socketSocket:服务器上侦听传入的请求socket对象的服务器。</li>
</ul>
<h3 id="服务器类支持下面的类变量"><a href="#服务器类支持下面的类变量" class="headerlink" title="服务器类支持下面的类变量"></a>服务器类支持下面的类变量</h3><ul>
<li>BaseServer.allow_reuse_address：服务器是否允许地址的重用。默认为false ，并且可在子类中更改。</li>
<li>BaseServer.request_queue_size</li>
</ul>
<h3 id="请求队列的大小"><a href="#请求队列的大小" class="headerlink" title="请求队列的大小"></a>请求队列的大小</h3><p>如果单个请求需要很长的时间来处理，服务器忙时请求被放置到队列中，最多可以放request_queue_size个。一旦队列已满，来自客户端的请求将得到 “Connection denied”错误。默认值通常为5 ，但可以被子类覆盖。</p>
<ul>
<li>BaseServer.socket_type：服务器使用的套接字类型;socket.SOCK_STREAM和socket.SOCK_DGRAM等。</li>
<li>BaseServer.timeout：超时时间，以秒为单位，或 None表示没有超时。如果handle_request()在timeout内没有收到请求，将调用handle_timeout()。</li>
</ul>
<p>下面方法可以被子类重载，它们对服务器对象的外部用户没有影响。</p>
<ul>
<li>BaseServer.finish_request()：实际处理RequestHandlerClass发起的请求并调用其handle()方法。 常用。</li>
<li>BaseServer.get_request()：接受socket请求，并返回二元组包含要用于与客户端通信的新socket对象，以及客户端的地址。</li>
<li>BaseServer.handle_error(request, client_address)：如果RequestHandlerClass的handle()方法抛出异常时调用。默认操作是打印traceback到标准输出，并继续处理其他请求。</li>
<li>BaseServer.handle_timeout()：超时处理。默认对于forking服务器是收集退出的子进程状态，threading服务器则什么都不做。</li>
<li>BaseServer.process_request(request, client_address) :调用finish_request()创建RequestHandlerClass的实例。如果需要，此功能可以创建新的进程或线程来处理请求,ForkingMixIn和ThreadingMixIn类做到这点。常用。</li>
<li>BaseServer.server_activate()：通过服务器的构造函数来激活服务器。默认的行为只是监听服务器套接字。可重载。</li>
<li>BaseServer.server_bind()：通过服务器的构造函数中调用绑定socket到所需的地址。可重载。</li>
<li>BaseServer.verify_request(request, client_address)：返回一个布尔值，如果该值为True ，则该请求将被处理，反之请求将被拒绝。此功能可以重写来实现对服务器的访问控制。默认的实现始终返回True。client_address可以限定客户端，比如只处理指定ip区间的请求。 常用。</li>
</ul>
<h3 id="请求处理器"><a href="#请求处理器" class="headerlink" title="请求处理器"></a>请求处理器</h3><p>处理器接收数据并决定如何操作。它负责在socket层之上实现协议（i.e., HTTP, XML-RPC, or AMQP)，读取数据，处理并写反应。可以重载的方法如下：</p>
<ul>
<li>setup():准备请求处理. 默认什么都不做，StreamRequestHandler中会创建文件类似的对象以读写socket.</li>
<li>handle():处理请求。解析传入的请求，处理数据，并发送响应。默认什么都不做。常用变量：self.request，self.client_address，self.server。</li>
<li>finish():环境清理。默认什么都不做，如果setup产生异常，不会执行finish。</li>
</ul>
<p>通常只需要重载handle,self.request的类型和数据报或流的服务不同。</p>
<ul>
<li>对于流服务，self.request是socket 对象；</li>
<li>对于数据报服务，self.request是字符串和socket。可以在子类StreamRequestHandler或 DatagramRequestHandler中重载，重写setup()和finish(),并提供self.rfile和self.wfile属性。self.rfile和self.wfile可以读取或写入，以获得请求数据或将数据返回到客户端。</li>
</ul>
]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>base server</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP Module</title>
    <url>/FTP-Module/</url>
    <content><![CDATA[<h3 id="ftplib模块的用法"><a href="#ftplib模块的用法" class="headerlink" title="ftplib模块的用法"></a>ftplib模块的用法</h3><ul>
<li>login(user&#x3D;’’,passwd&#x3D;’’, acct&#x3D;’’) 登录到FTP 服务器，所有的参数都是可选的</li>
<li>pwd() 当前工作目录</li>
<li>cwd(path) 把当前工作目录设置为path</li>
<li>dir([path[,…[,cb]]) 显示path 目录里的内容，可选的参数cb 是一个回调函数，会被传给retrlines()方法</li>
<li>nlst([path[,…]) 与dir()类似，但返回一个文件名的列表，而不是显示这些文件名</li>
<li>retrlines(cmd [, cb]) 给定FTP 命令（如“RETR filename”），用于下载文本文件。可选的回调函数cb 用于处理文件的每一行</li>
<li>retrbinary(cmd, cb[,bs&#x3D;8192[, ra]]) 与retrlines()类似，只是这个指令处理二进制文件。回调函数cb 用于处理每一块（块大小默认为8K）下载的数据。</li>
<li>storlines(cmd, f) 给定FTP 命令（如“STOR filename”），以上传文本文件。要给定一个文件对象f</li>
<li>storbinary(cmd, f[,bs&#x3D;8192]) 与storlines()类似，只是这个指令处理二进制文件。要给定一个文件对象f，上传块大小bs 默认为8Kbs&#x3D;8192])</li>
<li>rename(old, new) 把远程文件old 改名为new</li>
<li>delete(path) 删除位于path 的远程文件</li>
<li>mkd(directory) 创建远程目录</li>
</ul>
<span id="more"></span>

<h3 id="此处给出官方给的介绍"><a href="#此处给出官方给的介绍" class="headerlink" title="此处给出官方给的介绍"></a>此处给出官方给的介绍</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Methods defined here:</span><br><span class="line">|</span><br><span class="line">| init(self, host=’’, user=’’, passwd=’’, acct=’’, keyfile=<span class="literal">None</span>, certfile=<span class="literal">None</span>, context=<span class="literal">None</span>, timeout=, source_address=<span class="literal">None</span>)</span><br><span class="line">|</span><br><span class="line">| auth(self)</span><br><span class="line">| <span class="type">Set</span> up secure control connection by using TLS/SSL.</span><br><span class="line">|</span><br><span class="line">| login(self, user=’’, passwd=’’, acct=’’, secure=<span class="literal">True</span>)</span><br><span class="line">|</span><br><span class="line">| ntransfercmd(self, cmd, rest=<span class="literal">None</span>)</span><br><span class="line">|</span><br><span class="line">| prot_c(self)</span><br><span class="line">| <span class="type">Set</span> up clear text data connection.</span><br><span class="line">|</span><br><span class="line">| prot_p(self)</span><br><span class="line">| <span class="type">Set</span> up secure data connection.</span><br><span class="line">|</span><br><span class="line">| retrbinary(self, cmd, callback, blocksize=<span class="number">8192</span>, rest=<span class="literal">None</span>)</span><br><span class="line">|</span><br><span class="line">| retrlines(self, cmd, callback=<span class="literal">None</span>)</span><br><span class="line">|</span><br><span class="line">| storbinary(self, cmd, fp, blocksize=<span class="number">8192</span>, callback=<span class="literal">None</span>, rest=<span class="literal">None</span>)</span><br><span class="line">|</span><br><span class="line">| storlines(self, cmd, fp, callback=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPath的用法</title>
    <url>/OS-Path/</url>
    <content><![CDATA[<h3 id="OS-path模块中的部分函数的介绍"><a href="#OS-path模块中的部分函数的介绍" class="headerlink" title="OS.path模块中的部分函数的介绍"></a>OS.path模块中的部分函数的介绍</h3><ul>
<li>os.path.abspath(path) #返回绝对路径</li>
<li>os.path.basename(path) #返回文件名</li>
<li>os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。</li>
<li>os.path.dirname(path) #返回文件路径</li>
<li>os.path.exists(path) #路径存在则返回True,路径损坏返回False</li>
<li>os.path.lexists #路径存在则返回True,路径损坏也返回True</li>
<li>os.path.expanduser(path) #把path中包含的”<del>”和”</del>user”转换成用户目录</li>
</ul>
<span id="more"></span>

<ul>
<li>os.path.expandvars(path) #根据环境变量的值替换path中包含的”$name”和”${name}”</li>
<li>os.path.getatime(path) #返回最后一次进入此path的时间。</li>
<li>os.path.getmtime(path) #返回在此path下最后一次修改的时间。</li>
<li>os.path.getctime(path) #返回path的大小</li>
<li>os.path.getsize(path) #返回文件大小，如果文件不存在就返回错误</li>
<li>os.path.isabs(path) #判断是否为绝对路径</li>
<li>os.path.isfile(path) #判断路径是否为文件</li>
<li>os.path.isdir(path) #判断路径是否为目录</li>
<li>os.path.islink(path) #判断路径是否为链接</li>
<li>os.path.ismount(path) #判断路径是否为挂载点（）</li>
<li>os.path.join(path1[, path2[, …]]) #把目录和文件名合成一个路径</li>
<li>os.path.normcase(path) #转换path的大小写和斜杠</li>
<li>os.path.normpath(path) #规范path字符串形式</li>
<li>os.path.realpath(path) #返回path的真实路径</li>
<li>os.path.relpath(path[, start]) #从start开始计算相对路径</li>
<li>os.path.samefile(path1, path2) #判断目录或文件是否相同</li>
<li>os.path.sameopenfile(fp1, fp2) #判断fp1和fp2是否指向同一文件</li>
<li>os.path.samestat(stat1, stat2) #判断stat tuple stat1和stat2是否指向同一个文件</li>
<li>os.path.split(path) #把路径分割成dirname和basename，返回一个元组</li>
<li>os.path.splitdrive(path) #一般用在windows下，返回驱动器名和路径组成的元组</li>
<li>os.path.splitext(path) #分割路径，返回路径名和文件扩展名的元组</li>
<li>os.path.splitunc(path) #把路径分割为加载点与文件</li>
<li>os.path.walk(path, visit, arg) #遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数</li>
<li>os.path.supports_unicode_filenames #设置是否支持unicode路径名</li>
</ul>
]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>os模块</tag>
        <tag>path的用法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python位运算</title>
    <url>/Python%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>Python中的位运算是程序设计中对位模式或二进制的一元和二元操作。<br>按位运算就是把数字转换为机器语言—以二进制形式表示  </p>
<h2 id="Python中的位运算有哪些？"><a href="#Python中的位运算有哪些？" class="headerlink" title="Python中的位运算有哪些？"></a>Python中的位运算有哪些？</h2><p>在Python中，按位运算符有左移运算符（&lt;&lt;）、右移运算符（&gt;&gt;）、按位与运算（&amp;）、按位或运算（|）、按位取反运算（~）、异或运算符，其中按位取反运算符为单目运算符</p>
<span id="more"></span>

<h3 id="按位左移运算符（"><a href="#按位左移运算符（" class="headerlink" title="按位左移运算符（&lt;&lt;）"></a>按位左移运算符（&lt;&lt;）</h3><p>在机器语言中，任何形式均以二进制的形式进行表示：<br>举例：7&lt;&lt;2<br>二进制为：111 左移两位：11100 最后结果为：28  </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 7&lt;&lt;2</span><br><span class="line">28</span><br></pre></td></tr></table></figure>

<h3 id="按位右移运算符（-）"><a href="#按位右移运算符（-）" class="headerlink" title="按位右移运算符（&gt;&gt;）"></a>按位右移运算符（&gt;&gt;）</h3><p>具体的使用形式和左移一样。<br>举例：<br>7&gt;&gt;2<br>28&gt;&gt;2<br>二进制：7的二进制为：111，右移两位后为001，结果即为1<br>28的二进制为:11100，右移两位后为00111，结果为7  </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 7&gt;&gt;2</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 28&gt;&gt;2</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>由于正数和负数的二进制形式不同，所以此处特别说下以下两个运算。在计算机中，负数的二进制形式是其正数的补码形式，此处不做特别的说明，需要知道的以下给出一个<a href="http://www.cnblogs.com/junsky/archive/2009/08/06/1540727.html">链接</a>.</p>
<h3 id="按位与运算（-）"><a href="#按位与运算（-）" class="headerlink" title="按位与运算（&amp;）"></a>按位与运算（&amp;）</h3><p>正数和正数的与运算：<br>举例： 7&amp;9<br>二进制：7的二进制为:0111，9的二进制为:1001<br>说明：根据（1&amp;1&#x3D;1、1&amp;0&#x3D;0、0&amp;1&#x3D;0、0&amp;0&#x3D;0）即相同位置同为1结果即为1，否者为0，由此可见7&amp;9的二进制形式为：0111&amp;1001 &#x3D;&#x3D; 0001<br>正数与负数的与运算：<br>举例：-7&amp;5<br>二进制：-7：1001，5：0101。结果为1<br>说明：此处你可能要问-7的二进制和9的二进制不是相同吗？答案是不相同，在机器中-7的二进制为：11111111 11111111 11111111 11111001，9的二进制为：00000000 00000000 00000000 00001001。同样根据上文的同为1既为1，所以结果为1。运算最后结果的二进制形式从最左侧的第一个0前的1开始，直至右侧结尾，将此数转换为10进制，重点是，此处不是依次相加，而是依次相减，得到的结果最后加上负号即为最后运算的结果。<br>负数与负数的与运算：<br>举例：-5&amp;-8<br>二进制：-5：11111011，-8：11111000结果为-8<br>说明：你可能会很疑惑，此处的结果明明是11111000，结果怎么是-8.原因是-5&amp;-8的二进制形式为：11111011&amp;11111000 &#x3D;&#x3D; 11111000，从最左侧的第一个0前的1开始，直至右侧结尾，将此数转换为10进制，重点是，此处不是依次相加，而是依次相减，得到的结果最后加上负号即为最后运算的结果。  </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 7&amp;9</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; -7&amp;5</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; -5&amp;-8</span><br><span class="line">-8</span><br></pre></td></tr></table></figure>

<h3 id="按位或运算（-）"><a href="#按位或运算（-）" class="headerlink" title="按位或运算（|）"></a>按位或运算（|）</h3><p>或运算和与运算十分相似，只是依据的逻辑运算不同，或运算的依据逻辑是相同位置有个为1结果即为1<br>正数与正数的或运算：<br>举例：7|9<br>二进制：7：0111，9：1001<br>说明：根据（1|0&#x3D;1、1|1&#x3D;1、0|1&#x3D;1、0|0&#x3D;0）可知，7|9的二进制形式为：0111|1001，结果为：15<br>负数与正数的或运算：<br>举例：-7|9<br>二进制：-7：11111001，9：00001001<br>说明：从最左侧的第一个0前的1开始的数，转化为十进制，需要进行的是依次相减运算。<br>负数与负数的或运算：<br>举例：-5|-8<br>二进制：-5：11111011，-8：11111000结果为-5<br>说明：运算最后结果的二进制形式从最左侧的第一个0前的1开始，直至右侧结尾，将此数转换为10进制，重点是，此处不是依次相加，而是依次相减，得到的结果最后加上负号即为最后运算的结果。  </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 7|9</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; -7|9</span><br><span class="line">-7</span><br><span class="line">&gt;&gt;&gt; -5|-8</span><br><span class="line">-5</span><br></pre></td></tr></table></figure>

<h3 id="按位取反运算符（-）"><a href="#按位取反运算符（-）" class="headerlink" title="按位取反运算符（~）"></a>按位取反运算符（~）</h3><p>将二进制数+1之后乘以-1,假如x的二进制数是y，x的按位翻转是-(y+1)<br>举例：-3<br>去反后：2<br>二进制：-3：11111101 取反操作：-（11111101+1）&#x3D;&#x3D;-（11111110）&#x3D;&#x3D;2  </p>
<h3 id="异或运算符（-）"><a href="#异或运算符（-）" class="headerlink" title="异或运算符（^）"></a>异或运算符（^）</h3><p>二进制对应位相加，不进位。依据逻辑为：（1^1&#x3D;0、1^0&#x3D;1、0^1&#x3D;1、0^0&#x3D;0）,同样依照，如果两个数中一正一负，则最后的二进制转十进制时依次相减，如果同正同负，则相加<br>正数和正数的异或运算：<br>举例：7^9<br>二进制：7：0111，9：1001<br>说明：7^9的二进制形式为：0111^1001 &#x3D;&#x3D; 1110，十进制为：14<br>负数和正数的异或运算：<br>举例：-3^4<br>二进制：-3：11111101，4：00000100<br>说明：-3^4的二进制形式为：11111101^00000100 &#x3D;&#x3D; 11111001,根据说明可以知道结果为-（222-1）&#x3D;-7<br>负数和负数的异或运算：<br>举例：-7^-9<br>二进制：-7：11111001，-9：11110111<br>说明；-7^-9的二进制形式为：11111001^11110111 &#x3D;&#x3D; 00001110，根据说明可以知道结果为222+2*2+2&#x3D;14  </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 7^9</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; -3^4</span><br><span class="line">-7</span><br><span class="line">&gt;&gt;&gt; -7^-9</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>起始篇</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title>Hypervisor Drivers</title>
    <url>/hypervisor-drivers/</url>
    <content><![CDATA[<h3 id="Drivers-Models"><a href="#Drivers-Models" class="headerlink" title="Drivers Models"></a>Drivers Models</h3><p>The libvirt library exposes a guaranteed stable API &amp; ABI which is decoupled from any particular virtualization technology. In addition many of the APIs have associated XML schemata which are considered part of the stable ABI guarantee. Internally, there are multiple of implementations of the public ABI, each targeting a different virtualization technology. Each implementation is referred to as a driver. When obtaining a instance of the virConnect class, the application developer can provide a URI to determine which hypervisor driver is activated.  </p>
<span id="more"></span>

<p>No two virtualization technologies have exactly the same functionality. The libvirt goal is not to restrict applications to a lowest common denominator, since this would result in an unacceptably limited API. Instead libvirt attempts to define a representation of concepts and configuration that is hypervisor agnostic, and adaptable to allow future extensions. Thus, if two hypervisors implement a comparable feature, libvirt provides a uniform control mechanism or configuration format for that feature.<br>If a libvirt driver does not implement a particular API, then it will return a VIR_ERR_NO_SUPPORT error code enabling this to be detected. There is also an API to allow applications to the query certain capabilities of a hypervisor, such as the type of guest ABIs that are supported.<br>Internally a libvirt driver will attempt to utilize whatever management channels are available for the virtualization technology in question. For some drivers this may require libvirt to run directly on the host being managed, talking to a local hypervisor, while others may be able to communicate remotely over an RPC service. For drivers which have no native remote communication capability, libvirt provides a generic secure RPC service. This is discussed in detail later in this chapter.  </p>
<h3 id="Hypervisor-drivers"><a href="#Hypervisor-drivers" class="headerlink" title="Hypervisor drivers"></a>Hypervisor drivers</h3><ul>
<li><p>Xen: The open source Xen hypervisor providing paravirtualized and fully virtualized machines.</p>
<p>A single system driver runs in the Dom0 host talking directly to a combination of the hypervisor,xenstored and xend. Example local URI scheme xen:&#x2F;&#x2F;&#x2F;.</p>
</li>
<li><p>QEMU: Any open source QEMU based virtualization technology, including KVM. A single privileged system driver runs in the host managing QEMU processes. Each unprivileged user account also has a private instance of the driver. Example privileged URI scheme qemu:&#x2F;&#x2F;&#x2F;system. Example unprivileged URI scheme qemu:&#x2F;&#x2F;&#x2F;session</p>
</li>
<li><p>UML: The User Mode Linux kernel, a pure paravirtualization technology. A single privileged system driver runs in the host managing UML processes. Each unprivileged user account also has a private instance of the driver. Example privileged URI scheme uml:&#x2F;&#x2F;&#x2F;system. Example unprivileged URI scheme uml:&#x2F;&#x2F;&#x2F;session</p>
</li>
<li><p>OpenVZ: The OpenVZ container based virtualization technology, using a modified Linux host kernel.</p>
<p>A single privileged system driver runs in the host talking to the OpenVZ tools. Example privileged URI scheme openvz:&#x2F;&#x2F;&#x2F;system</p>
</li>
<li><p>LXC: The native Linux container based virtualization technology, available with Linux kernels since 2.6.25. A single privileged system driver runs in the host talking to the kernel. Example privileged URI scheme lxc:&#x2F;&#x2F;&#x2F;</p>
</li>
<li><p>Remote: Generic secure RPC service talking to a libvirtd daemon. Encryption and authentication using a choice of TLS, x509 certificates, SASL (GSSAPI&#x2F;Kerberos) and SSH tunneling. URIs follow the scheme of the desired driver, but with a hostname filled in, and a data transport name appended to the URI scheme. Example URI to talk to Xen over a TLS channel xen+tls:&#x2F;&#x2F;somehostname&#x2F;. Example URI to talk to QEMU over a SASL channel qemu+tcp:&#x2F;&#x2F;&#x2F;somehost&#x2F;system</p>
</li>
<li><p>Test: A mock driver, providing a virtual in-memory hypervisor covering all the libvirt APIs. Facilities testing of applications using libvirt, by allowing automated tests to run which exercise libvirt APIs without needing to deal with a real hypervisor Example default URI scheme test:&#x2F;&#x2F;&#x2F;default.</p>
<p>Example customized URI scheme test:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;driver&#x2F;config.xml</p>
</li>
</ul>
<p><img src="/userImages/hypervisor.png" alt="Hypervisor"></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Hypervisor</tag>
        <tag>qemu</tag>
        <tag>xen</tag>
      </tags>
  </entry>
  <entry>
    <title>tempfile模块的用法</title>
    <url>/tempfile/</url>
    <content><![CDATA[<blockquote>
<p>tempfile模块，用来对临时数据进行操作</p>
</blockquote>
<h2 id="tempfile-临时文件-夹-操作"><a href="#tempfile-临时文件-夹-操作" class="headerlink" title="tempfile 临时文件(夹)操作"></a>tempfile 临时文件(夹)操作</h2><h3 id="tempfile-mkstemp-suffix-”-prefix-’tmp’-dir-None-text-False"><a href="#tempfile-mkstemp-suffix-”-prefix-’tmp’-dir-None-text-False" class="headerlink" title="tempfile.mkstemp([suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None[, text&#x3D;False]]]])"></a>tempfile.mkstemp([suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None[, text&#x3D;False]]]])</h3><p>mkstemp方法用于创建一个临时文件。该方法仅仅用于创建临时文件，调用tempfile.mkstemp函数后，返回包含两个元素的元组，第一个元素指示操作该临时文件的安全级别，第二个元素指示该临时文件的路径。参数suffix和prefix分别表示临时文件名称的后缀和前缀；dir指定了临时文件所在的目录，如果没有指定目录，将根据系统环境变量TMPDIR, TEMP或者TMP的设置来保存临时文件；参数text指定了是否以文本的形式来操作文件，默认为False，表示以二进制的形式来操作文件。</p>
<span id="more"></span>

<h3 id="tempfile-mkdtemp-suffix-”-prefix-’tmp’-dir-None"><a href="#tempfile-mkdtemp-suffix-”-prefix-’tmp’-dir-None" class="headerlink" title="tempfile.mkdtemp([suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None]]])"></a>tempfile.mkdtemp([suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None]]])</h3><p>该函数用于创建一个临时文件夹。参数的意思与tempfile.mkdtemp一样。它返回临时文件夹的绝对路径。</p>
<h3 id="tempfile-mktemp-suffix-”-prefix-’tmp’-dir-None"><a href="#tempfile-mktemp-suffix-”-prefix-’tmp’-dir-None" class="headerlink" title="tempfile.mktemp([suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None]]])"></a>tempfile.mktemp([suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None]]])</h3><p>mktemp用于返回一个临时文件的路径，但并不创建该临时文件。</p>
<h3 id="tempfile-tempdir"><a href="#tempfile-tempdir" class="headerlink" title="tempfile.tempdir"></a>tempfile.tempdir</h3><p>该属性用于指定创建的临时文件（夹）所在的默认文件夹。如果没有设置该属性或者将其设为None，Python将返回以下环境变量TMPDIR, TEMP, TEMP指定的目录，如果没有定义这些环境变量，临时文件将被创建在当前工作目录。</p>
<h3 id="tempfile-gettempdir"><a href="#tempfile-gettempdir" class="headerlink" title="tempfile.gettempdir()"></a>tempfile.gettempdir()</h3><p>gettempdir()则用于返回保存临时文件的文件夹路径。</p>
<h3 id="tempfile-TemporaryFile-mode-’w-b’-bufsize-1-suffix-”-prefix-’tmp’-dir-None"><a href="#tempfile-TemporaryFile-mode-’w-b’-bufsize-1-suffix-”-prefix-’tmp’-dir-None" class="headerlink" title="tempfile.TemporaryFile([mode&#x3D;’w+b’[, bufsize&#x3D;-1[, suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None]]]]])"></a>tempfile.TemporaryFile([mode&#x3D;’w+b’[, bufsize&#x3D;-1[, suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None]]]]])</h3><p>该函数返回一个类文件对象(file-like)用于临时数据保存（实际上对应磁盘上的一个临时文件）。当文件对象被close或者被del的时候，临时文件将从磁盘上删除。mode、bufsize参数的单方与open()函数一样；suffix和prefix指定了临时文件名的后缀和前缀；dir用于设置临时文件默认的保存路径。返回的类文件对象有一个file属性，它指向真正操作的底层的file对象。</p>
<h3 id="tempfile-NamedTemporaryFile-mode-’w-b’-bufsize-1-suffix-”-prefix-’tmp’-dir-None-delete-True"><a href="#tempfile-NamedTemporaryFile-mode-’w-b’-bufsize-1-suffix-”-prefix-’tmp’-dir-None-delete-True" class="headerlink" title="tempfile.NamedTemporaryFile([mode&#x3D;’w+b’[, bufsize&#x3D;-1[, suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None[, delete&#x3D;True]]]]]])"></a>tempfile.NamedTemporaryFile([mode&#x3D;’w+b’[, bufsize&#x3D;-1[, suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None[, delete&#x3D;True]]]]]])</h3><p>tempfile.NamedTemporaryFile函数的行为与tempfile.TemporaryFile类似，只不过它多了一个delete参数，用于指定类文件对象close或者被del之后，是否也一同删除磁盘上的临时文件（当delete &#x3D; True的时候，行为与TemporaryFile一样）。</p>
<h3 id="tempfile-SpooledTemporaryFile-max-size-0-mode-’w-b’-bufsize-1-suffix-”-prefix-’tmp’-dir-None"><a href="#tempfile-SpooledTemporaryFile-max-size-0-mode-’w-b’-bufsize-1-suffix-”-prefix-’tmp’-dir-None" class="headerlink" title="tempfile.SpooledTemporaryFile([max_size&#x3D;0[, mode&#x3D;’w+b’[, bufsize&#x3D;-1[, suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None]]]]]])"></a>tempfile.SpooledTemporaryFile([max_size&#x3D;0[, mode&#x3D;’w+b’[, bufsize&#x3D;-1[, suffix&#x3D;”[, prefix&#x3D;’tmp’[, dir&#x3D;None]]]]]])</h3><p>tempfile.SpooledTemporaryFile函数的行为与tempfile.TemporaryFile类似。不同的是向类文件对象写数据的时候，数据长度只有到达参数max_size指定大小时，或者调用类文件对象的fileno()方法，数据才会真正写入到磁盘的临时文件中。</p>
]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>tempfile</tag>
        <tag>临时文件</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机的动、静态迁移</title>
    <url>/vmmove/</url>
    <content><![CDATA[<h3 id="动静态迁移的原理"><a href="#动静态迁移的原理" class="headerlink" title="动静态迁移的原理"></a>动静态迁移的原理</h3><p>静态迁移是指在虚拟机关闭或暂停的情况下，将源宿主机上虚拟机的磁盘文件和配置文件拷贝到目标宿主机上。这种方式需要显式的停止虚拟机运行，对服务可用性要求高的需求不合适。</p>
<p>动态迁移无需拷贝虚拟机配置文件和磁盘文件，但是需要迁移的主机之间有相同的目录结构放置虚拟机磁盘文件，可以通过多种方式实现，本例采用基于共享存储动态迁移，通过NFS来实现。</p>
<span id="more"></span>

<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><blockquote>
<p>源宿主机：Ubuntu17.10 Server版操作系统，4.10.0-38-generic内核。下文中以“Node1”表示，主机名为Service，IP地址为192.168.200.132，NFS挂载目录&#x2F;opt。<br>  目标宿主机：Ubuntu17.10 Server版操作系统，4.10.0-38-generic内核。下文中以“Node2”表示，主机名为Service1，IP地址为192.168.200.131，NFS挂载目录&#x2F;opt。<br>  基于QEMU的动态迁移虚拟机镜像文件为ubuntu16server.img。<br>  基于libvirt的静态迁移测试虚拟机：demo1，IP为192.168.200.132，虚拟镜像文件为ubuntu16.img。<br>  基于libvirt的动态迁移测试虚拟机：demo2，IP为192.168.200.131，虚拟镜像文件为ubuntu16.img。<br>  NFS服务器：Ubuntu17.10 Server版，4.10.0-38-generic内核。IP地址为192.168.200.130，服务目录为&#x2F;opt&#x2F;share。  </p>
</blockquote>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="NFS服务器的搭建"><a href="#NFS服务器的搭建" class="headerlink" title="NFS服务器的搭建"></a>NFS服务器的搭建</h3><ul>
<li><p>KVM虚拟机动态迁移无需拷贝虚拟机配置文件和磁盘文件，但是需要迁移的主机之间有相同的目录结构放置虚拟机磁盘文件（本例为“&#x2F;opt&#x2F;share”目录），这里的动态迁移是基于共享存储动态迁移，通过NFS来实现，需要QEMU 0.12.2以上版本支持。可以使用以下命令查看安装的QEMU的版本号。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">qemu-img –help|grep version</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先在NFS服务器上，下载安装NFS，kernel-server相当于server端,common是client端，使用命令以下命令进行安装NFS:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server nfs-common -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置NFS服务器，将NFS服务器上的“&#x2F;opt&#x2F;share”目录设为服务目录。首先使用以下命令创建目录，然后修改创建的目录权限，同时如果不放心是否权限修改了，可以查看下文件夹的权限，修改后为“drwxr-xr-x”</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo mkdir /opt/share,</span><br><span class="line">sudo chmod 777 /opt/share</span><br><span class="line">sudo ll /opt</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来使用vim修改<code>/etc/exports</code>:文件添加共享目录，在该文件最后添加以下内容即可。&#x2F;opt&#x2F;share:表示要设置的共享目录，__:表示允许所有的网段访问，也可以使用具体的IP。rw:表示挂载此目录的客户端对该共享目录具有读写权限。sync:表示资料同步写入内存和硬盘。no_root_squash:表示root用户具有对根目录的完全管理访问权限。no_subtree_check:表示不检查父目录的权限。修改完毕后保存退出。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/opt/share (rw,sync,no_subtree_check,no_root_squash)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>/etc/exports</code>文件修改后，使用命令然后进行刷新。最后启动NFS服务，命令如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo exportfs –r</span><br><span class="line">sudo /etc/init.d/rpcbind restart</span><br><span class="line">sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>NFS服务启动后，在Node1上使用以下命令查看远程主机的共享目录，可以看到以下斜体内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo showmount -e 192.168.200.130</span><br><span class="line">root@Service:~# sudo showmount -e 192.168.200.130</span><br><span class="line">Export list for 192.168.200.130:</span><br><span class="line">/opt/share *</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别在Node1和Node2上分别挂载NFS服务器的共享文件夹到本地“&#x2F;opt”目录中，然后将Node1上的的虚拟磁盘文件ubuntu16server.img（前面实验中制作的ubuntu的镜像文件）拷贝到挂载NFS服务器共享目录的文件夹“&#x2F;opt”中(我制作好的镜像文件在&#x2F;root文件夹中)，之后可以看到ubuntu16server.img镜像文件。在节点2上执行同样的操作，但在Node2中不用执行拷贝这一命令。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo mount -t nfs 192.168.200.130:/opt/share /opt -o rw</span><br><span class="line">sudo cp /root/ubuntu16server.img /opt</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载拷贝完成后两节点都有相同的虚拟机磁盘文件存储目录</p>
</li>
</ul>
<h3 id="基于QEMU的虚拟机动态迁移"><a href="#基于QEMU的虚拟机动态迁移" class="headerlink" title="基于QEMU的虚拟机动态迁移"></a>基于QEMU的虚拟机动态迁移</h3><ul>
<li><p>在Node1上使用如下命令启动虚拟机，ubuntu16server.img为前面实验制作的镜像文件，-monitor stdio表示可以进入QEMU监控器，以便接下来执行迁移命令。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -hda ubuntu16server.img -m 1024 -smp 1 -vnc :0 -monitor stdio</span><br><span class="line">(qemu)</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开VNC界面，连接节点1上的QEMU虚拟机,登陆之后并执行“top”命令,可以看到界面一直在发生改变。</p>
</li>
<li><p>在Node2上使用以下命令启动一个虚拟机，该虚拟机并没有真实启动，只是用于等待接收动态迁移过来的内存内容，使用VNC连接后显示界面状态为黑屏，或者是有一行提示。这里需要注意：在Node2上，NFS挂载目录必须与源主机上保持一致；启动客户机命令也需一致，但是需要增加-incoming 选项。“-incoming tcp:0:6666” 这个参数表示在6666 端口建立一个tcp socket 连接用于接收来自于源宿主机的动态迁移的内容，其中“0”表示允许来自任何主机的连接，“-incoming”表示使QEMU进程进入到迁移监听（migration-listen）模式，而不是真正以命令行中的镜像文件运行客户机。另外，这里是以NFS服务器上的镜像文件作为虚拟机磁盘来启动虚拟机，如果有多个用户同时使用NFS服务器上的镜像文件，请将镜像文件在本地进行派生，使用派生后的镜像文件启动虚拟机，具体方式读者可自行查阅相关资料</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -hda /opt/ubuntu16server.img -m 1024 -smp 1 -vnc :0 -incoming tcp:0:6666</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Node1源宿主机的qemu monitor 命令行中输入以下命令迁移虚拟机，进入动态迁移的流程，其中“192.168.200.131”是目标宿主机IP，TCP协议和6666端口与目标宿主机上命令行的-incoming 参数保持一致</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(qemu) migrate tcp:192.168.200.131:6666 //(qemu)为启动镜像时出现的qemu monitor</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Node1上执行”migrate”命令从开始到执行完成，大约十秒钟（视网络而定），在执行完成后迁移成功。迁移后在Node2上，也就是目标宿主机上，之前处于迁移监听状态的虚拟机开始运行，在该虚拟机中可以查看到，原来在Node1上运行的虚拟机上执行的top命令在迁移后仍在继续在Node2上执行。</p>
</li>
<li><p>至此基于QEMU的虚拟机动态迁移完成</p>
</li>
</ul>
<h3 id="基于Libvirt的虚拟机静态迁移"><a href="#基于Libvirt的虚拟机静态迁移" class="headerlink" title="基于Libvirt的虚拟机静态迁移"></a>基于Libvirt的虚拟机静态迁移</h3><ul>
<li><p>静态迁移也叫做常规迁移、离线迁移（Offline Migration）。是在虚拟机关机或暂停的情况下，拷贝虚拟机磁盘文件与配置文件从源宿主机到目标宿主机中，实现的从一台物理机到另一台物理机的迁移。因为虚拟机的文件系统建立在虚拟机镜像文件上面，所以在虚拟机关机的情况下，只需要简单的迁移虚拟机镜像和相应的配置文件到另外一台物理主机上即可。如果需要保存虚拟机迁移之前的状态，那么应该在迁移之前将虚拟机暂停，然后拷贝状态至目标宿主机，最后在目标宿主机重建虚拟机状态，恢复执行。这种方式的迁移过程需要显式的停止虚拟机的运行。从用户角度看，有明确的一段停机时间，虚拟机上的服务不可用。这种迁移方式简单易行，适用于对服务可用性要求不严格的场合。</p>
</li>
<li><p>为网络添加br0网桥</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo brctl addif br0 ens33</span><br><span class="line">sudo brctl stp br0 on</span><br><span class="line">sudo ifconfig ens33 0</span><br><span class="line">sudo dhclient br0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Node1上进行操作，首先确定demo虚拟机状态为“shut off”,如果不是可以执行“destroy ”进行关闭</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo virsh list –all</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备迁移demo虚拟机，查看demo虚拟机的磁盘文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">virsh domblklist</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出虚拟机配置文件demo.xml、ubuntu16.img,将其发送到Node2中与Node1中文件对应的文件夹（demo.xml文件在文章结尾会给出代码）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo scp /root/demo.xml /root/ubuntu16.img 192.168.200.131:/root</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后开始在目标宿主机Node2上进行虚拟机的配置和启动。</p>
</li>
<li><p>使用virsh的子命令define定义并注册demo虚拟机</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo virsh define /root/demo.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动迁移后的demo虚拟机,通过VNC查看,VNC端口查看</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo virsh vncdisplay</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后通过VNC查看是否可以登陆和其他操作</p>
</li>
</ul>
<h3 id="基于Libvirt的虚拟机动态迁移"><a href="#基于Libvirt的虚拟机动态迁移" class="headerlink" title="基于Libvirt的虚拟机动态迁移"></a>基于Libvirt的虚拟机动态迁移</h3><ul>
<li><p>此处我说明下，这种迁移虽然为基于Libvirt的动态迁移，但是其迁移的只是虚拟机的状态而不是虚拟机的状态和文件，这一点我再次特别说明。</p>
</li>
<li><p>将Node1上的“ubuntu16.img”发送到Node2对应的文件夹,此时的demo状态为“shut off”，发送后启动demo虚拟机</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo scp /root/ubuntu16.img 192.168.200.131:/root</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看Node1上虚拟机状态，demo虚拟机保证处于“runing”（如果demo处于“shut off”，将其启动运行“sudo virsh start demo”）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo virsh list –all</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看Node2上虚拟机状态，确保无虚拟机运行，命令如上</p>
</li>
<li><p>通过VNC连接登陆，并执行“top”命令</p>
</li>
<li><p>在Node1上执行“virsh migrate”迁移命令，虚拟机demo在迁移出去的过程中，状态有从“running”到“shut off”的一个改变。–verbose 指迁移demo虚拟机，192.168.200.131为节点2的IP地址，使用tcp协议连接，–unsafe参数表示跳过安全检测, &#x2F;system为以root身份进行状态迁移,qemu+ssh表示为通过ssh通道连接到远程节点的system实例，具有最大权限来管理远程节点上的虚拟机资源</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo virsh migrate –live –verbose demo qemu+ssh://192.168.200.131/system tcp://192.168.200.131 –unsafe</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Node2上,查看虚拟机demo虚拟机状态为“runing”</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo virsh list –all</span><br></pre></td></tr></table></figure>
</li>
<li><p>在迁移过程中，可以通过另外一台客户机一直ping虚拟机demo，查看demo迁移过程中的可连接性。实际上迁移过程除了偶尔有几个包的中断，基本上没有太大影响</p>
</li>
<li><p>此时虽然demo虚拟机已经在Node2上启动了，但是Node2上还没有demo虚拟机的配置文件。这时需要创建配置文件并定义该虚拟机，可以通过迁移过来的虚拟机内存状态创建虚拟机配置文件，然后通过xml配置文件定义虚拟机。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo virsh dumpxml demo &gt; /etc/libvirt/qemu/demo1.xml //之所以命名为demo1.xml是因为，在libvirt静态迁移过程中已经有个demo.xml文件，虽然不在同一个文件夹，为了避免搞混。</span><br><span class="line">sudo virsh define /etc/libvirt/qemu/demo1.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过VNC连接查看，VNC端口号查询。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo virsh vncdisplay demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>在通过VNC连接上后发现迁移前的“top”命令依然在执行</p>
</li>
<li><p>至此，demo虚拟机迁移完成。</p>
</li>
</ul>
<hr>
<h3 id="demo-xml文件中的内容"><a href="#demo-xml文件中的内容" class="headerlink" title="demo.xml文件中的内容"></a>demo.xml文件中的内容</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE</span></span><br><span class="line"><span class="comment">OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:</span></span><br><span class="line"><span class="comment">  virsh edit demo</span></span><br><span class="line"><span class="comment">or other application using the libvirt API.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;kvm&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uuid</span>&gt;</span>782ca9b9-8403-4fcd-979e-e4f038aaeb15<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">currentMemory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">currentMemory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&#x27;static&#x27;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&#x27;x86_64&#x27;</span> <span class="attr">machine</span>=<span class="string">&#x27;pc-i440fx-trusty&#x27;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boot</span> <span class="attr">dev</span>=<span class="string">&#x27;cdrom&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boot</span> <span class="attr">dev</span>=<span class="string">&#x27;hd&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">acpi</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">apic</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pae</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&#x27;localtime&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/kvm<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;disk&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;qcow2&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/home/ubuntu16.img&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hda&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;drive&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">target</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">controller</span> <span class="attr">type</span>=<span class="string">&#x27;usb&#x27;</span> <span class="attr">index</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x01&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x2&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">controller</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">controller</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">index</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">model</span>=<span class="string">&#x27;pci-root&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">controller</span> <span class="attr">type</span>=<span class="string">&#x27;ide&#x27;</span> <span class="attr">index</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x01&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x1&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">controller</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;bridge&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;52:54:00:c0:a2:8a&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span> <span class="attr">bridge</span>=<span class="string">&#x27;br0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;rtl8139&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x03&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;tablet&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;usb&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;mouse&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ps2&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;keyboard&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ps2&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">&#x27;vnc&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;-1&#x27;</span> <span class="attr">autoport</span>=<span class="string">&#x27;yes&#x27;</span> <span class="attr">listen</span>=<span class="string">&#x27;0.0.0.0&#x27;</span> <span class="attr">keymap</span>=<span class="string">&#x27;en-us&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;cirrus&#x27;</span> <span class="attr">vram</span>=<span class="string">&#x27;9216&#x27;</span> <span class="attr">heads</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x02&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">memballoon</span> <span class="attr">model</span>=<span class="string">&#x27;virtio&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x04&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">memballoon</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python后端</category>
      </categories>
      <tags>
        <tag>虚拟机迁移</tag>
        <tag>NFS</tag>
        <tag>动态迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进制转换</title>
    <url>/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="Python中实现的进制间的转换"><a href="#Python中实现的进制间的转换" class="headerlink" title="Python中实现的进制间的转换"></a>Python中实现的进制间的转换</h3><blockquote>
<p>在python中可以使用Python的内置函数进行进制间的转换。<br>  bin()：其他进制转二进制<br>  oct()：其他进制转八进制<br>  int()：其他进制转十进制<br>  hex()：其他进制转十六进制  </p>
</blockquote>
<span id="more"></span>
<h3 id="二进制、八进制、十六进制的形式"><a href="#二进制、八进制、十六进制的形式" class="headerlink" title="二进制、八进制、十六进制的形式"></a>二进制、八进制、十六进制的形式</h3><ul>
<li>二进制：以“0b”开头，如：0b111为十进制的7</li>
<li>八进制：以“0”开头，如：026为十进制的22</li>
<li>十六进制：以“0x”开头，如：0x1f为十进制的31</li>
</ul>
<h3 id="二进制、八进制、十六进制对照表"><a href="#二进制、八进制、十六进制对照表" class="headerlink" title="二进制、八进制、十六进制对照表"></a>二进制、八进制、十六进制对照表</h3><p><img src="/userImages/dzb.png" alt="对照表"></p>
<h3 id="二进制、八进制、十六进制转十进制"><a href="#二进制、八进制、十六进制转十进制" class="headerlink" title="二进制、八进制、十六进制转十进制"></a>二进制、八进制、十六进制转十进制</h3><p>使用int()函数，第一个参数是要转换的数字，类型为字符串，第二个参数是该数几进制的数，转化结果为一个十进制的数。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">二进制转十进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0b1111&#x27;</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">15</span></span><br><span class="line">八进制转十进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;67&#x27;</span>,<span class="number">8</span>)</span><br><span class="line"><span class="number">55</span></span><br><span class="line">十六进制转十进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0x1f&#x27;</span>,<span class="number">16</span>)</span><br><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure>

<h3 id="八进制、十进制、十六进制转二进制"><a href="#八进制、十进制、十六进制转二进制" class="headerlink" title="八进制、十进制、十六进制转二进制"></a>八进制、十进制、十六进制转二进制</h3><p>使用bin()函数，需要先将八进制、十六进制转换为十进制，然后才能转换为二进制，<br>即八进制&#x2F;十六进制 —&gt; 十进制 —&gt; 二进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">八进制转二进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="string">&#x27;016&#x27;</span>,<span class="number">8</span>))</span><br><span class="line"><span class="string">&#x27;0b1110&#x27;</span></span><br><span class="line">十进制转二进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">14</span>)</span><br><span class="line"><span class="string">&#x27;0b1110&#x27;</span></span><br><span class="line">十六进制转二进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="string">&#x27;0xe&#x27;</span>,<span class="number">16</span>))</span><br><span class="line"><span class="string">&#x27;0b1110&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="二进制、十进制、十六进制转八进制"><a href="#二进制、十进制、十六进制转八进制" class="headerlink" title="二进制、十进制、十六进制转八进制"></a>二进制、十进制、十六进制转八进制</h3><p>使用oct()函数可以直接进行进制的转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">二进制转八进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">0b1110</span>)</span><br><span class="line"><span class="string">&#x27;016&#x27;</span></span><br><span class="line">十进制转八进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">14</span>)</span><br><span class="line"><span class="string">&#x27;016&#x27;</span></span><br><span class="line">十六进制转八进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">0xe</span>)</span><br><span class="line"><span class="string">&#x27;016&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="二进制、八进制、十进制转十六进制"><a href="#二进制、八进制、十进制转十六进制" class="headerlink" title="二进制、八进制、十进制转十六进制"></a>二进制、八进制、十进制转十六进制</h3><p>使用hex()函数，需要先将二进制、八进制转换为十进制，然后才能转换为十六进制，<br>即二进制&#x2F;八进制 —&gt; 十进制 —&gt; 十六进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">二进制转十六进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;0b1110&#x27;</span>,<span class="number">2</span>))</span><br><span class="line"><span class="string">&#x27;0xe&#x27;</span></span><br><span class="line">八进制转十六进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;016&#x27;</span>,<span class="number">8</span>))</span><br><span class="line"><span class="string">&#x27;0xe&#x27;</span></span><br><span class="line">十进制转十六进制：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">14</span>)</span><br><span class="line"><span class="string">&#x27;0xe&#x27;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python杂记</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>八进制</tag>
        <tag>十六进制</tag>
      </tags>
  </entry>
</search>
